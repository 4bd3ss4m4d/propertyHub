|-./
  |-client/
    |-vite.config.js
      import { defineConfig } from 'vite';
      import react from '@vitejs/plugin-react-swc';
      
      export default defineConfig({
        plugins: [react()],
        server: {
          proxy: {
            '/api': {
              target: process.env.VITE_API_URL || 'http://localhost:5000', // Use the environment variable
              changeOrigin: true,
              secure: false,
            },
          },
        },
      });
    |-eslint.config.js
      import js from '@eslint/js'
      import globals from 'globals'
      import react from 'eslint-plugin-react'
      import reactHooks from 'eslint-plugin-react-hooks'
      import reactRefresh from 'eslint-plugin-react-refresh'
      
      export default [
        { ignores: ['dist'] },
        {
          files: ['**/*.{js,jsx}'],
          languageOptions: {
            ecmaVersion: 2020,
            globals: globals.browser,
            parserOptions: {
              ecmaVersion: 'latest',
              ecmaFeatures: { jsx: true },
              sourceType: 'module',
            },
          },
          settings: { react: { version: '18.3' } },
          plugins: {
            react,
            'react-hooks': reactHooks,
            'react-refresh': reactRefresh,
          },
          rules: {
            ...js.configs.recommended.rules,
            ...react.configs.recommended.rules,
            ...react.configs['jsx-runtime'].rules,
            ...reactHooks.configs.recommended.rules,
            'react/jsx-no-target-blank': 'off',
            'react-refresh/only-export-components': [
              'warn',
              { allowConstantExport: true },
            ],
          },
        },
      ]
    |-src/
      |-main.jsx
        import React from 'react';
        import { createRoot } from 'react-dom/client';
        import App from './App';
        import { store } from './redux/store';
        import { Provider } from 'react-redux';
        import { loadUserFromStorage } from './redux/userSlice'; // Correct import
        
        const root = createRoot(document.getElementById('root'));
        
        // Load user from localStorage on app start
        store.dispatch(loadUserFromStorage());
        
        root.render(
          <React.StrictMode>
            <Provider store={store}>
              <App />
            </Provider>
          </React.StrictMode>
        );
      |-App.jsx
        import React from "react";
        import { Routes, Route, BrowserRouter } from "react-router-dom";
        import "./App.css";
        import Home from "./pages/Home";
        import FAQ from "./pages/FAQ";
        import SignUp from "./pages/SignUp";
        import SignIn from "./pages/SignIn";
        import { AuthSuccess, AuthFailure } from "./pages/AuthStatus";
        import Profile from "./pages/Profile";
        import Create from "./pages/Create";
        
        function App() {
          return (
            <BrowserRouter>
            <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/faq" element={<FAQ />} />
              <Route path="/signup" element={<SignUp />} />
              <Route path="/signup/success" element={<AuthSuccess type="SignUp" />} /> 
              <Route path="/signup/failure" element={<AuthFailure type="SignUp" />} /> 
              <Route path="/signin" element={<SignIn />} />
              <Route path="/signin/success" element={<AuthSuccess type="SignIn" />} /> 
              <Route path="/signin/failure" element={<AuthFailure type="SignIn" />} /> 
              <Route path="/profile" element={<Profile/>} /> 
              <Route path="/create" element={<Create/>} /> 
        
            </Routes>
            </BrowserRouter>
          );
        }
        
        export default App;
        
      |-components/
        |-FormInput.jsx
          import React from 'react';
          import '../assets/styles/formInput.css';
          
          const FormInput = ({ type, placeholder, value, onChange, className }) => {
            return (
              <input
                type={type}
                placeholder={placeholder}
                required
                className={className}
                value={value}
                onChange={onChange}
              />
            );
          };
          
          export default FormInput;
          
        |-SignUpFormLocal.jsx
          import React, { useState } from 'react';
          import InputField from './InputField';
          import FormInput from './FormInput';
          import { registerUser, checkEmailAvailability, checkUsernameAvailability } from '../services/authServices';
          import { validateField } from '../services/validationHelper';
          import { useNavigate } from 'react-router-dom';
          import ErrorDisplay from './ErrorDisplay'; // Import the ErrorDisplay component
          import '../assets/styles/signupLocalForm.css';
          
          const SignUpForm = () => {
            const [firstName, setFirstName] = useState('');
            const [lastName, setLastName] = useState('');
            const [username, setUsername] = useState('');
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
          
            // Email state
            const [emailLoading, setEmailLoading] = useState(false);
            const [emailStatus, setEmailStatus] = useState(null); // 'valid', 'invalid', or 'error'
            const [emailError, setEmailError] = useState('');
          
            // Username state
            const [usernameLoading, setUsernameLoading] = useState(false);
            const [usernameStatus, setUsernameStatus] = useState(null); // 'valid', 'invalid', or 'error'
            const [usernameError, setUsernameError] = useState('');
          
            // Error and Success Messages
            const [errorMessages, setErrorMessages] = useState([]); // List of general error messages
            const [successMessage, setSuccessMessage] = useState(''); // Success message
            const [errors, setErrors] = useState([]); // Validation errors from the API
          
            const navigate = useNavigate();
          
            // Clear the error message on input change for username
            const handleUsernameChange = (e) => {
              setUsername(e.target.value);
              setUsernameError('');  // Clear error when user types
              setUsernameStatus(null); // Reset status when user types
            };
          
            // Clear the error message on input change for email
            const handleEmailChange = (e) => {
              setEmail(e.target.value);
              setEmailError('');  // Clear error when user types
              setEmailStatus(null); // Reset status when user types
            };
          
            // Handle validation for email on blur
            const handleEmailBlur = () =>
              validateField('email', email, setEmailLoading, setEmailStatus, setEmailError, checkEmailAvailability);
          
            // Handle validation for username on blur
            const handleUsernameBlur = () =>
              validateField('username', username, setUsernameLoading, setUsernameStatus, setUsernameError, checkUsernameAvailability);
          
            // Handle form submission
            const handleSignUp = async (e) => {
              e.preventDefault();
              console.log('Sign Up button clicked'); // Debug log
          
              // Check if the button is disabled
              if (loading || emailStatus === 'invalid' || usernameStatus === 'invalid' || !emailStatus || !usernameStatus) {
                console.log('Button is disabled, form submission prevented');
                return;
              }
          
              setLoading(true);
              setErrorMessages([]);  // Clear previous error messages
              setSuccessMessage(''); // Clear previous success message
          
              console.log('Attempting to register user with:', { firstName, lastName, username, email, password }); // Debug log
          
              try {
                console.log('Calling registerUser function'); // Debug log
                const response = await registerUser({ firstName, lastName, username, email, password });
                console.log('Received response:', response); // Debug log
                
                if (response.data.message === "User registered successfully!") {
                  // Redirect to the success page on successful registration
                  navigate('/signup/success'); // Redirect to AuthSuccess page
                } else {
                  setErrorMessages(["An unexpected error occurred. Please try again."]);
                }
              } catch (err) {
                console.error('Error during registration:', err); // Debug log
                if (err.response && err.response.data && err.response.data.error) {
                  const validationErrors = err.response.data.error.errors || [];
                  setErrors(validationErrors); // Set validation errors from the server response
                } else if (err.request) {
                  setErrorMessages(["No response received from server. Please try again."]);
                } else {
                  setErrorMessages([`Error: ${err.message}`]);
                }
              } finally {
                setLoading(false);
              }
            };
          
            return (
              <div className="register-container">
                <h1>Create an Account</h1>
          
                {/* Display success message */}
                {successMessage && <p className="success-message">{successMessage}</p>}
          
                {/* Display general error messages */}
                {errorMessages.length > 0 && (
                  <div className="error-messages">
                    {errorMessages.map((message, index) => (
                      <p key={index} className="error-message">{message}</p>
                    ))}
                  </div>
                )}
          
                <form onSubmit={handleSignUp}>
                  <div className="name-fields">
                    <FormInput
                      type="text"
                      placeholder="First Name*"
                      value={firstName}
                      onChange={(e) => setFirstName(e.target.value)}
                      className="input-firstname"
                    />
                    <FormInput
                      type="text"
                      placeholder="Last Name*"
                      value={lastName}
                      onChange={(e) => setLastName(e.target.value)}
                      className="input-lastname"
                    />
                  </div>
          
                  {/* Username Input Field with validation */}
                  <InputField
                    type="text"
                    placeholder="Username*"
                    value={username}
                    onChange={handleUsernameChange}  // Handle username change to clear errors
                    onBlur={handleUsernameBlur}      // Trigger validation on blur
                    status={usernameStatus}          // 'valid' or 'invalid'
                    loading={usernameLoading}        // Show loading icon while checking
                  />
                  {/* Error message when username is invalid */}
                  {!usernameLoading && usernameStatus === 'invalid' && (
                    <p className="error-message">{usernameError}</p>  // Show only if username is invalid
                  )}
          
                  {/* Email Input Field with validation */}
                  <InputField
                    type="email"
                    placeholder="Email Address*"
                    value={email}
                    onChange={handleEmailChange}     // Handle email change to clear errors
                    onBlur={handleEmailBlur}         // Trigger validation on blur
                    status={emailStatus}             // 'valid' or 'invalid'
                    loading={emailLoading}           // Show loading icon while checking
                  />
                  {/* Error message when email is invalid */}
                  {!emailLoading && emailStatus === 'invalid' && (
                    <p className="error-message">{emailError}</p>  // Show only if email is invalid
                  )}
          
                  {/* Password Input */}
                  <FormInput
                    type="password"
                    placeholder="Password*"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="input-password"
                  />
          
                  {/* Display validation errors */}
                  <ErrorDisplay errors={errors} />
          
                  {/* Submit Button */}
                  <button
                    type="submit"
                    className="continue-button"
                    disabled={loading || emailStatus === 'invalid' || usernameStatus === 'invalid' || !emailStatus || !usernameStatus}
                  >
                    {loading ? 'Signing up...' : 'Sign Up'}
                  </button>
                </form>
              </div>
            );
          };
          
          export default SignUpForm;
          
        |-Footer.jsx
          import React, { useState } from "react";
          import "../assets/styles/footer.css";
          import { Link } from "react-router-dom";
          
          export default function Footer() {
              const [email, setEmail] = useState("");
          
              const handleEmail = (e)=> { 
                      setEmail(e.target.value)
              }
          
          
              const handleSubmit = (e)=>{
                  e.preventDefault();
                  console.log(email)
          
              }
            return (
              <footer className="footer">
                <div className="footer-content">
                  <div className="footer-about">
                    <h2>PropertyHub</h2>
                    <p>
                      Your trusted partner in real estate. Helping you find your dream
                      home or sell your property with ease.
                    </p>
                    <div className="social-media">
                      <a
                        href="https://facebook.com/PropertyHub"
                        aria-label="Facebook"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M22.675 0h-21.35c-.733 0-1.325.592-1.325 1.325v21.351c0 .732.592 1.324 1.325 1.324h11.494v-9.294h-3.124v-3.622h3.124v-2.671c0-3.1 1.894-4.787 4.659-4.787 1.325 0 2.462.099 2.793.143v3.24l-1.917.001c-1.504 0-1.795.715-1.795 1.764v2.31h3.587l-.467 3.622h-3.12v9.294h6.116c.732 0 1.324-.592 1.324-1.324v-21.35c0-.733-.592-1.325-1.325-1.325z" />
                        </svg>
                      </a>
                      <a
                        href="https://twitter.com/PropertyHub"
                        aria-label="Twitter"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M24 4.557c-.883.392-1.83.656-2.825.775 1.014-.608 1.794-1.57 2.163-2.723-.949.564-2.003.974-3.127 1.195-.896-.954-2.173-1.55-3.591-1.55-2.717 0-4.917 2.201-4.917 4.917 0 .386.043.762.127 1.124-4.083-.205-7.702-2.159-10.125-5.134-.423.724-.666 1.561-.666 2.457 0 1.694.863 3.188 2.175 4.065-.801-.025-1.555-.245-2.212-.612v.061c0 2.367 1.683 4.342 3.918 4.789-.41.111-.841.171-1.287.171-.314 0-.621-.031-.921-.087.623 1.947 2.432 3.362 4.576 3.402-1.675 1.313-3.785 2.096-6.076 2.096-.395 0-.786-.023-1.17-.068 2.165 1.389 4.736 2.2 7.504 2.2 9.005 0 13.92-7.461 13.92-13.92 0-.212-.005-.425-.014-.637.954-.688 1.786-1.548 2.443-2.532z" />
                        </svg>
                      </a>
                      <a
                        href="https://instagram.com/PropertyHub"
                        aria-label="Instagram"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M12 2.163c3.204 0 3.584.012 4.849.07 1.366.062 2.633.333 3.608 1.308.975.975 1.246 2.242 1.308 3.608.058 1.265.069 1.645.069 4.849s-.012 3.584-.07 4.849c-.062 1.366-.333 2.633-1.308 3.608-.975.975-2.242 1.246-3.608 1.308-1.265.058-1.645.069-4.849.069s-3.584-.012-4.849-.07c-1.366-.062-2.633-.333-3.608-1.308-.975-.975-1.246-2.242-1.308-3.608-.058-1.265-.069-1.645-.069-4.849s.012-3.584.07-4.849c.062-1.366.333-2.633 1.308-3.608.975-.975 2.242-1.246 3.608-1.308 1.265-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-1.702.076-3.23.487-4.388 1.646-1.158 1.158-1.569 2.686-1.646 4.388-.058 1.28-.072 1.688-.072 4.947s.014 3.667.072 4.947c.076 1.702.487 3.23 1.646 4.388 1.158 1.158 2.686 1.569 4.388 1.646 1.28.058 1.688.072 4.947.072s3.667-.014 4.947-.072c1.702-.076 3.23-.487 4.388-1.646 1.158-1.158 1.569-2.686 1.646-4.388.058-1.28.072-1.688.072-4.947s-.014-3.667-.072-4.947c-.076-1.702-.487-3.23-1.646-4.388-1.158-1.158-2.686-1.569-4.388-1.646-1.28-.058-1.688-.072-4.947-.072z" />
                          <path d="M12 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.162 6.162 6.162 6.162-2.759 6.162-6.162-2.759-6.162-6.162-6.162zm0 10.162c-2.206 0-4-1.794-4-4s1.794-4 4-4 4 1.794 4 4-1.794 4-4 4zm6.406-11.845c-.796 0-1.443.647-1.443 1.443s.647 1.443 1.443 1.443 1.443-.647 1.443-1.443-.647-1.443-1.443-1.443z" />
                        </svg>
                      </a>
                    </div>
                  </div>
          
                  <div className="footer-links">
                    <h3>Quick Links</h3>
                    <ul>
                      <li>
                        <Link to="/">Home</Link>
                      </li>
                      <li>
                        <Link to="/profile">Profile</Link>
                      </li>
                    </ul>
                  </div>
          
                  <div className="footer-newsletter">
                    <h3>Subscribe to our Newsletter</h3>
                    <form>
                      <input type="email" placeholder="Enter your email" onChange={handleEmail}/>
                      <button type="submit" onClick={handleSubmit}>Subscribe</button>
                    </form>
                  </div>
                </div>
          
                <div className="footer-bottom">
                  <p>&copy; {new Date().getFullYear()} PropertyHub. All rights reserved.</p>
                </div>
              </footer>
            );
          }
        |-card.jsx
          import React from "react";
          import '../assets/styles/card.css'
          
          export default function Card(){
              return(
                  <div className="cardsContainer">
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
          
                  </div>
              )
          };
        |-TextFieldsAndCheckbox.jsx
          import React from "react";
          
          export default function TextFieldsAndCheckbox({ data, handleChange }) {
            return (
              <>
                <input type="text" placeholder="Name" name="name" onChange={handleChange} />
                <input type="text" placeholder="Description" name="description" onChange={handleChange} />
                <input type="text" placeholder="Address" name="address" onChange={handleChange} required />
                <input type="text" placeholder="Phone" name="phone" onChange={handleChange} />
                <h3>This is for?</h3> 
                <div className="check">
            <label htmlFor="rent" className="cheking">Rent  
              <input
                type="checkbox"
                name="rent"
                id="rent"
                checked={data.rent}
                onChange={handleChange}
              />
            </label>
          
            <label htmlFor="sell" className="cheking">Sell 
              <input
                type="checkbox"
                name="sell"
                id="sell"
                checked={data.sell}
                onChange={handleChange}
              />
            </label>
          </div>
          
                <h3>Include :</h3>
                <div className="check">
                  <label htmlFor="parking" className="cheking">Parking <input type="checkbox" name="parking" id="parking" onChange={handleChange} /></label>
                  
          
                  <label htmlFor="wifi" className="cheking">WI-FI  <input type="checkbox" name="wifi" id="wifi" onChange={handleChange} /></label>
                 
          
                  <label htmlFor="petFriendly" className="cheking">Pet-friendly <input type="checkbox" name="petFriendly" id="petFriendly" onChange={handleChange} /></label>
                  
                </div>
          
                <label htmlFor="rooms">Rooms</label>
                <input type="number" name="rooms" min="1" id="rooms" onChange={handleChange} required />
          
                <label htmlFor="bathrooms">Bathrooms</label>
                <input type="number" name="bathrooms" min="1" id="bathrooms" onChange={handleChange} required />
          
                <label htmlFor="price" >Price</label>
                <div className="price">
                  <input type="number" name="price" min="0" id="price" onChange={handleChange} required />
                  <p>{data.rent ? "$ / night" : "$"}</p>
                </div>
              </>
            );
          }
        |-ImageUpload.jsx
          import React from "react";
          
          export default function ImageUpload({ handleFileChange, createImagePreviews }) {
            return (
              <>
                <label htmlFor="images">Upload Images</label>
                <input
                  type="file"
                  name="images"
                  id="images"
                  accept="image/*"
                  multiple
                  onChange={handleFileChange}
                />
                
                <div className="image-previews">
                  {createImagePreviews()}
                </div>
              </>
            );
          }
        |-search.jsx
          import React, { useState } from "react";
          import "../assets/styles/search.css";
          
          export default function Search() {
            const [filters, setFilters] = useState({
              offerType: "",
              location: "",
              bathrooms: "",
              rooms: "",
              wifi: false,
              petFriendly: false,
              parking: false,
              priceMax: "",
              more: false,
            });
          
            const handleInputChange = (e) => {
              const { name, value, type, checked } = e.target;
              setFilters({
                ...filters,
                [name]: type === "checkbox" ? checked : value,
              });
            };
          
            const handleSubmit = (e) => {
              e.preventDefault();
              console.log("Filters applied:", filters);
              // Implement search logic here
            };
          
            return (
              <form className="serchContainer" onSubmit={handleSubmit}>
                <div className="OfferAndLocation">
                  <div className="offer-type">
                    <p>Offer Type</p>
                    <select
                      name="offerType"
                      className="select"
                      value={filters.offerType}
                      onChange={handleInputChange}
                    >
                      <option value="" disabled hidden>
                        Select Offer Type
                      </option>
                      <option value="rent">Rent</option>
                      <option value="sale">Sale</option>
                    </select>
                  </div>
          
                  <div className="location">
                    <p>Location</p>
                    <input
                      type="text"
                      name="location"
                      placeholder="City/Location name"
                      value={filters.location}
                      onChange={handleInputChange}
                    />
                  </div>
                </div>
          
                {filters.more && (
                  <div className="filters show">
                    <div className="filter-group">
                      <label htmlFor="bathrooms">Bathrooms</label>
                      <input
                        type="number"
                        name="bathrooms"
                        min="1"
                        placeholder="e.g., 2"
                        value={filters.bathrooms}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <label htmlFor="rooms">Rooms</label>
                      <input
                        type="number"
                        name="rooms"
                        min="1"
                        placeholder="e.g., 3"
                        value={filters.rooms}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <label htmlFor="priceMax">Price Maximum</label>
                      <input
                        type="number"
                        name="priceMax"
                        min="0"
                        placeholder="e.g., 1000"
                        value={filters.priceMax}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <div className="checkbox-container">
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="wifi"
                            id="wifi"
                            checked={filters.wifi}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="wifi">WiFi</label>
                        </div>
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="petFriendly"
                            id="petFriendly"
                            checked={filters.petFriendly}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="petFriendly">Pet Friendly</label>
                        </div>
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="parking"
                            id="parking"
                            checked={filters.parking}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="parking">Parking</label>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
          
                <div className="actions">
                  <button type="submit" className="button search-button">
                    Search
                  </button>
                  <button
                    type="button"
                    className="button filter-button"
                    onClick={() => setFilters({ ...filters, more: !filters.more })}
                  >
                    {filters.more ? "Hide Filters" : "More Filters"}
                  </button>
                </div>
              </form>
            );
          }
        |-InputField.jsx
          import React from 'react';
          import { FaCheck, FaTimes } from 'react-icons/fa';
          import '../assets/styles/inputField.css';
          
          const InputField = ({ type, placeholder, value, onChange, onBlur, status, loading }) => {
            return (
              <div className="input-wrapper">
                <input
                  type={type}
                  placeholder={placeholder}
                  value={value}
                  onChange={onChange}
                  onBlur={onBlur}
                  className={`input-field ${status ? status : ''}`}
                />
                <div className="icon-container">
                  {loading && <div className="loading-icon"></div>}
          
                  {/* Show icons only if value is not empty and loading is false */}
                  {!loading && value && status === 'valid' && <FaCheck className="valid-icon" />}  {/* Green check for valid */}
                  {!loading && value && status === 'invalid' && <FaTimes className="invalid-icon" />} {/* Red cross for invalid */}
                </div>
              </div>
            );
          };
          
          export default InputField;
          
        |-ErrorDisplay.jsx
          import React from 'react';
          
          const ErrorDisplay = ({ errors }) => {
            // Check if there are no errors or if errors is not an array
            if (!errors || !Array.isArray(errors) || errors.length === 0) {
              return null; // Don't render anything if there are no errors
            }
          
            // Group errors by field
            const groupedErrors = errors.reduce((acc, error) => {
              const field = error.field || 'general'; // Use 'general' if field is not specified
              if (!acc[field]) {
                acc[field] = [];
              }
              acc[field].push(error.message);
              return acc;
            }, {});
          
            return (
              <div className="error-display">
                {Object.entries(groupedErrors).map(([field, messages]) => (
                  <div key={field} className="error-category">
                    <h4>{field.charAt(0).toUpperCase() + field.slice(1)}:</h4>
                    <ul>
                      {messages.map((message, index) => (
                        <li key={index}>{message}</li>
                      ))}
                    </ul>
                  </div>
                ))}
              </div>
            );
          };
          
          export default ErrorDisplay;
          
        |-SignUpOAuth.jsx
          import React, { useState, useEffect } from 'react';
          import { useSearchParams } from 'react-router-dom';
          import '../assets/styles/signupOAuthForm.css';  // OAuth-specific styling
          
          const SignUpOAuth = () => {
            const [searchParams] = useSearchParams();
            const [errorMessage, setErrorMessage] = useState('');
          
            useEffect(() => {
              const message = searchParams.get('message');
              if (message) {
                setErrorMessage(message);
              }
            }, [searchParams]);
          
            const redirectToGoogleSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/google/signup`;
            };
          
            const redirectToMicrosoftSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/microsoft/signup`;
            };
          
            const redirectToAppleSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/apple/signup`;
            };
          
            return (
              <div className="register-container">
                <h1>Create an Account</h1>
                {errorMessage && <p className="error-message">{errorMessage}</p>}
                
                <div className="divider">
                  <hr /> <span>Sign up with</span> <hr />
                </div>
                
                <div className="social-login">
                  <button className="social-button google" onClick={redirectToGoogleSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg" alt="Google Logo" />
                    Continue with Google
                  </button>
          
                  <button className="social-button microsoft" onClick={redirectToMicrosoftSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/1024px-Microsoft_logo.svg.png" alt="Microsoft Logo" />
                    Continue with Microsoft
                  </button>
          
                  <button className="social-button apple" onClick={redirectToAppleSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg" alt="Apple Logo" />
                    Continue with Apple
                  </button>
                </div>
              </div>
            );
          };
          
          export default SignUpOAuth;
          
        |-navbar.jsx
          import React, { useState } from 'react';
          import { NavLink, useNavigate } from 'react-router-dom';
          import Flag from 'react-world-flags';
          import '../assets/styles/navbar.css';
          import { FaBars, FaTimes, FaUser, FaGlobe, FaQuestionCircle } from 'react-icons/fa';
          import { useSelector } from 'react-redux';
          import { SignOut } from '../services/authServices';
          
          export default function Navbar() {
            const { currentUser } = useSelector((state) => state.user);
            console.log(currentUser);
            
            const [toggle, setToggle] = useState({
              isMobileMenuOpen: false,
              isProfileMenuOpen: false,
              isLanguageMenuOpen: false,
              isProfileOpen: false
            });
          
            const navigate = useNavigate();
          
            const handleToggle = (menu) => {
              setToggle((prevState) => ({
                isMobileMenuOpen: menu === 'mobile' ? !prevState.isMobileMenuOpen : false,
                isProfileMenuOpen: menu === 'profile' ? !prevState.isProfileMenuOpen : false,
                isLanguageMenuOpen: menu === 'language' ? !prevState.isLanguageMenuOpen : false,
                isProfileOpen: menu === 'profileLogged' ? !prevState.isProfileOpen : false,
              }));
            };
          
            return (
              <header className="navbar">
                {/* Hamburger & FAQ Icon */}
                <div className="hamburger-menu">
                  {toggle.isMobileMenuOpen ? (
                    <FaTimes onClick={() => handleToggle('mobile')} className="icon" />
                  ) : (
                    <>
                      <FaBars onClick={() => handleToggle('mobile')} className="icon" />
                      <FaQuestionCircle onClick={() => navigate('/faq')} className="icon faq-icon" /> {/* FAQ Icon */}
                    </>
                  )}
                </div>
          
                {/* Center Logo */}
                <div className="logo">
                  <NavLink to="/">
                    <img 
                      src="https://i.ibb.co/mv6JJbL/Property-Hub-Logo-White.png" 
                      alt="PropertyHub Logo" 
                      className="logo-img"
                    />
                  </NavLink>
                </div>
          
                {/* Right-side Icons */}
                <div className="right-icons">
                  {toggle.isLanguageMenuOpen ? (
                    <FaTimes onClick={() => handleToggle('language')} className="icon" />
                  ) : (
                    <FaGlobe onClick={() => handleToggle('language')} className="icon" />
                  )}
                  {currentUser ? (
                    <div className="name-text profile-icon" onClick={() => handleToggle('profileLogged')}>
                      {currentUser.username}
                    </div>
                  ) : (
                    <FaUser onClick={() => handleToggle('profile')} className="icon profile-icon" />
                  )}
                </div>
          
                {/* Mobile Menu - Buy, Rent, Sell, Agents */}
                {toggle.isMobileMenuOpen && (
                  <div className="mobile-menu">
                    <NavLink to="/buy" className="menu-link" onClick={() => handleToggle('mobile')}>Buy</NavLink>
                    <NavLink to="/rent" className="menu-link" onClick={() => handleToggle('mobile')}>Rent</NavLink>
                    <NavLink to="/sell" className="menu-link" onClick={() => handleToggle('mobile')}>Sell</NavLink>
                    <NavLink to="/agents" className="menu-link" onClick={() => handleToggle('mobile')}>Agents</NavLink>
                  </div>
                )}
          
                {/* Profile Menu - Sign In & Sign Up */}
                {toggle.isProfileMenuOpen && (
                  <div className="profile-menu">
                    <button onClick={() => navigate('/signin')} className="profile-button">Sign In</button>
                    <button onClick={() => navigate('/signup')} className="profile-button">Sign Up</button>
                  </div>
                )}
          
                {/* Logged-in Profile Menu */}
                {toggle.isProfileOpen && (
                  <div className="profile-menu">
                    <button onClick={() => navigate('/profile')} className="profile-button">Profile</button>
                    <button onClick={() => SignOut()} className="profile-button">Sign Out</button>
                  </div>
                )}
          
                {/* Language Menu */}
                {toggle.isLanguageMenuOpen && (
                  <div className="language-menu">
                    <div className="language-option">
                      <Flag code="US" className="flag-icon" /> <span>English</span>
                    </div>
                    <div className="language-option">
                      <Flag code="MA" className="flag-icon" /> <span>العربية</span>
                    </div>
                    <div className="language-option">
                      <Flag code="FR" className="flag-icon" /> <span>Français</span>
                    </div>
                    <div className="language-option">
                      <Flag code="ES" className="flag-icon" /> <span>Español</span>
                    </div>
                    <div className="language-option">
                      <Flag code="DE" className="flag-icon" /> <span>Deutsch</span>
                    </div>
                    <div className="language-option">
                      <Flag code="BR" className="flag-icon" /> <span>Português</span>
                    </div>
                  </div>
                )}
              </header>
            );
          }
      |-redux/
        |-store.js
          import { configureStore } from '@reduxjs/toolkit';
          import userReducer from './userSlice';
          
          export const store = configureStore({
            reducer: {
              user: userReducer,
            },
          });
        |-userSlice.js
          import { createSlice } from '@reduxjs/toolkit';
          import Cookies from 'js-cookie';
          
          const USER_STORAGE_KEY = 'propertyHubUser';
          
          // Initial state
          const initialState = {
            currentUser: null,
          };
          
          // Create user slice
          const userSlice = createSlice({
            name: 'user',
            initialState,
            reducers: {
              setUser: (state, action) => {
                state.currentUser = action.payload;
                // Save user to localStorage
                localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(action.payload));
              },
              clearUser: (state) => {
                state.currentUser = null;
                // Remove user from localStorage
                localStorage.removeItem(USER_STORAGE_KEY);
              },
            },
          });
          
          // Export actions
          export const { setUser, clearUser } = userSlice.actions;
          
          // Thunk to load user data from localStorage or cookies
          export const loadUserFromStorage = () => (dispatch) => {
            // Try to load user from localStorage
            const savedUser = localStorage.getItem(USER_STORAGE_KEY);
          
            if (savedUser) {
              dispatch(setUser(JSON.parse(savedUser)));
            } else {
              // Fallback to loading user from cookies (if you want to)
              const token = Cookies.get('propertyHubAuthToken');
              if (token) {
                const userData = { token }; // You can decode token here or fetch data from API
                dispatch(setUser(userData));
              }
            }
          };
          
          // Export reducer
          export default userSlice.reducer;
      |-assets/
        |-styles/
      |-pages/
        |-FAQ.jsx
          import React, { useEffect, useState } from 'react';
          import axios from 'axios';
          import '../assets/styles/faq.css';
          import Navbar from '../components/navbar';
          import Footer from '../components/Footer';
          
          const FAQ = () => {
            const [faqs, setFaqs] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
          
            // Fetch FAQs from the API
            useEffect(() => {
              const fetchFaqs = async () => {
                try {
                  const response = await axios.get('/api/faqs');
                  setFaqs(response.data);
                  setLoading(false);
                } catch (err) {
                  setError(err.response?.data?.message || 'Failed to fetch FAQs');
                  setLoading(false);
                }
              };
          
              fetchFaqs();
            }, []);
          
            const toggleFaq = (id) => {
              setFaqs(faqs.map(faq => faq._id === id ? { ...faq, open: !faq.open } : faq));
            };
          
            return (
              <>
              <Navbar />
              <div className="faq-page">
                {/* FAQ Section */}
                <div className="faq-container">
                  <h2>Frequently Asked Questions</h2>
                  {loading && <p>Loading FAQs...</p>}
                  {error && <p>Error loading FAQs: {error}</p>}
          
                  {!loading && !error && faqs.length === 0 && <p>No FAQs available at the moment.</p>}
          
                  {!loading && !error && faqs.length > 0 && (
                    <div className="faq-list">
                      {faqs.map(faq => (
                        <div key={faq._id} className={`faq-item ${faq.open ? 'open' : ''}`}>
                          <div className="faq-question" onClick={() => toggleFaq(faq._id)}>
                            {faq.question}
                            <span className="faq-toggle">{faq.open ? '-' : '+'}</span>
                          </div>
                          {faq.open && (
                            <div className="faq-answer">
                              <p>{faq.answer}</p>
                              {faq.tags && faq.tags.length > 0 && (
                                <div className="faq-meta">
                                  {faq.tags.map(tag => (
                                    <span key={tag}>{tag}</span>
                                  ))}
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                
              </div>
              
              <Footer />
              </>
            );
          };
          
          export default FAQ;
        |-Create.jsx
          import React, { useState } from "react";
          import axios from "axios";
          import '../assets/styles/create.css';
          import Navbar from "../components/navbar";
          import { useSelector } from "react-redux";
          import TextFieldsAndCheckbox from "../components/TextFieldsAndCheckbox";
          import ImageUpload from "../components/ImageUpload";
          import Footer from "../components/Footer";
          
          export default function Create() {
            const { currentUser } = useSelector((state) => state.user);
            const [images, setImages] = useState([]);
            const [data, setData] = useState({
              id: currentUser._id,
              name: '',
              description: '',
              address: '',
              phone: '',
              rent: true,
              sell: false,
              parking: false,
              wifi: false,
              petFriendly: false,
              rooms: '',
              bathrooms: '',
              price: '',
              image: []
            });
          
            // Handle file input change
            const handleFileChange = (event) => {
              setImages([...event.target.files]);
            };
          
            // Handle text and checkbox changes
            const handleChange = (e) => {
              const { name, type, checked, value } = e.target;
              if (type === "checkbox") {
                if (name === "rent") {
                  setData((prev) => ({
                    ...prev,
                    rent: checked,
                    sell: !checked, // Automatically toggle sell to false when rent is true
                  }));
                } else if (name === "sell") {
                  setData((prev) => ({
                    ...prev,
                    sell: checked,
                    rent: !checked, // and vice-versa
                  }));
                } else {
                  setData((prev) => ({
                    ...prev,
                    [name]: checked,
                  }));
                }
              } else {
                setData((prev) => ({
                  ...prev,
                  [name]: value,
                }));
              }
            };
          
            // Handle form submission
            const handleSubmit = async (event) => {
              event.preventDefault();
          
              const formData = new FormData();
              const imageUrls = [];
          
              for (const image of images) {
                formData.append("file", image);
                formData.append("upload_preset", import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
          
                try {
                  const response = await axios.post(
                    `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                    formData
                  );
          
                  imageUrls.push(response.data.secure_url);
                } catch (error) {
                  console.error("Error uploading image to Cloudinary:", error);
                  alert("Error during uploading image");
                  return;
                }
              }
          
              // Update state with image URLs before sending data to backend
              const updatedData = { ...data, image: imageUrls };
          
              console.log(updatedData); // for testing delete in final version
              console.log(currentUser);
          
              // Sending the data to the backend
              try {
                await axios.post(`${API_URL}/create-listing`, updatedData); // Update the API endpoint accordingly
                console.log("Listing created successfully");
              } catch (error) {
                console.error("Error creating listing:", error);
              }
            };
          
            // Create image previews
            const createImagePreviews = () => {
              return Array.from(images).map((file, index) => {
                const url = URL.createObjectURL(file);
                return (
                  <img
                    key={index}
                    src={url}
                    alt={`preview ${index}`}
                    style={{ width: "100px", height: "100px", objectFit: "cover", margin: "5px" }}
                  />
                );
              });
            };
          
            return (
              <>
                <Navbar />
          
                <div className="creating-container">
                  <h2>CREATE LISTING</h2>
                  <form className="creating" onSubmit={handleSubmit}>
                    <TextFieldsAndCheckbox data={data} handleChange={handleChange} />
                    <ImageUpload handleFileChange={handleFileChange} createImagePreviews={createImagePreviews} />
          
                    <button type="submit">Create</button>
                  </form>
                </div>
                
                <Footer />
              </>
            );
          }
        |-SignIn.jsx
          import React, { useState } from 'react';
          import { useNavigate } from 'react-router-dom';
          import { useDispatch } from 'react-redux';
          import { loginUser } from '../services/authServices';  // Import the login function from authServices
          import '../assets/styles/signin.css';
          import Navbar from '../components/navbar';
          
          const SignIn = () => {
            const dispatch = useDispatch();
          
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
            const navigate = useNavigate();
          
            // Handle Google OAuth login redirection
            const redirectToGoogleSignin = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/google/signin`;
            };
          
            // Handle Email and Password Sign-In
            const handleEmailSignIn = async (e) => {
              e.preventDefault();
              setLoading(true);
          
              try {
                // Call loginUser function from authServices
                const response = await loginUser({ email, password }, dispatch);
          
                if (response.data.success) {
                  navigate('/signin/success');  // Redirect on success
                }
              } catch (err) {
                const errorMessage = err.response?.data?.message || 'Something went wrong. Please try again.';
                navigate(`/signin/failure?message=${encodeURIComponent(errorMessage)}`);
              } finally {
                setLoading(false);
              }
            };
          
            return (
              <>
                <Navbar />
                <div className="login-container">
                  <h1>Welcome back</h1>
          
                  {/* Sign-in using email and password */}
                  <form onSubmit={handleEmailSignIn}>
                    <input
                      type="email"
                      placeholder="Email address*"
                      required
                      className="input-email"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                    />
                    <input
                      type="password"
                      placeholder="Password*"
                      required
                      className="input-password"  // New input for password
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                    />
                    <button type="submit" className="continue-button" disabled={loading}>
                      {loading ? 'Signing in...' : 'Continue'}
                    </button>
                  </form>
          
                  <p className="signup-link">
                    Don't have an account? <a href="/signup">Sign Up</a>
                  </p>
          
                  <div className="divider">
                    <hr /> <span>OR</span> <hr />
                  </div>
          
                  {/* Google OAuth sign-in */}
                  <div className="social-login">
                    <button className="social-button google" onClick={redirectToGoogleSignin}>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg" alt="Google Logo" />
                      Continue with Google
                    </button>
          
                    {/* Other social logins (disabled for now) */}
                    <button className="social-button microsoft" disabled>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/1024px-Microsoft_logo.svg.png" alt="Microsoft Logo" />
                      Continue with Microsoft Account
                    </button>
          
                    <button className="social-button apple" disabled>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg" alt="Apple Logo" />
                      Continue with Apple
                    </button>
                  </div>
                </div>
              </>
            );
          };
          
          export default SignIn;
        |-Profile.jsx
          import React, { useState, useRef, useEffect } from "react";
          import { useSelector } from "react-redux";
          import '../assets/styles/profile.css';
          import { Navigate, useNavigate } from "react-router-dom";
          import Navbar from "../components/navbar";
          import axios from "axios";
          import { SignOut } from "../services/authServices";
          import Footer from "../components/Footer";
          
          
          export default function Profile() {
              const { currentUser } = useSelector((state) => state.user);
              const navigate = useNavigate();
          
              const [updateData, setUpdateData] = useState({
                  id: currentUser ? currentUser.id : '',
                  username: currentUser ? currentUser.username : '',
                  email: currentUser ? currentUser.email : '',
                  password: '', // Initially empty, filled when user enters a new password
              });
          
              const [toggle, setToggle] = useState(false); // Toggle for expanding profile section
              const [error, setError] = useState('');
              const [loading, setLoading] = useState(false);
          
              const imageUpdate = useRef(null);
          
              useEffect(() => {
                  if (!currentUser) {
                      navigate("/signin"); // Redirect to signin if currentUser is not set
                  }
              }, [currentUser, navigate]);
          
              const handleUpdate = (e) => {
                  const { name, value } = e.target;
                  setError('');
          
                  if (value.trim() === '') return; // Prevent empty updates
          
                  setUpdateData((prev) => ({
                      ...prev,
                      [name]: value,
                  }));
              };
          
              const handleSubmit = async () => {
                  if (!updateData.username || !updateData.email) {
                      setError('Username and Email are required fields.');
                      return;
                  }
          
                  if (updateData.password && updateData.password !== updateData.confirmPassword) {
                      setError('Passwords do not match.');
                      return;
                  }
          
                  try {
                      setError('');
                      setLoading(true);
          
                      const response = await axios.put('/api/update-profile', updateData); // Example API call
                      console.log('Profile updated:', response.data);
          
                  } catch (error) {
                      setError('Failed to update profile. Please try again.');
                  } finally {
                      setLoading(false);
                  }
              };
          
              const navigateateToCreate = () => {
                  navigate('/create')
              }
          
              const handleToggle = () => {
                  setToggle(!toggle); // Toggle expand/collapse
              };
          
              const handleSignout = () => {
                  SignOut()
                      .then(() => {
                          // Navigate to the homepage after successful sign-out
                          navigate("/");
                      })
                      .catch((error) => {
                          setError('Failed to sign out. Please try again.');
                      });
              };
          
              return (
                  <>
                      {currentUser && (
                          <>
                              <Navbar />
                              <div className="profile">
                                  <img
                                      src="https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png"
                                      alt="User Avatar"
                                      onClick={() => imageUpdate.current.click()}
                                  />
                                  <div className="setting">
                                      <input
                                          type="file"
                                          accept="image/*"
                                          name="avatar"
                                          style={{ display: 'none' }}
                                          ref={imageUpdate}
                                          onChange={handleUpdate}
                                      />
          
                                      {/* Profile button */}
                                      <button className="profile-toggle-btn" onClick={handleToggle}>
                                          Profile
                                      </button>
          
                                      {/* Show profile info if toggle is true */}
                                      {toggle && (
                                          <div className="profile-info">
                                              <h4>{error}</h4>
                                              <label htmlFor="username">Change Username</label>
                                              <input
                                                  type="text"
                                                  name="username"
                                                  value={updateData.username}
                                                  onChange={handleUpdate}
                                              />
          
                                              <label htmlFor="email">Change Email</label>
                                              <input
                                                  type="email"
                                                  name="email"
                                                  value={updateData.email}
                                                  onChange={handleUpdate}
                                              />
          
                                              <label htmlFor="password">Change Password</label>
                                              <input
                                                  type="password"
                                                  name="password"
                                                  placeholder="New Password"
                                                  onChange={handleUpdate}
                                              />
                                              <input
                                                  type="password"
                                                  name="confirmPassword"
                                                  placeholder="Confirm Password"
                                                  onChange={handleUpdate}
                                              />
          
                                              <button
                                                  className="upating-profile"
                                                  type="submit"
                                                  onClick={handleSubmit}
                                                  disabled={loading}>
                                                  {loading ? 'Updating...' : 'Update Profile'}
                                              </button>
                                          </div>
                                      )}
                                  </div>
          
                                  <button className="profile-toggle-btn" onClick={navigateateToCreate}>Create Listing</button>
                                  <button className="profile-toggle-btn">Show My Listing</button>
                                  <button className="profile-toggle-btn" onClick={handleSignout}>Sign Out</button>
                              </div>
                          </>
                      )}
          
                      <Footer />
                  </>
              );
          }
        |-AuthStatus.jsx
          import React, { useEffect } from 'react';
          import { useNavigate, useSearchParams } from 'react-router-dom';
          import { FaCheckCircle, FaExclamationTriangle } from 'react-icons/fa'; // Icons for success and failure
          import '../assets/styles/authStatus.css';  // Centralized CSS
          
          // Failure Component
          export const AuthFailure = ({ type = "SignUp" }) => {  // Default type is "SignUp" if not provided
            const [searchParams] = useSearchParams();
            const navigate = useNavigate();
          
            // Extract the error message from query params or use a default message
            const errorMessage = searchParams.get('message') || `Failed to ${type}. Please try again.`;
          
            useEffect(() => {
              // Redirect to the correct page after 3 seconds
              const timer = setTimeout(() => {
                navigate(`/${type.toLowerCase()}`); // Redirects to /signin or /signup
              }, 3000);
          
              // Clean up timer
              return () => clearTimeout(timer);
            }, [navigate, type]);
          
            return (
              <div className="error-container">
                <div className="error-icon">
                  <FaExclamationTriangle className="icon" /> {/* Failure icon */}
                </div>
                <h1 className="error-title">{`${type} Failed`}</h1>
                <p className="error-message">{errorMessage}</p>
                <p className="redirect-message">You will be redirected to the {type} page shortly...</p>
              </div>
            );
          };
          
          // Success Component
          export const AuthSuccess = ({ type = "SignUp" }) => {  // Default type is "SignUp" if not provided
            const navigate = useNavigate();
          
            useEffect(() => {
              // Redirect to the homepage after 2 seconds
              const timer = setTimeout(() => {
                navigate('/');
              }, 2000);
          
              // Clean up timer
              return () => clearTimeout(timer);
            }, [navigate]);
          
            return (
              <div className="success-container">
                <div className="success-icon">
                  <FaCheckCircle className="icon" /> {/* Success icon */}
                </div>
                <h1 className="success-title">{`${type} Successful!`}</h1>
                <p className="redirect-message">Redirecting to the homepage...</p>
              </div>
            );
          };
          
        |-Home.jsx
          import React from "react";
          import Navbar from "../components/navbar";
          import Search from "../components/search";
          import Card from "../components/card";
          
          
          
          export default function Home(){
             return( <>
              <Navbar />
              <Search />
              <Card /> 
             </>)
          }
        |-SignUp.jsx
          import React from 'react';
          import Navbar from '../components/navbar';
          import SignUpOAuth from '../components/SignUpOAuth';
          import SignUpForm from '../components/SignUpFormLocal';
          
          const SignUp = () => {
            return (
              <>
                <Navbar />
                <div className="signup-page-container">
                  
                  {/* Local Email/Password Sign-Up Section */}
                  <SignUpForm />
          
                  {/* Divider between Local and OAuth sign-up form */}
                  <div className="divider">
                    <hr />
                    <span>Or sign up with</span>
                    <hr />
                  </div>
          
                  {/* OAuth Sign-Up Section */}
                  <SignUpOAuth />
          
                </div>
              </>
            );
          };
          
          export default SignUp;
          
        |-Agents.jsx
      |-services/
        |-validationHelper.js
          export const validateField = async (field, value, setLoading, setStatus, setError, validationService) => {
            if (value) {
              setLoading(true);
              setStatus(null);
              setError('');
          
              try {
                const response = await validationService(value); // Call the validation service
                if (response.data.success) {
                  setStatus('valid'); // Change 'available' to 'valid'
                } else {
                  setStatus('invalid'); // Change 'taken' to 'invalid'
                  setError(response.data.error.message);
                }
              } catch (err) {
                if (err.response && err.response.status === 400) {
                  setStatus('invalid'); // Change 'taken' to 'invalid'
                  setError(`This ${field} is already registered.`);
                } else {
                  setStatus('error');
                  setError(`Error checking ${field} availability.`);
                }
              } finally {
                setLoading(false);
              }
            }
          };
          
        |-authServices.jsx
          import axios from 'axios';
          import { setUser } from '../redux/userSlice';
          import Cookies from 'js-cookie';
          
          
          
          const API_URL = import.meta.env.VITE_API_URL;
          const tokenName = import.meta.env.VITE_JWT_COOKIE_NAME;
          
          
          // Create an Axios instance with a base URL and default options
          const axiosInstance = axios.create({
            baseURL: API_URL,        // Base URL for all API requests
            withCredentials: true,   // Include credentials with every request (useful for authentication)
          });
          
          // Function to register a new user
          export const registerUser = async (userData, dispatch) => {
            console.log('registerUser called with:', userData);
            try {
              console.log('Sending request to:', `${API_URL}/api/auth/signup`); // Log API endpoint
              const response = await axiosInstance.post('/api/auth/signup', userData); // Use axiosInstance
              console.log('API response:', response);
          
              // Dispatch the action after successful registration
              dispatch(setUser(response));
          
              return response;
            } catch (error) {
              console.error('API error:', error);
              if (error.response) {
                console.error('Error response:', error.response.data);
                console.error('Error status:', error.response.status);
              } else if (error.request) {
                console.error('Error request:', error.request);
              } else {
                console.error('Error message:', error.message);
              }
              throw error; // Re-throw the error to be handled by the caller
            }
          };
          
          // Login function
          export const loginUser = async (userData, dispatch) => {
            try {
              const response = await axiosInstance.post('/api/auth/signin', userData); // Use axiosInstance
              console.log('Login API response:', response);
          
              // Assuming your backend sends the token in response
              Cookies.set('propertyHubAuthToken', response.data.token); // Store token in cookies
              dispatch(setUser(response.data.user)); // Dispatch the action to update Redux and persist it
          
              return response;
            } catch (error) {
              console.error('Error during login:', error);
              throw error;
            }
          };
          
          // Function to validate email availability
          export const checkEmailAvailability = async (email) => {
            console.log('checkEmailAvailability called with email:', email);
            try {
              const response = await axiosInstance.get(`/api/auth/check-email/${email}`); // Use axiosInstance
              console.log('Email availability response:', response);
              return response;
            } catch (error) {
              console.error('Error in checkEmailAvailability:', error);
              throw error; // Re-throw the error to be handled by the caller
            }
          };
          
          // Function to validate username availability
          export const checkUsernameAvailability = async (username) => {
            console.log('checkUsernameAvailability called with username:', username);
            try {
              const response = await axiosInstance.get(`/api/auth/check-username/${username}`); // Use axiosInstance
              console.log('Username availability response:', response);
              return response;
            } catch (error) {
              console.error('Error in checkUsernameAvailability:', error);
              throw error;
            }
          };
          
          
          export const SignOut = () => {
            try {
              axios.post(`${API_URL}/api/auth/logout`)
              
                .then(() => {
                  // Clear cookies and local storage after successful sign-out
                  Cookies.remove(tokenName);
                  localStorage.clear();
          
                 
                })
                .catch((error) => {
                  console.error('Sign out failed:', error);
                  setError('Failed to sign out. Please try again.');
                });
            } catch (error) {
              console.error('Sign out failed:', error);
              setError('Failed to sign out. Please try again.');
            }
          };
  |-server/
    |-app.js
      import express from 'express';
      import connectDB from './config/db.js';
      import applyGlobalMiddleware from './middleware/auth/globalMiddlewares.js';
      import errorHandler from './middleware/error/globalErrorMiddleware.js';  
      import initRoutes from './routes/initRoutes.js';
      
      // Connect to the database
      connectDB();
      
      // Initialize the app
      const app = express();
      
      // Apply global middlewares (e.g., JSON parsing, CORS)
      applyGlobalMiddleware(app);
      
      // Initialize all routes
      initRoutes(app);
      
      // Error handling middleware
      app.use(errorHandler);
      
      // Start the server
      const PORT = process.env.PORT || 5000;
      app.listen(PORT, () => {
        console.log(`Server is running on http://localhost:${PORT}`);
      });
    |-config/
      |-db.js
        import mongoose from 'mongoose';
        import dotenv from 'dotenv';
        
        dotenv.config(); // Load environment variables
        
        // Function to connect to MongoDB using the latest Mongoose standards
        const mongoURI = process.env.MONGODB_URI;
        const connectDB = async () => {
          try {
            const conn = await mongoose.connect(mongoURI);
            console.log(`MongoDB connected successfully: ${conn.connection.host}`);
          } catch (error) {
            console.error(`MongoDB connection error: ${error.message}`);
            process.exit(1); // Exit with failure
          }
        };
        
        export default connectDB;
      |-passport.js
        /**
         * This file configures the passport authentication middleware using JWT strategy 
         * to verify tokens and authenticate admin users. It attaches the admin data 
         * to the request object upon successful authentication.
         */
        
        import passport from 'passport';
        import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
        import { Strategy as LocalStrategy } from 'passport-local';
        import { 
          authenticateAdmin, 
          authenticateAgent,
          authenticateUserService
        }  from '../services/authService.js';  // If singular, for example
        import { 
          handleGoogleOAuthSignup, 
          handleGoogleOAuthSignin,
        } from '../services/authService.js'; // Import service function
        
        
        passport.use(
          'local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                const user = await authenticateUserService(email, password);
                return done(null, user);
              } catch (error) {
                return done(error, false);
              }
            }
          )
        );
        
        
        passport.use(
          'admin-local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                const admin = await authenticateAdmin(email, password);
                return done(null, admin);  // Pass the authenticated admin to the next middleware
              } catch (error) {
                return done(null, false, { message: error.message });  // Pass the error to the controller
              }
            }
          )
        );
        
        // Passport strategy for agent-local authentication
        passport.use(
          'agent-local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                // Call the service to handle agent authentication
                const { agent } = await authenticateAgent(email, password);
        
                // Pass the authenticated agent to the next middleware
                return done(null, agent);
              } catch (error) {
                // Pass the error to the controller (since service now throws errors)
                return done(null, false, error);
              }
            }
          )
        );
        
        passport.use(
          'google-signup',
          new GoogleStrategy(
            {
              clientID: process.env.GOOGLE_OAUTH_CLIENT_ID,
              clientSecret: process.env.GOOGLE_OAUTH_CLIENT_SECRET,
              callbackURL: process.env.GOOGLE_OAUTH_SIGNUP_REDIRECT_URI,
              scope: ['profile', 'email'],
            },
            async (accessToken, refreshToken, profile, done) => {
              const { id: googleId, name: { givenName: firstName = '', familyName: lastName = '' }, emails: [{ value: email = '' } = {}], photos: [{ value: avatar = '' } = {}] } = profile;
        
              try {
                // Pass profile data to the service layer for sign-up logic
                const { user, isExisting } = await handleGoogleOAuthSignup({ googleId, firstName, lastName, email, avatar });
                return done(null, { user, isExisting }); // Pass both user and isExisting flag
              } catch (error) {
                return done(error, null); // In case of an error, pass it to Passport
              }
            }
          )
        );
        
        passport.use(
          'google-signin',
          new GoogleStrategy(
            {
              clientID: process.env.GOOGLE_OAUTH_CLIENT_ID,
              clientSecret: process.env.GOOGLE_OAUTH_CLIENT_SECRET,
              callbackURL: process.env.GOOGLE_OAUTH_SIGNIN_REDIRECT_URI,
              scope: ['profile', 'email'],
            },
            async (accessToken, refreshToken, profile, done) => {
              const { id: googleId, name: { givenName: firstName = '', familyName: lastName = '' }, emails: [{ value: email = '' } = {}], photos: [{ value: avatar = '' } = {}] } = profile;
        
              try {
                // Pass profile data to the service layer for sign-in logic
                const user = await handleGoogleOAuthSignin({ googleId, firstName, lastName, email, avatar });
                return done(null, { user }); // Pass user object to Passport
              } catch (error) {
                return done(error, null); // Handle errors
              }
            }
          )
        );
        
        export default passport;
    |-controllers/
      |-admin/
        |-adminController.js
          
          
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { 
            getAllAdminsService, 
            getAdminByIdService,
            deleteAdminService,
            updateAdminService,
           } from '../../services/adminService.js';
          
          /**
           * @desc    Controller to handle the retrieval of all admin users.
           * @route   GET /api/admin
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the user's authentication details.
           * @param   {Object} res - Express response object for sending the list of admins.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with the success status and list of all admin users.
           */
          export const getAllAdmins = async (req, res, next) => {
            try {
              // Get the raw admin data from the service layer
              const admins = await getAllAdminsService();
              
              // Sanitize the data by excluding sensitive fields like passwords
              const sanitizedAdmins = admins.map(admin => excludeSensitiveInfo(admin, ['password', '__v']));
          
              // Respond with the sanitized admin data
              return res.status(200).json({
                success: true,
                data: sanitizedAdmins,
              });
          
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          export const getAdminById = async (req, res, next) => {
            try {
              // Extract the admin ID from the request parameters
              const { id } = req.params;
          
              // Call the service layer to get the admin by ID
              const admin = await getAdminByIdService(id);
          
              const sanitizedAdmin = excludeSensitiveInfo(admin, ['password', '__v']);
          
              // Respond with the admin data (excluding sensitive info like password)
              return res.status(200).json({
                success: true,
                data: sanitizedAdmin,
              });
          
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to delete an admin by ID.
           * @route   DELETE /api/admin/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the admin ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteAdmin = async (req, res, next) => {
            try {
              // Extract admin ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle admin deletion
              await deleteAdminService(id);
          
              // Send success response after admin is deleted
              return res.status(200).json({
                success: true,
                message: 'Admin deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to update a specific admin's information.
           * @route   PUT /api/admin/:id
           * @access  Private (Admin or Super Admin)
           * @param   {Object} req - Express request object containing the admin ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated admin data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated admin data or error.
           */
          export const updateAdmin = async (req, res, next) => {
            try {
              const { id } = req.params;
              const updates = req.body;
              console.log(req.user);
              const userRole = req.user.role;  // Get the user's role from the request (e.g., 'admin' or 'super-admin')
          
              // Call the service to update the admin and pass the userRole
              const updatedAdmin = await updateAdminService(id, updates, userRole);
              
              const sanitizedUpdatedAdmin = excludeSensitiveInfo(updatedAdmin, ['password', '__v']);
          
          
              return res.status(200).json({
                success: true,
                message: 'Admin information updated successfully.',
                data: sanitizedUpdatedAdmin,
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
      |-agent/
        |-agentController.js
          
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import {
            getAllAgentsService, 
            getAgentByIdService,
            deleteAgentService,
            updateAgentService,
            updateAgentStatusService, 
          } from '../../services/agentService.js';
          
          
          /**
           * @desc    Controller to handle retrieving all agent users from the database.
           * @param   {Object} req - Express request object.
           * @param   {Object} res - Express response object used to send the list of agents.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with the success status and list of all agents.
           */
          export const getAllAgents = async (req, res, next) => {
            try {
              // Get the raw agent data from the service layer
              const agents = await getAllAgentsService();
          
              // Sanitize the data by excluding sensitive fields like passwords
              const sanitizedAgents = agents.map(agent => excludeSensitiveInfo(agent, ['password', '__v']));
          
              // Respond with the sanitized agent data
              return res.status(200).json({
                success: true,
                data: sanitizedAgents,
              });
          
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          /**
           * @desc    Get a specific agent by ID from the database.
           *          Returns agent data except for the password field.
           * @route   GET /api/agent/:id
           * @access  Private (Agent/Admin)
           * @param   {Object} req - Express request object containing the agent ID in params.
           * @param   {Object} res - Express response object for sending the agent data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with agent data or formatted error.
           */
          export const getAgentById = async (req, res, next) => {
            try {
              // Extract the agent ID from the request parameters
              const { id } = req.params;
          
              // Call the service layer to get the agent by ID
              const agent = await getAgentByIdService(id);
          
              // Sanitize the agent data (remove sensitive fields like password)
              const sanitizedAgent = excludeSensitiveInfo(agent, ['password', '__v']);
          
              // Respond with the agent data
              return res.status(200).json({
                success: true,
                data: sanitizedAgent,
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to delete an agent by ID.
           * @route   DELETE /api/agent/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the agent ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteAgent = async (req, res, next) => {
            try {
              // Extract agent ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle agent deletion
              await deleteAgentService(id);
          
              // Send success response after agent is deleted
              return res.status(200).json({
                success: true,
                message: 'Agent deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to update a specific agent's information.
           * @route   PUT /api/agent/:id
           * @access  Private (Agent or Super Admin)
           * @param   {Object} req - Express request object containing the agent ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated agent data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated agent data or error.
           */
          export const updateAgent = async (req, res, next) => {
            try {
              const { id } = req.params;
              const updates = req.body;
              const userRole = req.user.role;  // Get the user's role from the request
          
              // Call the service to update the agent and pass the userRole
              const updatedAgent = await updateAgentService(id, updates, userRole);
          
              // Exclude sensitive fields like password before returning the response
              const sanitizedUpdatedAgent = excludeSensitiveInfo(updatedAgent, ['password', '__v']);
          
              return res.status(200).json({
                success: true,
                message: 'Agent information updated successfully.',
                data: sanitizedUpdatedAgent,
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
          
          
          /**
           * @desc Controller to update the status of an agent (admin-only)
           * @route PUT /api/agent/:id/status
           * @access Private (Admin)
           * @param {Object} req - The request object containing agent ID and new status.
           * @param {Object} res - The response object used to send the updated agent details.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message and updated agent data.
           */
          export const updateAgentStatus = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { agentStatus } = req.body;
          
              // Call the service layer to update agent status
              const updatedAgent = await updateAgentStatusService(id, agentStatus);
          
              // Send response with updated agent data
              return res.status(200).json({
                success: true,
                message: `Agent status updated to ${agentStatus}`,
                data: {
                  id: updatedAgent._id,
                  firstName: updatedAgent.firstName,
                  lastName: updatedAgent.lastName,
                  email: updatedAgent.email,
                  agentStatus: updatedAgent.agentStatus,
                },
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
          
      |-faq/
        |-faqController.js
          import FAQ from '../../models/Faq.js';
          import { formatError } from '../../utils/errorFormatter.js';
          
          // Get all FAQs Controller
          export const getAllFaqs = async (req, res, next) => {
            try {
              const faqs = await FAQ.find();
              res.status(200).json(faqs);
            } catch (error) {
              return next(formatError('Error retrieving FAQs', [], 500));
            }
          };
          
          // Create a new FAQ Controller
          export const createFaq = async (req, res, next) => {
            const { question, answer, category, priority, isPublished, tags } = req.body;
          
            try {
              const faq = new FAQ({
                question,
                answer,
                category,  // Optional category
                priority,  // Optional priority
                isPublished, // Optional publication status
                tags       // Optional tags (array of strings)
              });
          
              await faq.save(); // Save the new FAQ to the database
              res.status(201).json(faq); // Return the created FAQ
            } catch (error) {
              return next(formatError('Error creating FAQ', [{ field: 'general', message: error.message }], 400));
            }
          };
          
          // Update a FAQ Controller
          export const updateFaq = async (req, res, next) => {
            const { id } = req.params;
            const updates = req.body;
          
            try {
              const faq = await FAQ.findById(id);
          
              if (!faq) {
                return next(formatError('FAQ not found', [{ field: 'id', message: `FAQ with id ${id} not found` }], 404));
              }
          
              // Object to track updated fields
              const fieldsUpdated = [];
          
              // Only update fields that were passed in req.body
              for (const key in updates) {
                if (faq[key] !== undefined) { // Ensure the key exists in the FAQ object
                  faq[key] = updates[key];
                  fieldsUpdated.push(key);
                }
              }
          
              // Save the updated FAQ
              await faq.save();
          
              // Respond with a detailed success message
              res.status(200).json({
                message: 'FAQ was successfully updated.',
                id: id,
                fieldsUpdated: fieldsUpdated.length ? fieldsUpdated : 'No fields were updated',
                faq
              });
          
            } catch (error) {
              return next(formatError('Error updating FAQ', [{ field: 'id', message: error.message }], 500));
            }
          };
          
          // Delete a FAQ Controller
          export const deleteFaq = async (req, res, next) => {
            const { id } = req.params; // Extract the id from the URL
          
            try {
              const faq = await FAQ.findByIdAndDelete(id); // Find and delete the FAQ by id
              if (!faq) {
                return next(formatError('FAQ not found', [{ field: 'id', message: `FAQ with id ${id} not found` }], 404));
              }
          
              res.status(200).json({
                message: 'FAQ was successfully deleted',
                id: id
              });
            } catch (error) {
              return next(formatError('Error deleting FAQ', [{ field: 'id', message: error.message }], 500));
            }
          };
      |-auth/
        |-agentAuthController.js
          
          
          import passport from 'passport';
          import '../../config/passport.js';
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { UnauthorizedError } from '../../utils/customErrors.js';  // Adjust path if needed
          import { createNewAgent, } from '../../services/agentService.js';
          
          
          /**
           * @desc    Controller to handle the registration of new agents.
           * @param   {Object} req - Express request object containing the agent's data in the body.
           * @param   {Object} res - Express response object used to send the result of the registration process.
           * @param   {Function} next - Express middleware function for passing control to the next middleware in case of errors.
           * @returns {JSON} - Success response with the created agent's data and a JWT token
           * @throws  {JSON} - If validation or business logic errors occur, or if there's a server error during registration.
           */
          export const createAgent = async (req, res, next) => {
              try {
                // Call the service layer to create a new agent
                const newAgent = await createNewAgent(req.body);
            
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(newAgent);
            
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
            
                // Exclude sensitive fields (like password) from the response
                const agentResponse = excludeSensitiveInfo(newAgent, ['password', '__v']);
            
                return res.status(201).json({
                  success: true,
                  message: 'Agent created successfully.',
                  data: agentResponse,
                });
                
              } catch (error) {
                return next(error);
              }
            };
            
            /*
             * Controller to handle agent login using Passport local strategy.
             * This controller handles authentication, token generation, and setting the authentication cookie.
             * 
             * @param {Object} req - Express request object containing agent's login credentials.
             * @param {Object} res - Express response object used to send the login result and JWT token.
             * @param {Function} next - Express middleware function for error handling or passing control to the next middleware.
             * @returns {JSON} - Returns a success response with the agent's data and a JWT token if authentication is successful.
             * @throws {JSON} - If authentication fails, it passes an error to the global error handler.
             */
            export const loginAgent = (req, res, next) => {
              passport.authenticate('agent-local', { session: false }, async (err, agent, info) => {
                if (err) {
                  return next(err);  // Pass server error to the global error handler
                }
            
                if (!agent) {
                  // Handle authentication failure
                  const error = new UnauthorizedError(info?.message || 'Authentication failed');
                  return next(error);
                }
            
                try {
                  // Generate JWT token and set it as a cookie
                  const { token, cookieOptions } = generateTokenAndCookieOptions(agent);
                  
                  // Set the JWT token in the cookie
                  setTokenCookie(res, token, cookieOptions);
            
            
                  const agentResponse = excludeSensitiveInfo(agent, ['password', '__v']);
            
            
                  // Send the response with agent info (excluding sensitive data)
                  return res.status(200).json({
                    success: true,
                    message: 'Agent logged in successfully!',
                    data: agentResponse,
                  });
                } catch (error) {
                  next(error);  // Pass any unexpected error to the global error handler
                }
              })(req, res, next);
            };
        |-userAuthController.js
          import passport from 'passport';
          import '../../config/passport.js';
          import { createNewUser } from '../../services/userServices.js';
          import { generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import { excludeSensitiveInfo } from '../../utils/excludeSensitiveInfo.js';
          import { clearTokenCookie } from '../../services/authService.js';
          import { UnauthorizedError, } from '../../utils/customErrors.js';
          
          
          /**
           * @desc    Controller to handle the registration of new users.
           * @param   {Object} req - Express request object containing the user's data in the body.
           * @param   {Object} res - Express response object used to send the result of the registration process.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with the created user's data and a JWT token.
           */
          export const createUser = async (req, res, next) => {
            try {
              // Call the service layer to create a new user
              const newUser = await createNewUser(req.body);
          
              // Generate token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(newUser);
          
              // Set the JWT token in the cookie
              setTokenCookie(res, token, cookieOptions);
          
              // Exclude sensitive fields (like password) from the response
              const userResponse = excludeSensitiveInfo(newUser, ['password', '__v']);
          
              return res.status(201).json({
                success: true,
                message: 'User registered successfully.',
                data: userResponse,
              });
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          /**
           * Controller to handle user login via local strategy.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with JWT token and user data.
           */
          export const authenticateUser = async (req, res, next) => {
            passport.authenticate('local', { session: false }, async (err, user, info) => {
              if (err) {
                return next(err);  // Pass server-side error to global error handler
              }
          
              if (!user) {
                // Handle authentication failure
                const error = new UnauthorizedError(info?.message || 'Authentication failed');
                return next(error);
              }
          
              try {
                // Generate JWT token and cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
          
                // Exclude sensitive fields like password from the response
                const userResponse = excludeSensitiveInfo(user, ['password', '__v']);
          
                // Send success response
                return res.status(200).json({
                  success: true,
                  message: 'User logged in successfully!',
                  data: userResponse,
                });
              } catch (error) {
                return next(error);  // Pass any unexpected error to the global error handler
              }
            })(req, res, next);
          };
          
          /**
           * Controller for logging out a user.
           * @desc Clears the authentication token stored in the user's cookie, effectively logging them out.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object used to send the result of the logout.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message indicating the user has logged out.
           */
          export const logoutUser = (req, res, next) => {
            try {
              // Call the service to clear the authentication token cookie
              clearTokenCookie(res);
          
              // Send a response indicating successful logout
              return res.status(200).json({
                success: true,
                message: 'User logged out successfully.',
              });
            } catch (error) {
              next(error); // Pass any errors to the global error handler
            }
          };
          
        |-googleOAuthController.js
          import User from '../../models/User.js';
          import { handleGoogleOAuthSignup } from '../../services/authService.js';
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          
          /**
           * Controller to handle Google OAuth Signup Callback.
           * @desc This controller is called after the Google OAuth sign-up process.
           * @param {Object} req - Express request object containing the user profile.
           * @param {Object} res - Express response object used to send the result of the signup.
           * @returns {Response} - Redirect to a success or failure page on the client.
           */
          export const googleOAuthSignupCallback = async (req, res) => {
            try {
              const { user, isExisting } = req.user;  // This is passed by Passport after Google authentication
          
              if (!user) {
                const errorMessage = encodeURIComponent('Google OAuth failed');
                return res.redirect(`${process.env.CLIENT_URI}/signup/failure?message=${errorMessage}`);
              }
          
              // Generate token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
              setTokenCookie(res, token, cookieOptions);
          
              if (isExisting) {
                const welcomeBackMessage = encodeURIComponent('Welcome back!');
                return res.redirect(`${process.env.CLIENT_URI}/signin/success?message=${welcomeBackMessage}`);
              } else {
                const successMessage = encodeURIComponent('Signup successful');
                return res.redirect(`${process.env.CLIENT_URI}/signup/success?message=${successMessage}`);
              }
            } catch (error) {
              const errorMessage = encodeURIComponent('Error processing signup');
              return res.redirect(`${process.env.CLIENT_URI}/signup/failure?message=${errorMessage}`);
            }
          };
          
          
          // Google OAuth Sign-In Callback
          /**
           * Google OAuth Sign-In Callback Controller
           * @desc This controller is called after the Google OAuth sign-in process.
           * @param {Object} req - Express request object containing the user profile.
           * @param {Object} res - Express response object used to send the result of the sign-in.
           * @returns {Response} - Redirect to a success or failure page on the client.
           */
          export const googleOAuthSigninCallback = async (req, res) => {
            try {
              const { user } = req.user;  // This is passed by Passport after Google authentication
          
              if (!user) {
                const errorMessage = encodeURIComponent('Google OAuth failed');
                return res.redirect(`${process.env.CLIENT_URI}/signin/failure?message=${errorMessage}`);
              }
          
              // Generate JWT token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
              // Set the JWT token in the cookie
              setTokenCookie(res, token, cookieOptions);
          
              // Redirect to frontend with success message
              const successMessage = encodeURIComponent('Signin successful');
              return res.redirect(`${process.env.CLIENT_URI}/signin/success?message=${successMessage}`);
          
            } catch (error) {
              const errorMessage = encodeURIComponent('Error processing signin');
              return res.redirect(`${process.env.CLIENT_URI}/signin/failure?message=${errorMessage}`);
            }
          };
        |-adminAuthController.js
          
          
          
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import passport from 'passport';
          import '../../config/passport.js';
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { 
            createNewAdmin, 
           } from '../../services/adminService.js';
          import { UnauthorizedError, } from '../../utils/customErrors.js';
          
          
          /**
           * Controller to create a new admin.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Returns the created admin and a JWT token.
           */
          export const createAdmin = async (req, res, next) => {
              try {
                // Call the service layer to create a new admin
                const newAdmin = await createNewAdmin(req.body);
            
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(newAdmin);
            
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
            
                // Exclude sensitive fields (like password) from the response
                const adminResponse = excludeSensitiveInfo(newAdmin, ['password', '__v']);
            
                // Send success response
                return res.status(201).json({
                  success: true,
                  message: 'Admin created successfully.',
                  data: adminResponse,
                });
              } catch (error) {
                // Pass the error to the global error handler
                return next(error);
              }
            };
            
          /**
           * Login admin controller.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           */
          export const loginAdmin = (req, res, next) => {
            passport.authenticate('admin-local', { session: false }, async (err, admin, info) => {
              if (err) {
                return next(err);  // Handle server error
              }
          
              if (!admin) {
                // If no admin is found, pass the UnauthorizedError to the error handler
                const error = new UnauthorizedError(info?.message || 'Authentication failed');
                return next(error);
              }
          
              try {
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(admin);
          
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
          
                // Exclude sensitive fields from the response
                const adminResponse = excludeSensitiveInfo(admin, ['password', '__v']);
          
                return res.status(200).json({
                  success: true,
                  message: 'Admin logged in successfully!',
                  data: adminResponse,
                });
              } catch (error) {
                // Pass any errors to the error handler
                return next(error);
              }
            })(req, res, next);
          };
      |-property/
        |-propertiesController.js
          import Property from '../../models/Property.js';
          import { validationResult } from 'express-validator';
          
          /**
           * @desc    Create a new property listing
           * @route   POST /api/properties
           * @access  Private (Agents/Admins only)
           */
          export const createProperty = async (req, res, next) => {
            // Extract validation errors from express-validator
            const validationErrors = validationResult(req);
            let errors = [];
          
            //Collect validation errors and ensure both `field` and `message` are included
            if (!validationErrors.isEmpty()) {
              errors = validationErrors.array().map(err => ({
                field: err.path, // Returns the field name
                message: err.msg, // Error message for that field
              }));
            }
          
            const {
              title, description, propertyType, price, status, size, bedrooms, bathrooms, rooms,
              offerType, wifi, petFriendly, parking, yearBuilt, availableFrom, address, images,
              amenities, coordinates
            } = req.body;
          
            try {
              // If there are any validation errors, pass them to the global error handler
              if (errors.length > 0) {
                const error = new Error('Validation failed');
                error.statusCode = 400;
                error.errors = errors;
                return next(error);  // Forward errors to the global error handler
              }
          
              // Create a new property object using the Property model
              const newProperty = new Property({
                title,
                description,
                propertyType,
                price,
                status,
                size,
                bedrooms,
                bathrooms,
                rooms,
                offerType,
                wifi: wifi || false,
                petFriendly: petFriendly || false,
                parking: parking || false,
                yearBuilt,
                availableFrom,
                address,
                images: images || [],
                amenities: amenities || [],
                agentId: req.user._id,  // Use the authenticated user's ID (from `req.user`)
                coordinates,
              });
          
              //Save the new property to the database
              const savedProperty = await newProperty.save();
          
              // Return success response with the newly created property and its ID
              return res.status(201).json({
                success: true,
                message: 'Property created successfully!',
                data: {
                  id: savedProperty._id,  // Return the generated property ID
                  property: savedProperty  // Include the full property object
                }
              });
          
            } catch (error) {
              // Catch any server errors and pass them to the global error handler
              return next(error);
            }
          };
      |-validation/
        |-validationController.js
          
          
          import { 
            isUsernameAvailable, 
            isEmailAvailable 
          } from '../../services/validationServices.js';
          
          /**
           * Controller to check if a username is available.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware for error handling.
           */
          export const checkUsername = async (req, res, next) => {
            const { username } = req.params;
          
            try {
              await isUsernameAvailable(username); // Call the service layer
          
              return res.status(200).json({ success: true, message: 'Username is available.' });
            } catch (error) {
              return next(error); // Forward errors to the global error handler
            }
          };
          
          /**
           * Controller to check if an email is already registered.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware for error handling.
           */
          export const checkEmail = async (req, res, next) => {
            const { email } = req.params;
          
            try {
              await isEmailAvailable(email); // Call the service layer
          
              return res.status(200).json({ success: true, message: 'Email is available.' });
            } catch (error) {
              return next(error); // Forward errors to the global error handler
            }
          };
      |-user/
        |-userController.js
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import {
            getAllUsersService, 
            getUserByIdService,
            deleteUserService,
            updateUserService,
          } from '../../services/userServices.js';
          
          /**
           * @desc    Controller to handle retrieving all users from the database.
           * @param   {Object} req - Express request object.
           * @param   {Object} res - Express response object used to send the list of users.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with the success status and list of all users.
           */
          export const getAllUsers = async (req, res, next) => {
              try {
                // Fetch all users from the service layer
                const users = await getAllUsersService();
            
                // Sanitize user data to exclude sensitive fields (like passwords)
                const sanitizedUsers = users.map(user => excludeSensitiveInfo(user, ['password', '__v']));
            
                // Respond with the sanitized user data
                return res.status(200).json({
                  success: true,
                  data: sanitizedUsers,
                });
            
              } catch (error) {
                return next(error); // Pass any errors to the global error handler
              }
          };
          
          /**
           * @desc    Get a specific user by ID from the database.
           *          Returns user data except for the password field.
           * @route   GET /api/user/:id
           * @access  Private (User/Admin)
           * @param   {Object} req - Express request object containing the user ID in params.
           * @param   {Object} res - Express response object for sending the user data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with user data or formatted error.
           */
          export const getUserById = async (req, res, next) => {
              try {
                const { id } = req.params; // Extract user ID from params
            
                // Call the service to get user by ID
                const user = await getUserByIdService(id);
            
                // Sanitize user data (exclude sensitive fields like password)
                const sanitizedUser = excludeSensitiveInfo(user, ['password', '__v']);
            
                return res.status(200).json({
                  success: true,
                  data: sanitizedUser,
                });
              } catch (error) {
                return next(error); // Pass error to global error handler
              }
          };
          
          /**
           * @desc    Controller to update a specific user's information.
           * @route   PUT /api/user/:id
           * @access  Private (User or Admin)
           * @param   {Object} req - Express request object containing the user ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated user data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated user data or error.
           */
          export const updateUser = async (req, res, next) => {
              try {
                const { id } = req.params; // Extract user ID from the request params
                const updates = req.body;  // Extract the updates from the request body
                const userRole = req.user.role;  // Get the user's role from the JWT payload
            
                // Call the service to update the user
                const updatedUser = await updateUserService(id, updates, userRole);
            
                // Exclude sensitive fields like password before sending the response
                const sanitizedUpdatedUser = excludeSensitiveInfo(updatedUser, ['password', '__v']);
            
                return res.status(200).json({
                  success: true,
                  message: 'User information updated successfully.',
                  data: sanitizedUpdatedUser,
                });
              } catch (error) {
                return next(error);  // Pass the error to the global error handler
              }
          };
          
          /**
           * @desc    Controller to delete a user by ID.
           * @route   DELETE /api/users/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the user ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteUser = async (req, res, next) => {
            try {
              // Extract user ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle user deletion
              await deleteUserService(id);
          
              // Send success response after user is deleted
              return res.status(200).json({
                success: true,
                message: 'User deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
    |-utils/
      |-validationErrorsHandler.js
        import { validationResult } from 'express-validator';
        import { ValidationError } from '../utils/customErrors.js';
        
        /**
         * Middleware to handle validation errors from express-validator.
         */
        export const handleValidationErrors = (req, res, next) => {
          const errors = validationResult(req);
        
          if (!errors.isEmpty()) {
            // Format validation errors: Each error includes only the field and its message
            const formattedErrors = errors.array().map(err => ({
              field: err.param,   // This will be the field name (like "email")
              message: err.msg,   // This will be the error message (like "Please provide a valid email address")
            }));
        
            // Pass the formatted errors to the global error handler
            return next(new ValidationError('Validation failed due to invalid inputs.', formattedErrors, 400));
          }
        
          // Proceed to the next middleware/controller if no validation errors
          next();
        };
      |-checkDuplicateFields.js
        /**
         * @desc Checks for duplicate fields in the database and returns an array of duplicate field errors if found.
         * @param {Model} model - The Mongoose model to search for existing records.
         * @param {Object} fieldsToCheck - The fields to check for duplicates (e.g., username, email, phoneNumber).
         * @returns {Array} - Returns an array of duplicate field errors or an empty array if no duplicates are found.
         */
        export const checkDuplicateFields = async (model, fieldsToCheck) => {
          const duplicateErrors = [];
        
          // Build the query to search for any matching records
          const query = {
            $or: Object.keys(fieldsToCheck).map((field) => ({ [field]: fieldsToCheck[field] })),
          };
        
          // Find an existing record that matches one of the fields
          const existingRecord = await model.findOne(query);
        
          // If an existing record is found, check for which fields are duplicates
          if (existingRecord) {
            Object.keys(fieldsToCheck).forEach((field) => {
              if (existingRecord[field] === fieldsToCheck[field]) {
                duplicateErrors.push({
                  field,
                  message: `${field.charAt(0).toUpperCase() + field.slice(1)} is already in use.`,
                });
              }
            });
          }
        
          // Return an array of duplicate errors (empty array if no duplicates found)
          return duplicateErrors;
        };
      |-generateUniqueUsername.js
        import User from '../models/User.js';
        
        async function generateUniqueUsername(firstName, lastName, email) {
            let baseUsername = (firstName + lastName).toLowerCase().replace(/\s+/g, '');
        
            // If no valid base username is created, fall back to the email prefix
            if (!baseUsername) {
                baseUsername = email.split('@')[0]; // Use email username part as fallback
            }
        
            let username = baseUsername;
            let suffix = 1;
            
            // Check if the generated username already exists in the database
            while (await User.findOne({ username })) {
              username = `${baseUsername}${suffix}`;
              suffix++;
            }
            
            return username;
        }
        
        export default generateUniqueUsername;
        
      |-authHelpers.js
        import jwt from 'jsonwebtoken';
        import { ValidationError } from '../utils/customErrors.js';
        
        export const generateJWT = (user) => {
          console.log('User object received in generateJWT:', JSON.stringify(user, null, 2));
          if (!user || !user._id || !user.username || !user.email || !user.role) {
            throw new ValidationError('Invalid user object provided to generateJWT', [
              { field: '_id', message: 'User ID is missing' },
              { field: 'username', message: 'Username is missing' },
              { field: 'email', message: 'Email is missing' },
              { field: 'role', message: 'Role is missing' }
            ].filter(error => !user || !user[error.field]));
          }
        
          const payload = {
            id: user._id,
            username: user.username,
            email: user.email,
            role: user.role,
          };
        
          const options = {
            expiresIn: process.env.JWT_EXPIRES_IN || '3d',
            issuer: process.env.JWT_ISSUER || 'propertyHub',
            audience: process.env.JWT_AUDIENCE || 'propertyHubApp',
          };
        
          return jwt.sign(payload, process.env.JWT_SECRET, options);
        };
        
        /**
         * Generate a token and cookie options for a user
         * @param {Object} user - The user object
         * @returns {Object} An object containing the token and cookie options
         */
        export const generateTokenAndCookieOptions = (user) => {
          const token = generateJWT(user);
          const cookieOptions = {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 24 * 60 * 60 * 1000, // 24 hours
          };
          return { token, cookieOptions };
        };
        
        /**
         * Set the JWT token in a cookie
         * @param {Object} res - The response object
         * @param {string} token - The JWT token
         * @param {Object} cookieOptions - The cookie options
         */
        export const setTokenCookie = (res, token, cookieOptions) => {
          if (!res || !token || !cookieOptions) {
            throw new Error('Invalid parameters provided to setTokenCookie');
          }
          res.cookie('propertyHubAuthToken', token, cookieOptions);
        };
        
        /**
         * Verify and decode a JWT token
         * @param {string} token - The JWT token to verify
         * @returns {Object} The decoded token payload
         * @throws {Error} If the token is invalid or expired
         */
        export const verifyJWT = (token) => {
          try {
            return jwt.verify(token, process.env.JWT_SECRET);
          } catch (error) {
            throw new Error('Invalid or expired token');
          }
        };
      |-removeRestrictedFields.js
        
        
        /**
         * Utility function to remove restricted fields from an updates object.
         * @param {Object} updates - The updates object containing fields to be modified.
         * @param {Array<string>} restrictedFields - An array of field names that should not be modified.
         * @returns {Object} - The sanitized updates object with restricted fields removed.
         */
        export const removeRestrictedFields = (updates, restrictedFields) => {
            // Create a shallow copy of updates to avoid directly modifying the original object
            const sanitizedUpdates = { ...updates };
          
            // Loop through restrictedFields and delete them from updates if they exist
            restrictedFields.forEach(field => {
              if (field in sanitizedUpdates) {
                delete sanitizedUpdates[field];
              }
            });
          
            return sanitizedUpdates;
          };
          
      |-excludeSensitiveInfo.js
        
        
        /**
         * @desc Exclude sensitive fields from the Mongoose model object before sending the response.
         * @param {Object} modelObject - The Mongoose model object.
         * @param {Array<string>} fieldsToExclude - Array of fields to exclude from the object. Defaults to ['password'].
         * @returns {Object} - The object with specified fields excluded, ready to send as a response.
         */
        export const excludeSensitiveInfo = (modelObject, fieldsToExclude = ['password']) => {
            const modelObj = modelObject.toObject(); // Convert Mongoose document to plain JS object
          
            fieldsToExclude.forEach(field => {
              delete modelObj[field];
            });
          
            return modelObj; // Return the sanitized object
          };
          
      |-mongooseUtils.js
        /*
         * This utility function checks if an ID is a valid MongoDB ObjectId. This is useful for ensuring that
         */
        
        import mongoose from 'mongoose';
        
        export const isValidObjectId = (id) => {
            console.log(isValidObjectId);
            return mongoose.Types.ObjectId.isValid(id);
        };
      |-errorFormatter.js
        /**
         * Formats errors for consistent API response.
         * @param {string} message - A general error message.
         * @param {array} errors - Optional array of field-specific errors.
         * @param {number} statusCode - Optional HTTP status code (default 400).
         */
        export const formatError = (message, errors = [], statusCode = 400) => {
          return {
            success: false,
            error: {
              message,
              errors: errors.length > 0 ? errors : undefined,  // Only include errors if there are any
            },
            statusCode,
          };
        };
      |-customErrors.js
        class CustomError extends Error {
            constructor(message, statusCode, errors = []) {
                super(message);
                this.statusCode = statusCode;
                this.errors = errors;
                this.name = this.constructor.name;
            }
        
            toJSON() {
                return {
                    success: false,
                    error: {
                        message: this.message,
                        errors: this.errors.length > 0 ? this.errors : undefined,
                    },
                    statusCode: this.statusCode,
                };
            }
        }
        
        export class UnauthorizedError extends CustomError {
            constructor(message = 'Unauthorized access', errors = []) {
                super(message, 401, errors);
            }
        }
        
        export class ForbiddenError extends CustomError {
            constructor(message = 'Forbidden action', errors = []) {
                super(message, 403, errors);
            }
        }
        
        export class ValidationError extends CustomError {
            constructor(message = 'Validation failed', errors = []) {
                super(message, 400, errors);
            }
        }
        
        export class BusinessLogicError extends CustomError {
            constructor(message = 'Business logic error occurred', errors = []) {
                super(message, 400, errors);
            }
        }
        
        export class NotFoundError extends CustomError {
            constructor(message = 'Resource not found') {
                super(message, 404);
            }
        }
        
        export class ServerError extends CustomError {
            constructor(message = 'Internal Server Error') {
                super(message, 500);
            }
        }
        
        export class MongooseValidationError extends ValidationError {
            constructor(mongooseError) {
                // Extract and format validation errors from Mongoose
                const formattedErrors = Object.keys(mongooseError.errors).map(key => ({
                    field: key,
                    message: mongooseError.errors[key].message,
                }));
                super('Validation failed for some fields.', formattedErrors);
            }
        }
        
        
        export { CustomError };
    |-routes/
      |-userRoutes.js
        
        import express from 'express';
        import {
          getAllUsers,
          getUserById,
          updateUser,
          deleteUser,
        } from '../controllers/user/userController.js';
        import {validateObjectId} from '../middleware/validation/validateObjectId.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        
        import { 
          checkIsUserSelfOrAdmin
        } from '../middleware/auth/roleMiddleware.js';  // Role-based access control
        import { validateUpdateUserFields } from '../middleware/validation/userUpdateValidation.js';  // Input validation for users
        
        
        const router = express.Router();
        
        /**
         * ============================
         * User Routes
         * ============================
         */
        
        // Get all users (public)
        router.get(
          '/', 
          getAllUsers
        );
        
        
        // Get a specific users by ID (public)
        router.get(
          '/:id',
          validateObjectId, 
          getUserById
        );
        
        // Update user information (admin or the user themselves)
        router.put(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsUserSelfOrAdmin, 
          validateUpdateUserFields, 
          updateUser
        );
        
        // Delete an user (admin or the user themselves)
        router.delete(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsUserSelfOrAdmin, 
          deleteUser
        );
        
        export default router;
        
      |-agentRoutes.js
        /**
         * This file contains the routes for agent management in the system.
         */
        
        import express from 'express';
        import {
          getAllAgents,
          getAgentById,
          updateAgentStatus,
          updateAgent,
          deleteAgent,
        } from '../controllers/agent/agentController.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        import { checkIsAdmin, checkIsAgentSelfOrAdmin} from '../middleware/auth/roleMiddleware.js';  // Role-based access control
        import { validateUpdateAgentFields } from '../middleware/validation/agentUpdateValidation.js';  // Input validation for agents
        import {validateObjectId} from '../middleware/validation/validateObjectId.js';
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Agent Routes
         * ============================
         */
        
        // Get all agents (public)
        router.get('/', getAllAgents);
        
        // Get a specific agent by ID (public)
        router.get(
          '/:id',
          validateObjectId, 
          getAgentById);
        
        // Admin-only route to approve or reject agents
        router.patch(
          '/:id/status', 
          authenticateJWT,
          validateObjectId,  
          checkIsAdmin, 
          updateAgentStatus
        );
        
        // Update agent information (admin or the agent themselves)
        router.put(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsAgentSelfOrAdmin, 
          validateUpdateAgentFields, 
          updateAgent);
        
        // Delete an agent (admin or the agent themselves)
        router.delete(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsAgentSelfOrAdmin, 
          deleteAgent
        );
        
        
        export default router;
        
      |-transactionRoutes.js
        import express from 'express';
        const router = express.Router();
        
        // Placeholder routes for transactions (buying, renting)
        router.get('/', (req, res) => {
          res.send('Transaction route');
        });
        
        export default router;
      |-initRoutes.js
        import authRoutes from './authRoutes.js';
        import userRoutes from './userRoutes.js';
        import propertyRoutes from './propertyRoutes.js';
        import transactionRoutes from './transactionRoutes.js';
        import adminRoutes from './adminRoutes.js';
        import agentRoutes from './agentRoutes.js';
        import faqRoutes from './faqRoutes.js';
        
        
        const initRoutes = (app) => {
          app.use('/api/auth', authRoutes);             // Authentication routes
          app.use('/api/users', userRoutes);            // User-related routes
          app.use('/api/properties', propertyRoutes);   // Property routes
          app.use('/api/transactions', transactionRoutes); // Transaction routes (buy, rent)
          app.use('/api/admin', adminRoutes);           // Admin-specific routes
          app.use('/api/agents', agentRoutes);          // Agent-specific routes
          app.use('/api/faqs', faqRoutes);
        };
        
        export default initRoutes;
        
      |-adminRoutes.js
        /**
         * This file contains the routes for admin management in the system.
         */
        
        import express from 'express';
        import {
          getAllAdmins,
          getAdminById,
          updateAdmin,
          deleteAdmin,
        } from '../controllers/admin/adminController.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';  // JWT auth middleware for protected routes
        import { checkIsAdmin,checkIsAdminSelfOrSuperAdmin} from '../middleware/auth/roleMiddleware.js';
        import { validateAdminUpdateFields } from '../middleware/validation/adminUpdateValidation.js';
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js';
        import {validateObjectId} from '../middleware/validation/validateObjectId.js';
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Admin Routes
         * ============================
         */
        
        // Admin Management
        
        // Get all admins (admin-only route)
        router.get('/', 
          authenticateJWT,
          checkIsAdmin, 
          getAllAdmins);
        
        // Get a specific admin by ID (admin-only route)
        router.get('/:id', 
          authenticateJWT,
          validateObjectId,
          checkIsAdmin, 
          getAdminById);
        
        // Update admin information (admin-only route)
        router.put('/:id',
          authenticateJWT,
          validateObjectId,  // Add this new middleware
          checkIsAdminSelfOrSuperAdmin,
          validateAdminUpdateFields,
          handleValidationErrors,
          updateAdmin
        );
        
        // Delete an admin (super admin only)
        router.delete('/:id',
          authenticateJWT,
          validateObjectId,
          checkIsAdminSelfOrSuperAdmin,
          deleteAdmin);
        
        export default router;
      |-propertyRoutes.js
        import express from 'express';
        const router = express.Router();
        
        // Placeholder routes for property-related operations
        router.get('/', (req, res) => {
          res.send('Property route');
        });
        
        export default router;
      |-authRoutes.js
        import express from 'express';
        import passport from 'passport';
        import '../config/passport.js'; // Ensure Passport configuration is loaded
        import {
          googleOAuthSignupCallback,
          googleOAuthSigninCallback
        } from '../controllers/auth/googleOAuthController.js';
        import {
          checkUsername,
          checkEmail,
        } from '../controllers/validation/validationController.js'; // Controllers for username and email checks
        import {
          createUser,
          authenticateUser,
          logoutUser,
          // forgotPassword,
          // resetPassword,
          // verifyToken
        } from '../controllers/auth/userAuthController.js';
        import { validateUserFields } from '../middleware/validation/userValidation.js';
        
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        
        import {
          createAdmin,
          loginAdmin,
        } from '../controllers/auth/adminAuthController.js';
        import { validateAdminFields } from '../middleware/validation/adminValidation.js';
        import {checkIsSuperAdmin} from '../middleware/auth/roleMiddleware.js';
        
        import {
          createAgent,
          loginAgent,
        } from '../controllers/auth/agentAuthController.js';
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js';
        import { validateAgentFields } from '../middleware/validation/agentValidation.js';  // Input validation for agents
        
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Google OAuth Routes
         * ============================
         */
        
        // Google OAuth Sign-Up Route
        router.get(
          '/google/signup', 
          passport.authenticate('google-signup'));
        
        // Google OAuth Sign-In Route
        router.get(
          '/google/signin', 
          passport.authenticate('google-signin')
        );
        
        // Google OAuth Callback for Sign Up
        router.get(
          '/google/signup/callback',
          passport.authenticate('google-signup', { session: false, failureRedirect: `${process.env.CLIENT_URI}/signup` }),
          googleOAuthSignupCallback
        );
        
        // Google OAuth Callback for Sign In
        router.get(
          '/google/signin/callback',
          passport.authenticate('google-signin', { session: false, failureRedirect: `${process.env.CLIENT_URI}/signin` }),
          googleOAuthSigninCallback
        );
        
        /**
         * ============================
         * Local Authentication Routes
         * ============================
         */
        
        // Sign-up route with validation
        router.post(
          '/signup', 
          validateUserFields,
          handleValidationErrors,  
          createUser
        );
        
        // Check if username is available (with validation middleware)
        router.get(
          '/check-username/:username', 
          checkUsername);
        
        // Check if email is already registered (with validation middleware)
        router.get(
          '/check-email/:email', 
          checkEmail);
        
        
        // User login with email and password (Local Authentication)
        router.post(
          '/signin', 
          authenticateUser
        );
        
        // Logout route (JWT-based, invalidates JWT on the client-side)
        router.post(
          '/logout', 
          logoutUser
        );
        
        /* 
        // Forgot Password (Send reset password link)
        router.post('/forgot-password', forgotPassword);
        
        // Reset Password (Handle reset with token)
        router.post('/reset-password', resetPassword);
        
        // Verify if the JWT token is still valid
        router.get('/verify-token', authenticateJWT, verifyToken);
        */
        
        /**
         * ============================
         * Admin Authentication Routes
         * ============================
         */
        
        // Create a new admin (super admin only)
        router.post(
          '/admins/signup',
          authenticateJWT, 
          checkIsSuperAdmin,
          validateAdminFields,
          handleValidationErrors,  
          createAdmin
        );
        
        // Admin Login
        router.post(
          '/admins/login',
           loginAdmin
        );
        
        /**
         * ============================
         * Agent Authentication Routes
         * ============================
         */
        
        // Register a new agent (public route)
        router.post(
          '/agents/signup',
          validateAgentFields,
          handleValidationErrors,  
          createAgent
        );
        
        // Agent login route (public)
        router.post(
          '/agents/login',
          loginAgent
        );
        
        export default router;
      |-faqRoutes.js
        import express from 'express';
        import { getAllFaqs, createFaq, updateFaq, deleteFaq } from '../controllers/faq/faqController.js';
        
        const router = express.Router();
        
        // Get All FAQS (GET /api/faqs)
        router.get('/', getAllFaqs);
        
        // Create a new FAQ (POST /api/faqs)
        router.post('/', createFaq);
        
        // Update an existing FAQ (PUT /api/faqs/:id)
        router.put('/:id', updateFaq);
        
        // Delete an existing FAQ (DELETE /api/faqs/:id)
        router.delete('/:id', deleteFaq);
        
        export default router;
        
    |-middleware/
      |-error/
        |-test.js
          class CustomError extends Error {
              constructor(message, statusCode, errors = []) {
                  super(message);
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.name = this.constructor.name;
              }
          
              toJSON() {
                  return {
                      success: false,
                      error: {
                          message: this.message,
                          errors: this.errors.length > 0 ? this.errors : undefined,
                      },
                      statusCode: this.statusCode,
                  };
              }
          }
          
          const eror = new CustomError("Not found", 404)
          console.log(eror.toJSON())
        |-globalErrorMiddleware.js
          import { ValidationError, BusinessLogicError, NotFoundError, ServerError, CustomError } from '../../utils/customErrors.js';
          
          /**
           * Global error handler middleware
           */
          const errorHandler = (err, req, res, next) => {
              let errorResponse;
          
              // Check if it's one of our custom errors
              if (err instanceof CustomError) {
                  errorResponse = err.toJSON();  // Use the custom error's toJSON method
              } else {
                  // If it's an unknown error, wrap it in a generic ServerError
                  const serverError = new ServerError('An unexpected error occurred');
                  errorResponse = serverError.toJSON();
          
                  // Optionally, log the original error in case it's unexpected
                  console.error('Unexpected Error:', err);
              }
          
              // Log stack trace in development mode for easier debugging
              if (process.env.NODE_ENV === 'development') {
                  console.error('Error Stack:', err.stack);
                  errorResponse.error.stack = err.stack;  // Include the stack trace in development mode
              }
          
              // Ensure statusCode is set in case something went wrong
              const statusCode = errorResponse.statusCode || 500;
          
              // Send the formatted error response to the client
              return res.status(statusCode).json(errorResponse);
          };
          
          export default errorHandler;
      |-common/
        |-checkRequiredFields.js
          import { formatError } from '../../utils/errorFormatter.js';
          
          /**
           * @desc Middleware to check for required fields in different request locations (body, query, params).
           * @param {Object} requiredFields - An object that specifies required fields and where to look for them (body, query, params).
           * @returns {Function} Middleware function
           */
          const checkRequiredFields = (requiredFields) => {
            return (req, res, next) => {
              const errors = [];
          
              // Loop through the specified required fields
              for (const [location, fields] of Object.entries(requiredFields)) {
                fields.forEach(field => {
                  if (!req[location] || !req[location][field]) {
                    errors.push({
                      field,
                      message: `${field} is required in ${location}.`,  // Dynamic error message
                    });
                  }
                });
              }
          
              // If errors are found, return the formatted error response
              if (errors.length > 0) {
                return next(formatError('Required fields missing', errors, 400));
              }
          
              // No errors, move to the next middleware
              next();
            };
          };
          
          export default checkRequiredFields;
        |-checkEmptyBody.js
          import { formatError } from '../../utils/errorFormatter.js';
          
          /**
           * @desc Middleware to check if the request body is empty and format the error using `errorFormatter`.
           *       This is reusable across different routes and contexts.
           * @param {String} message - Custom error message to return when the body is empty.
           * @returns {Function} - Middleware function to handle the empty body check.
           */
          const checkEmptyBody = (message = 'Request body is empty. Please provide valid data.') => {
            return (req, res, next) => {
              // Check if the request body is empty
              if (Object.keys(req.body).length === 0) {
                // Format and return the error
                const error = formatError(message, [], 400);  // Use `formatError` with the custom message
                return next(error);  // Pass the error to the global error handler
              }
              next();  // Proceed to the next middleware if the body isn't empty
            };
          };
          
          export default checkEmptyBody;
        |-handleValidationErrors.js
          import { validationResult } from 'express-validator';
          import { ValidationError } from '../../utils/customErrors.js';  // Use your custom ValidationError
          
          /**
           * Middleware to handle validation errors from express-validator.
           */
          export const handleValidationErrors = (req, res, next) => {
            const errors = validationResult(req);
          
            if (!errors.isEmpty()) {
              // Format validation errors: Each error includes only the field and its message
              const formattedErrors = errors.array().map(err => ({
                field: err.param,  // Field name (like "email")
                message: err.msg,  // Error message (like "Please provide a valid email address")
              }));
          
              // Pass the formatted errors to the global error handler using custom ValidationError
              return next(new ValidationError('Validation failed due to invalid inputs.', formattedErrors));
            }
          
            // Proceed if no validation errors
            next();
          };
      |-auth/
        |-authMiddleware.js
          import jwt from 'jsonwebtoken';
          import { UnauthorizedError, ForbiddenError } from '../../utils/customErrors.js';  // Import your custom error classes
          
          /**
           * @desc Authenticates the user using a JWT token.
           * @param {Object} req - The request object.
           * @param {Object} res - The response object.
           * @param {Function} next - The next middleware function.
           * @returns {void} - Calls the next middleware if authentication is successful.
           * @throws {UnauthorizedError} - Throws a 401 error if the token is missing.
           * @throws {ForbiddenError} - Throws a 403 error if the token is invalid or expired.
           */
          const authenticateJWT = (req, res, next) => {
            // Check if the token is sent in the Authorization header
            let token = req.header('Authorization')?.replace('Bearer ', '');
          
            // If not, check if the token is stored in a cookie
            if (!token) {
              token = req.cookies?.token;
            }
          
            // If no token is found, throw an UnauthorizedError
            if (!token) {
              return next(new UnauthorizedError('Unauthorized access. Token is missing, please log in.'));
            }
          
            try {
              // Verify the token using the secret key
              const decoded = jwt.verify(token, process.env.JWT_SECRET);
              req.user = decoded;  // Attach the decoded user info to `req.user`
              next();  // Continue to the next middleware/route handler
            } catch (error) {
              // If the token is invalid or expired, throw a ForbiddenError
              return next(new ForbiddenError('Invalid token or session expired. Please log in again.'));
            }
          };
          
          export default authenticateJWT;
        |-roleMiddleware.js
          import { ForbiddenError } from '../../utils/customErrors.js';  // Import custom ForbiddenError
          
          /**
           * @desc - Check if the user is an admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is not an admin
           */
          export const checkIsAdmin = (req, res, next) => {
            // Check if the user is authenticated and has the role 'admin' or 'super-admin'
            if (req.user && (req.user.role === 'admin' || req.user.role === 'super-admin')) {
              return next();  // Proceed if the user is an admin or super-admin
            }
          
            // If the user is not an admin, throw a ForbiddenError
            return next(new ForbiddenError('Access forbidden: Admins only.'));
          };
          
          /**
           * @desc - Check if the user is a super admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is not a super admin
           */
          export const checkIsSuperAdmin = (req, res, next) => {
            // Check if the user is authenticated and has the role 'super-admin'
            if (req.user && req.user.role === 'super-admin') {
              return next();  // Proceed if the user is a super-admin
            }
          
            // If the user is not a super-admin, throw a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * @desc - Check if the user is either the admin they are modifying or a super admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is neither the admin themselves nor a super admin
           */
          export const checkIsAdminSelfOrSuperAdmin = (req, res, next) => {
            const { id } = req.params;  // The ID of the admin being accessed (from URL param)
            const { role, id: userId } = req.user;  // The role and ID of the logged-in user (from JWT payload)
          
            // Allow access if the user is a super-admin
            if (role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is modifying their own account
            if (userId === id) {
              return next();
            }
          
            // If neither, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * @desc - Middleware to check if the user is either an admin or the agent themselves
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is neither the admin nor the agent
           */
          export const checkIsAgentSelfOrAdmin = (req, res, next) => {
            const { id } = req.params;  // The agent ID being accessed from the URL
            const { role, id: userId } = req.user;  // The logged-in user's role and ID from JWT payload
          
            // Allow access if the user is an admin (admin or super-admin)
            if (role === 'admin' || role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is updating their own account
            if (userId === id) {
              return next();
            }
          
            // If neither condition is met, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * Middleware to check if the user is either an admin or the user themselves.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express next middleware function.
           * @returns {void} - Calls next if authorized, throws ForbiddenError otherwise.
           */
          export const checkIsUserSelfOrAdmin = (req, res, next) => {
            const { id } = req.params;  // The user ID being accessed from the URL
            const { role, id: userId } = req.user;  // The logged-in user's role and ID from JWT payload
          
            // Allow access if the user is an admin
            if (role === 'admin' || role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is updating their own account
            if (userId === id) {
              return next();
            }
          
            // If neither condition is met, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
        |-globalMiddlewares.js
          import cors from 'cors';
          import express from 'express';
          import morgan from 'morgan';
          import helmet from 'helmet';
          import compression from 'compression';
          import rateLimit from 'express-rate-limit';
          
          // Apply all global middlewares
          const applyGlobalMiddleware = (app) => {
            // Body parsers
            app.use(express.json()); // Parse JSON requests
            app.use(express.urlencoded({ extended: true })); // Parse URL-encoded data
          
            // CORS middleware
            app.use(cors({
              origin: process.env.CLIENT_URI, // Your frontend URL
              credentials: true // Allow credentials (cookies, authorization headers, etc.)
            }));
          
            // Security middleware
            app.use(helmet()); // Secure app by setting various HTTP headers
          
            // Logging middleware
            app.use(morgan('dev')); // Log HTTP requests in the console (for dev environments)
          
            // Compression middleware
            app.use(compression()); // Compress response bodies for performance
          
            // Rate limiting middleware (optional but recommended)
            const limiter = rateLimit({
              windowMs: 15 * 60 * 1000, // 15 minutes
              max: 100, // Limit each IP to 100 requests per window
            });
            app.use(limiter); // Apply rate limiter to all requests
          };
          
          export default applyGlobalMiddleware;
      |-validation/
        |-userUpdateValidation.js
          import { body } from 'express-validator';
          import mongoose from 'mongoose';
          import User from '../../models/User.js';
          
          /**
           * @desc Middleware array that validates the fields for User updates.
           *       Fields are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling user requests.
           */
          export const validateUpdateUserFields = [
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            body('username')
              .optional()
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value, { req }) => {
                const user = await User.findOne({ username: value, _id: { $ne: req.params.id } });
                if (user) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value, { req }) => {
                const user = await User.findOne({ email: value, _id: { $ne: req.params.id } });
                if (user) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            body('avatar')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            body('role')
              .optional()
              .isIn(['user']).withMessage('Invalid role. Only "user" is allowed.'),
          
            body('accountStatus')
              .optional()
              .isIn(['active', 'pending', 'suspended', 'deactivated']).withMessage('Invalid account status.'),
          
            body('isEmailVerified')
              .optional()
              .isBoolean().withMessage('Email verification status must be true or false.'),
          
            body('lastLogin')
              .optional()
              .isISO8601().withMessage('Last login must be a valid date.'),
          
            body('failedLoginAttempts')
              .optional()
              .isInt({ min: 0 }).withMessage('Failed login attempts must be a positive integer.'),
          
            body('lockUntil')
              .optional()
              .isISO8601().withMessage('Lock until must be a valid date.'),
          
            body('isUsernameCustomized')
              .optional()
              .isBoolean().withMessage('isUsernameCustomized must be a boolean value (true or false).'),
          ];
          
        |-userValidation.js
          import { body } from 'express-validator';
          import {accountStatusEnum } from '../../models/User.js'; // Importing enums for validation
          
          export const validateUserFields = [
            // Validate first name
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ min: 2, max: 30 }).withMessage('First name must be between 2 and 30 characters long.')
              .matches(/^[a-zA-Z]+$/).withMessage('First name can only contain letters.'),
          
            // Validate last name
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ min: 2, max: 30 }).withMessage('Last name must be between 2 and 30 characters long.')
              .matches(/^[a-zA-Z]+$/).withMessage('Last name can only contain letters.'),
          
            // Validate username
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 3, max: 20 }).withMessage('Username must be between 3 and 20 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain letters, numbers, and underscores.'),
          
            // Validate email
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.')
              .normalizeEmail(), // Normalize email address to lowercase
          
            // Validate password
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,}$/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Validate role (optional, default role will be 'user')
            body('role')
            .optional()
            .isIn(['user']).withMessage('Role must be: user'),
          
            // Validate account status (optional, default is 'active')
            body('accountStatus')
              .optional()
              .isIn(accountStatusEnum).withMessage(`Account status must be one of: ${accountStatusEnum.join(', ')}`),
          
            // Ensure isEmailVerified is a boolean (optional)
            body('isEmailVerified')
              .optional()
              .isBoolean().withMessage('Email verification status must be a boolean value (true or false).'),
          
            // Ensure lastLogin is a valid date (optional)
            body('lastLogin')
              .optional()
              .isISO8601().withMessage('Last login must be a valid date.'),
          
            // Validate failedLoginAttempts (optional, should be an integer)
            body('failedLoginAttempts')
              .optional()
              .isInt({ min: 0 }).withMessage('Failed login attempts must be a positive integer.'),
          
            // Validate lockUntil (optional, should be a valid date)
            body('lockUntil')
              .optional()
              .isISO8601().withMessage('Lock until must be a valid date.'),
            
            // Validate avatar (optional)
            body('avatar')
              .optional()
              .isURL().withMessage('Avatar must be a valid URL.')
          ];
        |-validateObjectId.js
          import { isValidObjectId } from 'mongoose';
          import { ValidationError } from '../../utils/customErrors.js';
          
          export const validateObjectId = (req, res, next) => {
            const { id } = req.params;
            if (!isValidObjectId(id)) {
              return next(new ValidationError('Invalid ID'));
            }
            next();
          };
        |-propertyValidation.js
          import { body } from 'express-validator';
          
          export const validatePropertyFields = [
            body('title')
              .notEmpty().withMessage('Title is required.')
              .isLength({ max: 100 }).withMessage('Title cannot exceed 100 characters.'),
          
            // Description: required and max length 500 characters
            body('description')
              .notEmpty().withMessage('Description is required.')
              .isLength({ max: 500 }).withMessage('Description cannot exceed 500 characters.'),
          
            // Property Type: required and must be one of the predefined types
            body('propertyType')
              .notEmpty().withMessage('Property type is required.')
              .isIn(['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'])
              .withMessage('Invalid property type. Must be one of: Apartment, House, Condo, Land, Villa, Office, Studio.'),
          
            // Price: required and must be a positive number
            body('price')
              .notEmpty().withMessage('Price is required.')
              .isFloat({ min: 0 }).withMessage('Price must be a positive number.'),
          
            // Status: optional, but if present must be one of the allowed statuses
            body('status')
              .optional()
              .isIn(['Available', 'Sold', 'Rented', 'Pending'])
              .withMessage('Invalid status. Must be one of: Available, Sold, Rented, Pending.'),
          
            // Size: required and must be a positive number
            body('size')
              .notEmpty().withMessage('Size is required.')
              .isFloat({ min: 0 }).withMessage('Size must be a positive number.'),
          
            // Bedrooms: required and must be a positive integer
            body('bedrooms')
              .notEmpty().withMessage('Number of bedrooms is required.')
              .isInt({ min: 1 }).withMessage('Bedrooms must be at least 1.'),
          
            // Bathrooms: required and must be a positive integer
            body('bathrooms')
              .notEmpty().withMessage('Number of bathrooms is required.')
              .isInt({ min: 1 }).withMessage('Bathrooms must be at least 1.'),
          
            // Rooms: required and must be a positive integer
            body('rooms')
              .notEmpty().withMessage('Number of rooms is required.')
              .isInt({ min: 1 }).withMessage('Rooms must be at least 1.'),
          
            // Offer Type: required and must be either 'Sale' or 'Rent'
            body('offerType')
              .notEmpty().withMessage('Offer type is required.')
              .isIn(['Sale', 'Rent']).withMessage('Offer type must be either Sale or Rent.'),
          
            // Coordinates: Latitude and Longitude must be valid numbers
            body('coordinates.lat')
              .notEmpty().withMessage('Latitude is required.')
              .isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90.'),
            body('coordinates.lng')
              .notEmpty().withMessage('Longitude is required.')
              .isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180.'),
          
            // Address: street, city, state, zipCode are required
            body('address.street')
              .notEmpty().withMessage('Street address is required.')
              .isLength({ max: 100 }).withMessage('Street address cannot exceed 100 characters.'),
            body('address.city')
              .notEmpty().withMessage('City is required.'),
            body('address.state')
              .notEmpty().withMessage('State is required.'),
            body('address.zipCode')
              .notEmpty().withMessage('Zip code is required.')
              .matches(/^\d{5}(-\d{4})?$/).withMessage('Please provide a valid zip code.'),
          
            // Images: Optional but must be valid URLs if provided
            body('images')
              .optional()
              .isArray().withMessage('Images must be an array of URLs.')
              .custom((images) => {
                for (let url of images) {
                  if (!/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(url)) {
                    throw new Error('Invalid image URL. Must be a valid URL pointing to a jpg, jpeg, png, or webp file.');
                  }
                }
                return true;
              }),
          
            // Optional: Year built, but if present, it must be between 1800 and the current year
            body('yearBuilt')
              .optional()
              .isInt({ min: 1800, max: new Date().getFullYear() })
              .withMessage(`Year built must be between 1800 and ${new Date().getFullYear()}.`),
          ];
        |-adminValidation.js
          /**
           * This file contains middleware functions that validate the fields for creating a new Admin.
           */
          
          import { body } from 'express-validator';
          
          /**
           * @desc Middleware array that validates the fields for creating a new Admin.
           * @returns {Array} An array of validation rules to be applied before handling admin creation requests.
           */
          export const validateAdminFields = [
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.'),
          
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.'),
          
            body('phoneNumber')
              .notEmpty().withMessage('Phone number is required.')
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number in E.164 format (e.g., +1234567890).'),
          
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            body('role')
              .optional()
              .isIn(['admin', 'super-admin']).withMessage('Role must be either "admin" or "super-admin".'),
          
            body('permissions')
              .optional()
              .isArray().withMessage('Permissions must be an array.')
              .custom((permissions) => {
                const validPermissions = ['manage_users', 'manage_agents', 'view_reports', 'manage_admins'];
                for (const permission of permissions) {
                  if (!validPermissions.includes(permission)) {
                    throw new Error(`Invalid permission: ${permission}.`);
                  }
                }
                return true;
              }),
          
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL (jpg, jpeg, png, or webp).')
          ];
        |-agentUpdateValidation.js
          import { body } from 'express-validator';
          import mongoose from 'mongoose';
          import Agent from '../../models/Agent.js';
          
          /**
           * @desc Middleware array that validates the fields for Agent updates.
           *       Fields are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling agent requests.
           */
          export const validateUpdateAgentFields = [
            // First name validation
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            // Last name validation
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            // Username validation (must be unique)
            body('username')
              .optional()
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ username: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            // Email validation (must be unique)
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ email: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            // Phone number validation (must be unique, E.164 format)
            body('phoneNumber')
              .optional()
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ phoneNumber: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Phone number already exists.');
                }
              }),
          
            // Agency name validation
            body('agency')
              .optional()
              .isLength({ max: 100 }).withMessage('Agency name cannot exceed 100 characters.'),
          
            // Bio validation (optional)
            body('bio')
              .optional()
              .isLength({ max: 1000 }).withMessage('Bio cannot exceed 1000 characters.'),
          
            // License number validation (must be unique)
            body('licenseNumber')
              .optional()
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ licenseNumber: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('License number already exists.');
                }
              }),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            // Password validation (optional)
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Properties validation (optional)
            body('properties')
              .optional()
              .isArray().withMessage('Properties must be an array of ObjectIds.')
              .custom((value) => {
                if (!value.every(mongoose.Types.ObjectId.isValid)) {
                  throw new Error('Invalid property IDs.');
                }
                return true;
              }),
          
            // Social media links validation (optional)
            body('socialMediaLinks.facebook')
              .optional()
              .matches(/^https?:\/\/(www\.)?facebook.com\/.+$/).withMessage('Please provide a valid Facebook URL.'),
          
            body('socialMediaLinks.linkedin')
              .optional()
              .matches(/^https?:\/\/(www\.)?linkedin.com\/.+$/).withMessage('Please provide a valid LinkedIn URL.'),
          
            body('socialMediaLinks.twitter')
              .optional()
              .matches(/^https?:\/\/(www\.)?twitter.com\/.+$/).withMessage('Please provide a valid Twitter URL.'),
          
            // Availability validation (optional)
            body('availability')
              .optional()
              .isBoolean().withMessage('Availability must be true or false.'),
          ];
        |-adminUpdateValidation.js
          /**
           * This file contains middleware functions that validate the fields for updating an admin.
           */
          
          import { body } from 'express-validator';
          
          /**
           * @desc Middleware array that validates the fields for Admin updates (allows partial updates).
           * 
           * @returns {Array} An array of validation rules to be applied before handling admin update requests.
           */
          export const validateAdminUpdateFields = [
            // First name validation (optional for update)
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain letters.'),
          
            // Last name validation (optional for update)
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain letters.'),
          
            // Email validation (optional for update)
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.'),
          
            // Phone number validation (optional for update)
            body('phoneNumber')
              .optional()
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number in E.164 format (e.g., +1234567890).'),
          
            // Password validation (optional for update)
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,}$/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Role validation should not be allowed unless you're a super admin
            body('role')
              .optional()
              .custom((value, { req }) => {
                if (req.user.role !== 'super-admin') {
                  throw new Error('Only super-admin can update role.');
                }
                return true;
              }),
          
              body('permissions')
              .optional()
              .isArray().withMessage('Permissions must be an array.')
              .custom((permissions, { req }) => {
                const validPermissions = ['manage_users', 'manage_agents', 'view_reports', 'manage_admins'];
          
                // Ensure all provided permissions are valid
                const allValid = permissions.every(permission => validPermissions.includes(permission));
          
                if (!allValid) {
                  throw new Error('Invalid permission. Valid options are: manage_users, manage_agents, view_reports, manage_admins.');
                }
          
                return true;
              })
              .withMessage('Permissions must only contain valid values: manage_users, manage_agents, view_reports, manage_admins.'),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/)
              .withMessage('Please provide a valid image URL (jpg, jpeg, png, or webp).')
          ];
        |-agentValidation.js
          import { body } from 'express-validator';
          import Agent from '../../models/Agent.js';
          
          /**
           * @desc Middleware array that validates the fields for creating an Agent.
           * @returns {Array} An array of validation rules to be applied before handling agent creation requests.
           */
          export const validateAgentFields = [
            // First name validation
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            // Last name validation
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            // Username validation (must be unique)
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ username: value });
                if (agent) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            // Email validation (must be unique)
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ email: value });
                if (agent) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            // Phone number validation (must be unique, E.164 format)
            body('phoneNumber')
              .notEmpty().withMessage('Phone number is required.')
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ phoneNumber: value });
                if (agent) {
                  return Promise.reject('Phone number already exists.');
                }
              }),
          
            // Agency name validation
            body('agency')
              .notEmpty().withMessage('Agency name is required.')
              .isLength({ max: 100 }).withMessage('Agency name cannot exceed 100 characters.'),
          
            // Bio validation (optional)
            body('bio')
              .optional()
              .isLength({ max: 1000 }).withMessage('Bio cannot exceed 1000 characters.'),
          
            // License number validation (must be unique)
            body('licenseNumber')
              .notEmpty().withMessage('License number is required.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ licenseNumber: value });
                if (agent) {
                  return Promise.reject('License number already exists.');
                }
              }),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            // Password validation
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Properties validation (optional)
            body('properties')
              .optional()
              .isArray().withMessage('Properties must be an array of ObjectIds.')
              .custom((value) => {
                if (!value.every(mongoose.Types.ObjectId.isValid)) {
                  throw new Error('Invalid property IDs.');
                }
                return true;
              }),
          
            // Social media links validation (optional)
            body('socialMediaLinks.facebook')
              .optional()
              .matches(/^https?:\/\/(www\.)?facebook.com\/.+$/).withMessage('Please provide a valid Facebook URL.'),
          
            body('socialMediaLinks.linkedin')
              .optional()
              .matches(/^https?:\/\/(www\.)?linkedin.com\/.+$/).withMessage('Please provide a valid LinkedIn URL.'),
          
            body('socialMediaLinks.twitter')
              .optional()
              .matches(/^https?:\/\/(www\.)?twitter.com\/.+$/).withMessage('Please provide a valid Twitter URL.'),
          
            // Availability validation (optional)
            body('availability')
              .optional()
              .isBoolean().withMessage('Availability must be true or false.'),
          ];
    |-services/
      |-validationServices.js
        import User from '../models/User.js';
        import { BusinessLogicError } from '../utils/customErrors.js';
        
        /**
         * Service to check if a username is available.
         * @param {string} username - The username to check.
         * @throws {BusinessLogicError} - Throws an error if the username is already taken.
         */
        export const isUsernameAvailable = async (username) => {
          const existingUser = await User.findOne({ username });
          
          if (existingUser) {
            throw new BusinessLogicError('This username is unavailable.');
          }
          
          return true; // Username is available
        };
        
        /**
         * Service to check if an email is already registered.
         * @param {string} email - The email to check.
         * @throws {BusinessLogicError} - Throws an error if the email is already registered.
         */
        export const isEmailAvailable = async (email) => {
          const existingUser = await User.findOne({ email });
          
          if (existingUser) {
            throw new BusinessLogicError('This email is unavailable.');
          }
          
          return true; // Email is available
        };
      |-adminService.js
        import Admin from '../models/Admin.js';
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError,
          MongooseValidationError,
          ForbiddenError,
        } from '../utils/customErrors.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        
        /**
         * Business logic to create a new admin.
         * @param {Object} adminData - The data for creating the new admin.
         * @throws {BusinessLogicError | ServerError} - Throws errors if something goes wrong.
         * @returns {Object} - The newly created admin.
         */
        export const createNewAdmin = async (adminData) => {
          try {
            const { firstName, lastName, username, email, phoneNumber, password, role, permissions, profileImage } = adminData;
        
            // Check for duplicate fields (email, username, phoneNumber)
            const duplicateErrors = await checkDuplicateFields(Admin, { username, email, phoneNumber });
        
            // If duplicates are found, throw BusinessLogicError
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            // Create a new admin
            const newAdmin = new Admin({
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              password,
              role: role || 'admin',  // Default role is 'admin'
              permissions: permissions || ['manage_users', 'view_reports'],  // Default permissions for 'admin'
              profileImage,
            });
        
            // Save the new admin to the database
            await newAdmin.save();
        
            // Return the newly created admin
            return newAdmin;
        
          } catch (error) {
            // Throw any error to be caught by the controller
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating admin');  // Default to ServerError for unexpected errors
            }
          }
        };
        
        /**
         * Service to retrieve all admin users from the database.
         * @returns {Object[]} - Returns an array of admin objects with all fields.
         * @throws {Error} - Throws NotFoundError if no admins are found, or ServerError for other errors.
         */
        export const getAllAdminsService = async () => {
          try {
            // Find all admins (do not exclude sensitive info here)
            const admins = await Admin.find();
            
            if (!admins || admins.length === 0) {
              throw new NotFoundError('No admins found');
            }
        
            // Return raw data to the controller
            return admins;
        
          } catch (error) {
            if (error instanceof NotFoundError) {
              throw error; // Propagate the specific NotFoundError
            }
        
            // Wrap any other unexpected errors in a ServerError
            throw new ServerError('Error while fetching admins', 500);
          }
        };
        
        /**
         * Service to retrieve an admin by ID.
         * @param {string} id - The admin's ID from the request parameters.
         * @returns {Object} - Returns the found admin object or throws an error.
         */
        export const getAdminByIdService = async (id) => {
          try {
            // Find the admin by ID, excluding the password field
            const admin = await Admin.findById(id)
        
            if (!admin) {
              throw new NotFoundError('Admin not found');
            }
        
            // Return the admin data
            return admin;
        
          } catch (error) {
            // Handle specific and unexpected errors
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error retrieving admin');
          }
        };
        
        /**
         * Service to delete an admin by ID.
         * @param {string} id - The admin's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the admin with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteAdminService = async (id) => {
          try {
            // Find the admin by ID
            const admin = await Admin.findById(id);
            if (!admin) {
              throw new NotFoundError('Admin not found');
            }
        
            // Delete the admin
            await admin.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting admin');
          }
        };
        
        /**
         * Service to update a specific admin's information.
         * @param {string} id - The admin's ID.
         * @param {Object} updates - The updates to be applied to the admin.
         * @param {string} userRole - The role of the user making the update request (either 'admin' or 'super-admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the admin is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'permissions'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated admin object.
         */
        export const updateAdminService = async (id, updates, userRole) => {
          try {
            // Prevent non-super admins from updating 'role' and 'permissions'
            if (userRole !== 'super-admin') {
              if ('role' in updates || 'permissions' in updates) {
                throw new ForbiddenError('Only super-admin can modify role or permissions.');
              }
            }
        
                // List of fields that cannot be modified
                const restrictedFields = ['role', 'joinedAt'];
                // Remove restricted fields from updates using the utility function
                const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            // Attempt to find and update the admin
            const updatedAdmin = await Admin.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations for fields like email and phone number
            });
        
            if (!updatedAdmin) {
              throw new NotFoundError('Admin not found');
            }
        
            return updatedAdmin;
        
          } catch (error) {
            // Handle specific validation errors
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);  // Custom error class to handle Mongoose validation errors
            } else if (error instanceof ValidationError || error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;  // Propagate known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating admin information');
          }
        };
        
      |-agentService.js
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import Agent from '../models/Agent.js';
        import {isValidObjectId} from '../utils/mongooseUtils.js';
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError
        } from '../utils/customErrors.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        /**
         * Business logic to create a new agent.
         * @param {Object} agentData - The data for creating the new agent.
         * @throws {BusinessLogicError | ServerError} - Throws specific errors if necessary.
         * @returns {Object} - The newly created agent.
         */
        export const createNewAgent = async (agentData) => {
          try {
            const {
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              agency,
              bio,             // Optional field
              licenseNumber,
              profileImage,    // Optional field
              password,
              socialMediaLinks, // Optional field containing Facebook, LinkedIn, Twitter links
            } = agentData;  // Only pick the fields needed for agent creation
        
            // Check for duplicate fields
            const duplicateErrors = await checkDuplicateFields(Agent, { username, email, phoneNumber, licenseNumber });
        
            // If duplicates are found, throw a BusinessLogicError
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            // Proceed with creating the agent
            const newAgent = new Agent({
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              agency,
              bio,             // Include bio if provided
              licenseNumber,
              profileImage,    // Include profileImage if provided
              password,
              socialMediaLinks, // Include socialMediaLinks if provided
              role: 'agent',   // Default role is 'agent'
              agentStatus: 'pending'  // Default status is 'pending'
            });
        
            // Save the new agent to the database
            await newAgent.save();
        
            // Return the new agent
            return newAgent;
        
          } catch (error) {
            // Rethrow known errors or throw ServerError for unexpected cases
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating agent'); // Default to a server error
            }
          }
        };
        
        /**
         * Service to retrieve all agents from the database.
         * @returns {Object[]} - Returns an array of agent objects with all fields.
         * @throws {Error} - Throws NotFoundError if no agents are found, or ServerError for other errors.
         */
        export const getAllAgentsService = async () => {
          try {
            // Find all agents (do not exclude sensitive info here)
            const agents = await Agent.find();
        
            if (!agents || agents.length === 0) {
              throw new NotFoundError('No agents found');
            }
        
            // Return raw data to the controller
            return agents;
        
          } catch (error) {
            if (error instanceof NotFoundError) {
              throw error; // Propagate the specific NotFoundError
            }
        
            // Wrap any other unexpected errors in a ServerError
            throw new ServerError('Error while fetching agents', 500);
          }
        };
        
        /**
         * Service to retrieve an agent by ID.
         * @param {string} id - The agent's ID from the request parameters.
         * @returns {Object} - Returns the found agent object or throws an error.
         */
        export const getAgentByIdService = async (id) => {
          try {
            // Find the agent by ID
            const agent = await Agent.findById(id);
        
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Return the agent data
            return agent;
          } catch (error) {
            // Handle specific and unexpected errors
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error retrieving agent');
          }
        };
        
        /**
         * Service to delete an agent by ID.
         * @param {string} id - The agent's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the agent with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteAgentService = async (id) => {
          try {
            // Find the agent by ID
            const agent = await Agent.findById(id);
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Delete the agent
            await agent.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting agent');
          }
        };
        
        /**
         * Service to update a specific agent's information.
         * @param {string} id - The agent's ID.
         * @param {Object} updates - The updates to be applied to the agent.
         * @param {string} userRole - The role of the user making the update request (either 'agent' or 'super-admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the agent is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'permissions'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated agent object.
         */
        export const updateAgentService = async (id, updates, userRole) => {
          try {
        
            // List of fields that cannot be modified
            const restrictedFields = ['role', 'rating', 'reviews', 'joinedAt'];
            // Remove restricted fields from updates using the utility function
            const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            // Attempt to find and update the agent
            const updatedAgent = await Agent.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations for fields like email and phone number
            });
        
            if (!updatedAgent) {
              throw new NotFoundError('Agent not found');
            }
        
            return updatedAgent;
        
          } catch (error) {
            // Handle Mongoose validation errors
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);
            } else if (error instanceof ValidationError || error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;  // Propagate known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating agent information');
          }
        };
        
        /**
         * Service to update the status of a specific agent.
         * @param {string} id - The agent's ID.
         * @param {string} agentStatus - The new status to be applied to the agent.
         * @throws {ValidationError} - If the ID or status is invalid.
         * @throws {NotFoundError} - If the agent is not found.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated agent object.
         */
        export const updateAgentStatusService = async (id, agentStatus) => {
          try {
            // Ensure the provided agentStatus is valid
            const validStatuses = ['pending', 'active', 'rejected'];
            if (!validStatuses.includes(agentStatus)) {
              throw new ValidationError('Invalid status provided');
            }
        
            // Find the agent by ID
            const agent = await Agent.findById(id);
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Update the agent's status
            agent.agentStatus = agentStatus;
        
            // Save the updated agent
            await agent.save();
        
            return agent;  // Return the updated agent
          } catch (error) {
            if (error instanceof ValidationError || error instanceof NotFoundError) {
              throw error;  // Rethrow known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating agent status');
          }
        };
      |-userServices.js
        import User from '../models/User.js';
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError,
          MongooseValidationError 
        } from '../utils/customErrors.js';
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        /**
         * Business logic to create a new user.
         * @param {Object} userData - The data for creating the new user.
         * @throws {BusinessLogicError | ServerError} - Throws errors if something goes wrong.
         * @returns {Object} - The newly created user.
         */
        export const createNewUser = async (userData) => {
          try {
            const { firstName, lastName, username, email, password } = userData;
        
            // Check for duplicate fields (email, username)
            const duplicateErrors = await checkDuplicateFields(User, { email, username });
        
            // If duplicates are found, throw BusinessLogicError
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            // Create a new user
            const newUser = new User({
              firstName,
              lastName,
              username,
              email,
              password, // Password will be hashed automatically before saving
              role: 'user', // Default role is 'user'
            });
        
            // Save the new user to the database
            await newUser.save();
        
            // Return the newly created user
            return newUser;
        
          } catch (error) {
            // Throw any error to be caught by the controller
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating user'); // Default to ServerError for unexpected errors
            }
          }
        };
        
        /**
         * @desc    Business logic to retrieve all users from the database.
         * @throws  {ServerError} - Throws a server error in case something goes wrong.
         * @returns {Array} - Array of all users.
         */
        export const getAllUsersService = async () => {
          try {
            // Fetch all users from the database
            const users = await User.find();
        
            // Return the array of users
            return users;
        
          } catch (error) {
            throw new ServerError('Error retrieving users from the database');
          }
        };
        
        /**
         * Service to retrieve a user by their ID from the database.
         * @param {string} userId - The ID of the user to be fetched.
         * @returns {Object} - Returns the user object if found.
         * @throws {NotFoundError} - If the user is not found.
         * @throws {ServerError} - For other server errors.
         */
        export const getUserByIdService = async (userId) => {
          try {
            // Fetch user by ID
            const user = await User.findById(userId);
        
            if (!user) {
              throw new NotFoundError(`User with ID ${userId} not found`);
            }
        
            return user; // Return raw user data
          } catch (error) {
            if (error instanceof NotFoundError) {
              throw error; // Pass specific NotFoundError
            }
        
            // Wrap any unexpected errors in a ServerError
            throw new ServerError('Error while fetching user', 500);
          }
        };
        
        /**
         * Service to update a specific user's information.
         * @param {string} id - The user's ID.
         * @param {Object} updates - The updates to be applied to the user.
         * @param {string} userRole - The role of the user making the update request (either 'user' or 'admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the user is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'accountStatus'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated user object.
         */
        export const updateUserService = async (id, updates, userRole) => {
          try {
            // List of fields that cannot be modified
            const restrictedFields = ['role', 'accountStatus', 'createdAt', 'lastLogin'];
            
            const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            // Find and update the user
            const updatedUser = await User.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations
            });
        
            if (!updatedUser) {
              throw new NotFoundError('User not found');
            }
        
            return updatedUser;
        
          } catch (error) {
            // Handle Mongoose validation errors
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);
            } else if (error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;  // Rethrow known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating user information');
          }
        };
        
        /**
         * Service to delete a user by ID.
         * @param {string} id - The user's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the user with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteUserService = async (id) => {
          try {
            // Find the user by ID
            const user = await User.findById(id);
            if (!user) {
              throw new NotFoundError('User not found');
            }
        
            // Delete the user
            await user.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting user');
          }
        };
        
      |-authService.js
        import Admin from '../models/Admin.js';
        import Agent from '../models/Agent.js';
        import User from '../models/User.js';
        import generateUniqueUsername from '../utils/generateUniqueUsername.js'; // Default import
        import { ServerError} from '../utils/customErrors.js';
        import { BusinessLogicError } from '../utils/customErrors.js';
        
        /**
         * Authenticate admin by email and password.
         * @param {string} email - Admin email.
         * @param {string} password - Admin password.
         * @throws {UnauthorizedError | ServerError} - Throws specific errors if authentication fails.
         * @returns {Object} - Authenticated admin.
         */
        export const authenticateAdmin = async (email, password) => {
          try {
            // Find the admin by email
            const admin = await Admin.findOne({ email });
            if (!admin) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Verify the password
            const isPasswordValid = await admin.comparePassword(password);
            if (!isPasswordValid) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated admin if everything is fine
            return admin;
        
          } catch (error) {
            // Rethrow known errors or throw a generic server error
            if (error instanceof UnauthorizedError) {
              throw error;
            } else {
              throw new ServerError('Error during authentication');
            }
          }
        };
        
        /**
         * Business logic to authenticate an agent.
         * @param {String} email - The agent's email address.
         * @param {String} password - The agent's password.
         * @returns {Object} - Returns the authenticated agent or throws an error.
         */
        export const authenticateAgent = async (email, password) => {
          try {
            // Find the agent by email
            const agent = await Agent.findOne({ email });
        
            if (!agent) {
              // Throw error instead of returning
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Verify the password
            const isPasswordValid = await agent.comparePassword(password);
            if (!isPasswordValid) {
              // Throw error instead of returning
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated agent
            return { agent };
          } catch (error) {
            // Only throw ServerError if the caught error isn't already a known custom error
            if (error instanceof UnauthorizedError) {
              throw error;  // Pass the specific UnauthorizedError
            }
            
            // For other unexpected errors, throw a ServerError
            throw new ServerError('Error during agent authentication');
          }
        };
        
        export const handleGoogleOAuthSignup = async (userProfile) => {
          const { googleId, firstName, lastName, email, avatar } = userProfile;
        
          try {
            // Check if the user already exists in the database by googleId OR email
            const existingUser = await User.findOne({
              $or: [{ googleId }, { email }]
            });
        
            if (existingUser) {
              // If user exists, return the user with a flag indicating it's an existing user
              return { user: existingUser, isExisting: true };
            }
        
            // Create a new user in the database with a default role
            const newUser = new User({
              firstName,
              lastName,
              email,
              googleId,
              avatar,
              role: 'user',  // Add a default role
              username: await generateUniqueUsername(firstName, lastName, email),
            });
        
            await newUser.save();
        
            // Return the newly created user object with a flag indicating it's a new user
            return { user: newUser, isExisting: false };
          } catch (error) {
            console.error('Error during Google OAuth signup service:', error);
            throw new BusinessLogicError('Error processing signup');
          }
        };
        
        /**
         * Service to handle Google OAuth sign-in logic.
         * @param {Object} userProfile - Google user profile object containing user data.
         * @returns {Object} - Returns the user object if the user exists, otherwise throws an error.
         */
        export const handleGoogleOAuthSignin = async (userProfile) => {
          const { googleId, email } = userProfile;
        
          try {
            // Check if the user exists in the database by googleId OR email
            const existingUser = await User.findOne({ $or: [{ googleId }, { email }] });
        
            if (!existingUser) {
              // Throw an error if the user is not found
              throw new BusinessLogicError('User not found, please sign up');
            }
        
            // Return the existing user object
            return existingUser;
          } catch (error) {
            console.error('Error during Google OAuth signin service:', error);
            throw new BusinessLogicError('Error processing signin');
          }
        };
        
        /**
         * Service to handle user login.
         * @param {string} email - User's email address.
         * @param {string} password - User's password.
         * @throws {UnauthorizedError | ServerError} - Throws an error if authentication fails or if a server error occurs.
         * @returns {Object} - The authenticated user.
         */
        export const authenticateUserService = async (email, password) => {
          try {
            // Find the user by email
            const user = await User.findOne({ email });
        
            // If the user doesn't exist, throw UnauthorizedError
            if (!user) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Check if the password is correct
            const isPasswordValid = await user.comparePassword(password);
            if (!isPasswordValid) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated user
            return user;
          } catch (error) {
            // Catch unexpected server errors
            if (error instanceof UnauthorizedError) {
              throw error;
            } else {
              throw new ServerError('Server error during authentication');
            }
          }
        };
        
        /**
         * Clears the authentication token cookie, effectively logging the user out.
         * @param {Object} res - Express response object.
         * @returns {void}
         */
        export const clearTokenCookie = (res) => {
          const cookieOptions = {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 0,
          };
          
          // Clear the cookie by setting it with an expired maxAge
          res.cookie('propertyHubAuthToken', '', cookieOptions);
        };
        
    |-models/
      |-Admin.js
        /**
         * This file contains the schema for the Admin model.
         */
        
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        /**
         * @desc Admin model schema to represent admin users in the system. 
         *       It includes personal details, authentication data, and role-based permissions.
         *       Passwords are hashed before saving for security.
         */
        const adminSchema = new mongoose.Schema({
          firstName: {
            type: String,
            required: [true, 'First name is required.'],
            maxlength: [50, 'First name cannot exceed 50 characters.'],
          },
          lastName: {
            type: String,
            required: [true, 'Last name is required.'],
            maxlength: [50, 'Last name cannot exceed 50 characters.'],
          },
          username: {
            type: String,
            required: [true, 'Username is required.'],
            unique: true,
            minlength: [4, 'Username must be at least 4 characters long.'],
            maxlength: [30, 'Username cannot exceed 30 characters.'],
            match: [/^[a-zA-Z0-9_]+$/, 'Username can only contain alphanumeric characters and underscores.'],
          },
          email: {
            type: String,
            required: [true, 'Email is required.'],
            unique: true,
            match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email address.'],
          },
          phoneNumber: {
            type: String,
            required: [true, 'Phone number is required.'],
            match: [/^\+?[1-9]\d{1,14}$/, 'Please provide a valid phone number.'], // Format like +1234567890
          },
          password: {
            type: String,
            required: true,
            minlength: [6, 'Minimum length is 6 characters'],
            validate: {
              validator: function (value) {
                // Password must include at least one uppercase letter, one lowercase letter, and one number
                return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
              },
              message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.',
            },
          },
          role: {
            type: String,
            enum: ['admin', 'super-admin'],
            default: 'admin',  // Default role is "admin"
          },
          permissions: {
            type: [String],
            default: function () {
              return this.role === 'super-admin'
                ? ['manage_users', 'manage_agents', 'view_reports', 'manage_admins']
                : ['manage_users', 'view_reports'];  // Default permissions for "admin"
            },
            validate: {
              validator: function (permissionsArray) {
                // Check that all permissions are strings
                return permissionsArray.every(permission => typeof permission === 'string');
              },
              message: 'Permissions must be valid strings.',
            },
          },
          profileImage: {
            type: String,
            default: 'https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png',
            validate: {
              validator: function (value) {
                return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value);
              },
              message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).',
            },
          },
          joinedAt: {
            type: Date,
            default: Date.now, // Automatically set when admin is created
          },
        }, {
          timestamps: true, // Automatically adds createdAt and updatedAt fields
        });
        
        // Pre-save middleware to hash the password before saving
        adminSchema.pre('save', async function (next) {
          if (!this.isModified('password')) return next();
        
          try {
            const salt = await bcrypt.genSalt(10);
            this.password = await bcrypt.hash(this.password, salt);
            next();
          } catch (error) {
            next(error);
          }
        });
        
        // Method for comparing passwords during login/authentication
        adminSchema.methods.comparePassword = async function (candidatePassword) {
          return bcrypt.compare(candidatePassword, this.password);
        };
        
        // Virtual property to get admin's full name
        adminSchema.virtual('fullName').get(function () {
          return `${this.firstName} ${this.lastName}`;
        });
        
        // Indexing important fields for performance
        adminSchema.index({ email: 1 });
        adminSchema.index({ phoneNumber: 1 });
        adminSchema.index({ role: 1 });
        adminSchema.index({ username: 1 });  // Index the username for performance
        
        // Compile the schema into a model
        const Admin = mongoose.model('Admin', adminSchema);
        
        export default Admin;
      |-Property.js
        import mongoose from 'mongoose';
        
        // Create the schema for the Property model
        const propertySchema = new mongoose.Schema({
          title: {
            type: String,
            required: [true, 'Property title is required.'],
            maxlength: [100, 'Title cannot exceed 100 characters.']
          },
          description: {
            type: String,
            required: [true, 'Description is required.'],
            maxlength: [500, 'Description cannot exceed 500 characters.']
          },
          propertyType: {
            type: String,
            enum: ['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'],
            required: [true, 'Property type is required.']
          },
          price: {
            type: Number,
            required: [true, 'Price is required.'],
            min: [0, 'Price must be a positive number.'],
            validate: {
              validator: function (value) {
                return Number.isInteger(value); // Ensure price is an integer
              },
              message: 'Price must be a whole number (integer).'
            }
          },
          status: {
            type: String,
            enum: ['Available', 'Sold', 'Rented', 'Pending'],
            default: 'Available'
          },
          size: {
            type: Number, // Size in square feet/meters
            required: [true, 'Property size is required.'],
            min: [0, 'Size must be a positive number.'],
          },
          bedrooms: {
            type: Number,
            required: [true, 'Number of bedrooms is required.'],
            min: [1, 'Bedrooms must be at least 1.']
          },
          bathrooms: {
            type: Number,
            required: [true, 'Number of bathrooms is required.'],
            min: [1, 'Bathrooms must be at least 1.']
          },
          rooms: {
            type: Number,
            required: [true, 'Number of rooms is required.'],
            min: [1, 'Rooms must be at least 1.']
          },
          offerType: {
            type: String,
            enum: ['Sale', 'Rent'], // Offer type must be either for Sale or Rent
            required: [true, 'Offer type is required.']
          },
          wifi: {
            type: Boolean,
            default: false, // Boolean to indicate if Wi-Fi is available
          },
          petFriendly: {
            type: Boolean,
            default: false, // Boolean to indicate if the property is pet-friendly
          },
          parking: {
            type: Boolean,
            default: false, // Boolean to indicate if parking is available
          },
          yearBuilt: {
            type: Number,
            min: [1800, 'Year built must be after 1800.'],
            max: [new Date().getFullYear(), 'Year built cannot be in the future.'],
          },
          availableFrom: {
            type: Date,
            required: [true, 'Available date is required.'],
            default: Date.now, // Set default availability to current date
          },
          address: {
            street: {
              type: String,
              required: [true, 'Street address is required.'],
              maxlength: [100, 'Street address cannot exceed 100 characters.']
            },
            city: {
              type: String,
              required: [true, 'City is required.']
            },
            state: {
              type: String,
              required: [true, 'State is required.']
            },
            zipCode: {
              type: String,
              required: [true, 'Zip code is required.'],
              match: [/^\d{5}(-\d{4})?$/, 'Please provide a valid zip code.']
            },
            country: {
              type: String,
              required: [true, 'Country is required.'],
              default: 'USA'
            }
          },
          images: [
            {
              type: String,
              validate: {
                validator: function (value) {
                  return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value); // Validate URLs for images
                },
                message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).'
              }
            }
          ],
          amenities: {
            type: [String],
            default: [],
            validate: {
              validator: function (amenitiesArray) {
                return amenitiesArray.every(amenity => typeof amenity === 'string');
              },
              message: 'All amenities must be valid strings.'
            }
          },
          agentId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User', // Reference to the User (agent/owner) model
            required: [true, 'An agent is required to manage this property.']
          },
          isFeatured: {
            type: Boolean,
            default: false, // Boolean to mark properties as featured listings
          },
          coordinates: {
            lat: {
              type: Number,
              required: [true, 'Latitude is required.'],
              min: [-90, 'Latitude must be between -90 and 90 degrees.'],
              max: [90, 'Latitude must be between -90 and 90 degrees.']
            },
            lng: {
              type: Number,
              required: [true, 'Longitude is required.'],
              min: [-180, 'Longitude must be between -180 and 180 degrees.'],
              max: [180, 'Longitude must be between -180 and 180 degrees.']
            }
          },
          createdAt: {
            type: Date,
            default: Date.now
          },
          updatedAt: {
            type: Date,
            default: Date.now
          }
        }, {
          timestamps: true // Automatically add createdAt and updatedAt fields
        });
        
        // Pre-save middleware to update `updatedAt` before saving
        propertySchema.pre('save', function (next) {
          this.updatedAt = Date.now();
          next();
        });
        
        // Virtual property for displaying full address
        propertySchema.virtual('fullAddress').get(function () {
          return `${this.address.street}, ${this.address.city}, ${this.address.state}, ${this.address.zipCode}, ${this.address.country}`;
        });
        
        // Indexing fields for faster queries (e.g., searching properties by price, status, or agent)
        propertySchema.index({ price: 1 });
        propertySchema.index({ status: 1 });
        propertySchema.index({ agentId: 1 });
        propertySchema.index({ offerType: 1 });
        
        const Property = mongoose.model('Property', propertySchema);
        
        export default Property;
      |-Agent.js
        /*
         * This file defines the schema for the Agent model in a property management application.
         * It includes fields for agent information, password management, and agent status, 
         * with validation and pre-save hooks for password hashing.
         */
        
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        /**
         * @desc Schema definition for the `Agent` model representing real estate agents in the system.
         */
        const agentSchema = new mongoose.Schema({
          firstName: {
            type: String,
            required: [true, 'First name is required.'],
            maxlength: [50, 'First name cannot exceed 50 characters.'],
          },
          lastName: {
            type: String,
            required: [true, 'Last name is required.'],
            maxlength: [50, 'Last name cannot exceed 50 characters.'],
          },
          username: {
            type: String,
            required: [true, 'Username is required.'],
            unique: true,
            minlength: [4, 'Username must be at least 4 characters long.'],
            maxlength: [30, 'Username cannot exceed 30 characters.'],
            match: [/^[a-zA-Z0-9_]+$/, 'Username can only contain alphanumeric characters and underscores.'],
          },
          email: {
            type: String,
            required: [true, 'Email is required.'],
            unique: true,
            match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email address.'],
          },
          phoneNumber: {
            type: String,
            required: [true, 'Phone number is required.'],
            match: [/^\+?[1-9]\d{1,14}$/, 'Please provide a valid phone number.'], // E.164 format
          },
          agency: {
            type: String,
            maxlength: [100, 'Agency name cannot exceed 100 characters.'],
            required: [true, 'Agency name is required.'],
          },
          bio: {
            type: String,
            maxlength: [1000, 'Bio cannot exceed 1000 characters.'],
            default: '', // Default empty bio
          },
          licenseNumber: {
            type: String,
            required: [true, 'License number is required.'],
            unique: true,
          },
          profileImage: {
            type: String,
            default: 'https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png', // Default avatar
            validate: {
              validator: function (value) {
                return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value); // Validate URLs for profile image
              },
              message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).',
            },
          },
          password: {
            type: String,
            required: true,
            minlength: [6, 'Minimum length is 6 characters'],
            validate: {
              validator: function (value) {
                // Password must include at least one uppercase letter, one lowercase letter, and one number
                return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
              },
              message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.',
            },
          },
          properties: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Property', // Reference to properties managed by the agent
          }],
           default: [], // Default empty array for properties
          role: {
            type: String,
            enum: ['agent'], // Only "agent" is allowed for this model
            default: 'agent', // Automatically assign "agent" role
          },
          rating: {
            type: Number,
            min: [0, 'Rating cannot be below 0.'],
            max: [5, 'Rating cannot exceed 5.'],
            default: 0,
          },
          reviewsCount: {
            type: Number,
            default: 0, // Track how many reviews have been given
          },
          socialMediaLinks: {
            facebook: {
              type: String,
              match: [/^https?:\/\/(www\.)?facebook.com\/.+$/, 'Please provide a valid Facebook URL.'],
            },
            linkedin: {
              type: String,
              match: [/^https?:\/\/(www\.)?linkedin.com\/.+$/, 'Please provide a valid LinkedIn URL.'],
            },
            twitter: {
              type: String,
              match: [/^https?:\/\/(www\.)?twitter.com\/.+$/, 'Please provide a valid Twitter URL.'],
            },
            default: {}, // Default empty object for social media links
          },
          availability: {
            type: Boolean,
            default: true, // Agents are available by default unless explicitly set to unavailable
          },
          agentStatus: {
            type: String,
            enum: ['pending', 'active', 'rejected'], // Agent registration status
            default: 'pending', // New agents start with 'pending' status until approved by an admin
          },
          joinedAt: {
            type: Date,
            default: Date.now,
          },
        }, {
          timestamps: true, // Automatically adds createdAt and updatedAt fields
        });
        
        // Pre-save middleware to hash the password before saving
        agentSchema.pre('save', async function (next) {
          if (!this.isModified('password')) return next();
        
          try {
            const salt = await bcrypt.genSalt(10);
            this.password = await bcrypt.hash(this.password, salt);
            next();
          } catch (error) {
            next(error);
          }
        });
        
        // Method for comparing passwords during login/authentication
        agentSchema.methods.comparePassword = async function (candidatePassword) {
          return bcrypt.compare(candidatePassword, this.password);
        };
        
        // Virtual property to get agent's full name
        agentSchema.virtual('fullName').get(function () {
          return `${this.firstName} ${this.lastName}`;
        });
        
        // Virtual property to get the count of properties
        agentSchema.virtual('propertiesCount').get(function () {
          return this.properties.length;
        });
        
        // Indexing important fields for performance
        agentSchema.index({ email: 1 });
        agentSchema.index({ licenseNumber: 1 });
        agentSchema.index({ phoneNumber: 1 });
        agentSchema.index({ agency: 1 });
        agentSchema.index({ rating: 1 });
        agentSchema.index({ role: 1 });
        agentSchema.index({ agentStatus: 1 });
        agentSchema.index({ username: 1 });
        
        const Agent = mongoose.model('Agent', agentSchema);
        
        export default Agent;
      |-Faq.js
        import mongoose from 'mongoose';
        
        const faqSchema = new mongoose.Schema({
          question: {
            type: String,
            required: [true, "Question is required"],
            trim: true
          },
          answer: {
            type: String,
            required: [true, "Answer is required"],
            trim: true
          },
          category: {
            type: String,    // Category of FAQ, e.g., 'Registration', 'Payments', 'Account'
            default: 'General',
            trim: true
          },
          isPublished: {
            type: Boolean,   // Whether the FAQ is published or not
            default: true
          },
          priority: {
            type: Number,    // Priority or order in which FAQs should appear
            default: 0
          },
          tags: {
            type: [String],  // Tags to allow better filtering or searching of FAQs
            default: []
          }
        }, { timestamps: true });
        
        const FAQ = mongoose.model('FAQ', faqSchema);
        
        export default FAQ;
      |-User.js
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        // Define possible roles in the system
        export const rolesEnum = ['user', 'admin', 'super-admin'];
        
        // Define possible statuses for the account
        export const accountStatusEnum = ['active', 'pending', 'suspended', 'deactivated'];
        
        // Create the schema of the database
        const userSchema = new mongoose.Schema({
            firstName: {
                type: String,
                required: true,
            },
            lastName: {
                type: String,
                required: true,
            },
            username: {
                type: String,
                required: true,
                unique: true, // Ensure username is unique
            },
            email: {
                type: String,
                required: [true, "Please enter an email"],
                unique: true,
                lowercase: true,
                match: [/\S+@\S+\.\S+/, 'Please enter a valid email'] // Email format validation
            },
            avatar: {
                type: String,
                default: "https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png"
            },
            password: {
                type: String,
                minlength: [6, 'Minimum length is 6 characters'],
                validate: {
                    validator: function(value) {
                        // Password must include at least one uppercase letter, one lowercase letter, and one number
                        return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
                    },
                    message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.'
                }
            },
            googleId: {
                type: String,
                required: false, // This will store Google user ID for OAuth users
            },
            role: {
                type: String,
                enum: ['user'],
                default: 'user', // Default role is 'user'
            },
            accountStatus: {
                type: String,
                enum: accountStatusEnum, // Possible account statuses
                default: 'active', // Default status is 'active'
            },
            isEmailVerified: {
                type: Boolean,  // Whether the user's email has been verified
                default: false, // Default is unverified, can be updated after email confirmation
            },
            lastLogin: {
                type: Date,  // Store the last login time
                default: null,
            },
            failedLoginAttempts: {
                type: Number,  // Track failed login attempts for security reasons
                default: 0,
            },
            lockUntil: {
                type: Date,  // Lock the account until a specific time if too many failed login attempts
                default: null,
            },
            isUsernameCustomized: {
                type: Boolean,   // Field to indicate if the username was customized by the user
                default: false,  // Default value is false (automatically generated username)
            }
        }, 
        { timestamps: true } // Save the date of creation/update
        );
        
        // Hash the password before saving it to the database
        userSchema.pre('save', async function(next) {
            if (!this.isModified('password')) return next();
        
            try {
                this.password = await bcrypt.hash(this.password, 10);
                next();
            } catch (error) {
                next(error);
            }
        });
        
        // Instance method for password comparison (used for local login if needed)
        userSchema.methods.comparePassword = async function(password) {
            return bcrypt.compare(password, this.password);
        };
        
        // Method to update the last login time
        userSchema.methods.updateLastLogin = async function() {
            this.lastLogin = new Date();
            await this.save();
        };
        
        // Method to handle failed login attempts and lockout mechanism
        userSchema.methods.incrementFailedLogins = async function() {
            const MAX_ATTEMPTS = 5;
            this.failedLoginAttempts += 1;
        
            if (this.failedLoginAttempts >= MAX_ATTEMPTS) {
                this.lockUntil = new Date(Date.now() + 30 * 60 * 1000); // Lock account for 30 minutes
            }
        
            await this.save();
        };
        
        // Method to reset failed login attempts after successful login
        userSchema.methods.resetFailedLogins = async function() {
            this.failedLoginAttempts = 0;
            this.lockUntil = null;
            await this.save();
        };
        
        // Static method for login (handles both OAuth and local login)
        userSchema.statics.login = async function(email, password) {
            const user = await this.findOne({ email });
            if (user) {
                // Check if account is locked
                if (user.lockUntil && user.lockUntil > Date.now()) {
                    throw new Error("Account is temporarily locked due to multiple failed login attempts.");
                }
        
                const isMatch = await bcrypt.compare(password, user.password);
                if (isMatch) {
                    // Reset failed login attempts on successful login
                    await user.resetFailedLogins();
                    return user;
                } else {
                    // Increment failed login attempts on unsuccessful login
                    await user.incrementFailedLogins();
                    throw new Error("Incorrect password");
                }
            }
            throw new Error("Incorrect email");
        };
        
        // Virtual field to get the full name of the user
        userSchema.virtual('fullName').get(function() {
            return `${this.firstName} ${this.lastName}`;
        });
        
        const User = mongoose.model("User", userSchema);
        
        export default User;
  |-.git/
    |-refs/
      |-tags/
      |-heads/
      |-remotes/
        |-origin/
    |-hooks/
    |-branches/
    |-objects/
      |-79/
      |-2e/
      |-05/
      |-6b/
      |-b2/
      |-26/
      |-af/
      |-29/
      |-e3/
      |-4b/
      |-f6/
      |-9a/
      |-0b/
      |-c9/
      |-e9/
      |-f0/
      |-3c/
      |-a0/
      |-d3/
      |-e8/
      |-f4/
      |-dd/
      |-e7/
      |-98/
      |-pack/
      |-95/
      |-f5/
      |-a2/
      |-c6/
      |-b0/
      |-74/
      |-ce/
      |-cf/
      |-de/
      |-63/
      |-32/
      |-c2/
      |-bb/
      |-8b/
      |-ac/
      |-d9/
      |-da/
      |-87/
      |-ab/
      |-2f/
      |-c3/
      |-db/
      |-99/
      |-91/
      |-57/
      |-f9/
      |-1b/
      |-ed/
      |-39/
      |-65/
      |-10/
      |-58/
      |-e0/
      |-7e/
      |-48/
      |-19/
      |-22/
      |-7c/
      |-ad/
      |-7b/
      |-0d/
      |-77/
      |-2a/
      |-50/
      |-dc/
      |-40/
      |-09/
      |-88/
      |-5e/
      |-6f/
      |-ba/
      |-d5/
      |-4c/
      |-38/
      |-2b/
      |-8d/
      |-b6/
      |-54/
      |-15/
      |-04/
      |-0f/
      |-9f/
      |-82/
      |-20/
      |-b9/
      |-0e/
      |-ca/
      |-1c/
      |-f8/
      |-72/
      |-b7/
      |-78/
      |-9d/
      |-4d/
      |-86/
      |-14/
      |-75/
      |-61/
      |-d6/
      |-a8/
      |-33/
      |-a6/
      |-1d/
      |-11/
      |-b8/
      |-60/
      |-59/
      |-07/
      |-84/
      |-35/
      |-8c/
      |-4a/
      |-f1/
      |-c7/
      |-b3/
      |-46/
      |-43/
      |-62/
      |-73/
      |-e6/
      |-92/
      |-fe/
      |-b4/
      |-90/
      |-13/
      |-24/
      |-70/
      |-cd/
      |-69/
      |-6e/
      |-eb/
      |-08/
      |-5d/
      |-aa/
      |-3a/
      |-3e/
      |-3b/
      |-97/
      |-7d/
      |-b1/
      |-47/
      |-cb/
      |-c8/
      |-5a/
      |-ff/
      |-be/
      |-d4/
      |-96/
      |-66/
      |-a1/
      |-45/
      |-02/
      |-cc/
      |-0a/
      |-4f/
      |-e1/
      |-a5/
      |-6a/
      |-1a/
      |-18/
      |-30/
      |-36/
      |-4e/
      |-16/
      |-info/
    |-logs/
      |-refs/
        |-heads/
        |-remotes/
          |-origin/
    |-info/
