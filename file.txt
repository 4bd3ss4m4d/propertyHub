|-./
  |-client/
    |-vite.config.js
      import { defineConfig } from 'vite';
      import react from '@vitejs/plugin-react-swc';
      
      export default defineConfig({
        plugins: [react()],
        server: {
          proxy: {
            '/api': {
              target: process.env.VITE_API_URL || 'http://localhost:5000', // Use the environment variable
              changeOrigin: true,
              secure: false,
            },
          },
        },
      });
    |-eslint.config.js
      import js from '@eslint/js'
      import globals from 'globals'
      import react from 'eslint-plugin-react'
      import reactHooks from 'eslint-plugin-react-hooks'
      import reactRefresh from 'eslint-plugin-react-refresh'
      
      export default [
        { ignores: ['dist'] },
        {
          files: ['**/*.{js,jsx}'],
          languageOptions: {
            ecmaVersion: 2020,
            globals: globals.browser,
            parserOptions: {
              ecmaVersion: 'latest',
              ecmaFeatures: { jsx: true },
              sourceType: 'module',
            },
          },
          settings: { react: { version: '18.3' } },
          plugins: {
            react,
            'react-hooks': reactHooks,
            'react-refresh': reactRefresh,
          },
          rules: {
            ...js.configs.recommended.rules,
            ...react.configs.recommended.rules,
            ...react.configs['jsx-runtime'].rules,
            ...reactHooks.configs.recommended.rules,
            'react/jsx-no-target-blank': 'off',
            'react-refresh/only-export-components': [
              'warn',
              { allowConstantExport: true },
            ],
          },
        },
      ]
    |-src/
      |-main.jsx
        import React from 'react';
        import { createRoot } from 'react-dom/client';
        import App from './App';
        import { store } from './redux/store';
        import { Provider } from 'react-redux';
        import { loadUserFromStorage } from './redux/userSlice'; // Correct import
        
        const root = createRoot(document.getElementById('root'));
        
        // Load user from localStorage on app start
        store.dispatch(loadUserFromStorage());
        
        root.render(
          <React.StrictMode>
            <Provider store={store}>
              <App />
            </Provider>
          </React.StrictMode>
        );
      |-App.jsx
        import React from "react";
        import { Routes, Route, BrowserRouter } from "react-router-dom";
        import "./App.css";
        import Home from "./pages/Home";
        import FAQ from "./pages/FAQ";
        import SignUp from "./pages/SignUp";
        import SignIn from "./pages/SignIn";
        import { AuthSuccess, AuthFailure } from "./pages/AuthStatus";
        import Profile from "./pages/Profile";
        import Create from "./pages/Create";
        
        function App() {
          return (
            <BrowserRouter>
            <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/faq" element={<FAQ />} />
              <Route path="/signup" element={<SignUp />} />
              <Route path="/signup/success" element={<AuthSuccess type="SignUp" />} /> 
              <Route path="/signup/failure" element={<AuthFailure type="SignUp" />} /> 
              <Route path="/signin" element={<SignIn />} />
              <Route path="/signin/success" element={<AuthSuccess type="SignIn" />} /> 
              <Route path="/signin/failure" element={<AuthFailure type="SignIn" />} /> 
              <Route path="/profile" element={<Profile/>} /> 
              <Route path="/create" element={<Create/>} /> 
        
            </Routes>
            </BrowserRouter>
          );
        }
        
        export default App;
        
      |-components/
        |-FormInput.jsx
          import React from 'react';
          import '../assets/styles/formInput.css';
          
          const FormInput = ({ type, placeholder, value, onChange, className }) => {
            return (
              <input
                type={type}
                placeholder={placeholder}
                required
                className={className}
                value={value}
                onChange={onChange}
              />
            );
          };
          
          export default FormInput;
          
        |-SignUpFormLocal.jsx
          import React, { useState } from 'react';
          import InputField from './InputField';
          import FormInput from './FormInput';
          import { registerUser, checkEmailAvailability, checkUsernameAvailability } from '../services/authServices';
          import { validateField } from '../services/validationHelper';
          import { useNavigate } from 'react-router-dom';
          import ErrorDisplay from './ErrorDisplay'; // Import the ErrorDisplay component
          import '../assets/styles/signupLocalForm.css';
          
          const SignUpForm = () => {
            const [firstName, setFirstName] = useState('');
            const [lastName, setLastName] = useState('');
            const [username, setUsername] = useState('');
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
          
            // Email state
            const [emailLoading, setEmailLoading] = useState(false);
            const [emailStatus, setEmailStatus] = useState(null); // 'valid', 'invalid', or 'error'
            const [emailError, setEmailError] = useState('');
          
            // Username state
            const [usernameLoading, setUsernameLoading] = useState(false);
            const [usernameStatus, setUsernameStatus] = useState(null); // 'valid', 'invalid', or 'error'
            const [usernameError, setUsernameError] = useState('');
          
            // Error and Success Messages
            const [errorMessages, setErrorMessages] = useState([]); // List of general error messages
            const [successMessage, setSuccessMessage] = useState(''); // Success message
            const [errors, setErrors] = useState([]); // Validation errors from the API
          
            const navigate = useNavigate();
          
            // Clear the error message on input change for username
            const handleUsernameChange = (e) => {
              setUsername(e.target.value);
              setUsernameError('');  // Clear error when user types
              setUsernameStatus(null); // Reset status when user types
            };
          
            // Clear the error message on input change for email
            const handleEmailChange = (e) => {
              setEmail(e.target.value);
              setEmailError('');  // Clear error when user types
              setEmailStatus(null); // Reset status when user types
            };
          
            // Handle validation for email on blur
            const handleEmailBlur = () =>
              validateField('email', email, setEmailLoading, setEmailStatus, setEmailError, checkEmailAvailability);
          
            // Handle validation for username on blur
            const handleUsernameBlur = () =>
              validateField('username', username, setUsernameLoading, setUsernameStatus, setUsernameError, checkUsernameAvailability);
          
            // Handle form submission
            const handleSignUp = async (e) => {
              e.preventDefault();
              console.log('Sign Up button clicked'); // Debug log
          
              // Check if the button is disabled
              if (loading || emailStatus === 'invalid' || usernameStatus === 'invalid' || !emailStatus || !usernameStatus) {
                console.log('Button is disabled, form submission prevented');
                return;
              }
          
              setLoading(true);
              setErrorMessages([]);  // Clear previous error messages
              setSuccessMessage(''); // Clear previous success message
          
              console.log('Attempting to register user with:', { firstName, lastName, username, email, password }); // Debug log
          
              try {
                console.log('Calling registerUser function'); // Debug log
                const response = await registerUser({ firstName, lastName, username, email, password });
                console.log('Received response:', response); // Debug log
                
                if (response.data.message === "User registered successfully!") {
                  // Redirect to the success page on successful registration
                  navigate('/signup/success'); // Redirect to AuthSuccess page
                } else {
                  setErrorMessages(["An unexpected error occurred. Please try again."]);
                }
              } catch (err) {
                console.error('Error during registration:', err); // Debug log
                if (err.response && err.response.data && err.response.data.error) {
                  const validationErrors = err.response.data.error.errors || [];
                  setErrors(validationErrors); // Set validation errors from the server response
                } else if (err.request) {
                  setErrorMessages(["No response received from server. Please try again."]);
                } else {
                  setErrorMessages([`Error: ${err.message}`]);
                }
              } finally {
                setLoading(false);
              }
            };
          
            return (
              <div className="register-container">
                <h1>Create an Account</h1>
          
                {/* Display success message */}
                {successMessage && <p className="success-message">{successMessage}</p>}
          
                {/* Display general error messages */}
                {errorMessages.length > 0 && (
                  <div className="error-messages">
                    {errorMessages.map((message, index) => (
                      <p key={index} className="error-message">{message}</p>
                    ))}
                  </div>
                )}
          
                <form onSubmit={handleSignUp}>
                  <div className="name-fields">
                    <FormInput
                      type="text"
                      placeholder="First Name*"
                      value={firstName}
                      onChange={(e) => setFirstName(e.target.value)}
                      className="input-firstname"
                    />
                    <FormInput
                      type="text"
                      placeholder="Last Name*"
                      value={lastName}
                      onChange={(e) => setLastName(e.target.value)}
                      className="input-lastname"
                    />
                  </div>
          
                  {/* Username Input Field with validation */}
                  <InputField
                    type="text"
                    placeholder="Username*"
                    value={username}
                    onChange={handleUsernameChange}  // Handle username change to clear errors
                    onBlur={handleUsernameBlur}      // Trigger validation on blur
                    status={usernameStatus}          // 'valid' or 'invalid'
                    loading={usernameLoading}        // Show loading icon while checking
                  />
                  {/* Error message when username is invalid */}
                  {!usernameLoading && usernameStatus === 'invalid' && (
                    <p className="error-message">{usernameError}</p>  // Show only if username is invalid
                  )}
          
                  {/* Email Input Field with validation */}
                  <InputField
                    type="email"
                    placeholder="Email Address*"
                    value={email}
                    onChange={handleEmailChange}     // Handle email change to clear errors
                    onBlur={handleEmailBlur}         // Trigger validation on blur
                    status={emailStatus}             // 'valid' or 'invalid'
                    loading={emailLoading}           // Show loading icon while checking
                  />
                  {/* Error message when email is invalid */}
                  {!emailLoading && emailStatus === 'invalid' && (
                    <p className="error-message">{emailError}</p>  // Show only if email is invalid
                  )}
          
                  {/* Password Input */}
                  <FormInput
                    type="password"
                    placeholder="Password*"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="input-password"
                  />
          
                  {/* Display validation errors */}
                  <ErrorDisplay errors={errors} />
          
                  {/* Submit Button */}
                  <button
                    type="submit"
                    className="continue-button"
                    disabled={loading || emailStatus === 'invalid' || usernameStatus === 'invalid' || !emailStatus || !usernameStatus}
                  >
                    {loading ? 'Signing up...' : 'Sign Up'}
                  </button>
                </form>
              </div>
            );
          };
          
          export default SignUpForm;
          
        |-Footer.jsx
          import React, { useState } from "react";
          import "../assets/styles/footer.css";
          import { Link } from "react-router-dom";
          
          export default function Footer() {
              const [email, setEmail] = useState("");
          
              const handleEmail = (e)=> { 
                      setEmail(e.target.value)
              }
          
          
              const handleSubmit = (e)=>{
                  e.preventDefault();
                  console.log(email)
          
              }
            return (
              <footer className="footer">
                <div className="footer-content">
                  <div className="footer-about">
                    <h2>PropertyHub</h2>
                    <p>
                      Your trusted partner in real estate. Helping you find your dream
                      home or sell your property with ease.
                    </p>
                    <div className="social-media">
                      <a
                        href="https://facebook.com/PropertyHub"
                        aria-label="Facebook"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M22.675 0h-21.35c-.733 0-1.325.592-1.325 1.325v21.351c0 .732.592 1.324 1.325 1.324h11.494v-9.294h-3.124v-3.622h3.124v-2.671c0-3.1 1.894-4.787 4.659-4.787 1.325 0 2.462.099 2.793.143v3.24l-1.917.001c-1.504 0-1.795.715-1.795 1.764v2.31h3.587l-.467 3.622h-3.12v9.294h6.116c.732 0 1.324-.592 1.324-1.324v-21.35c0-.733-.592-1.325-1.325-1.325z" />
                        </svg>
                      </a>
                      <a
                        href="https://twitter.com/PropertyHub"
                        aria-label="Twitter"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M24 4.557c-.883.392-1.83.656-2.825.775 1.014-.608 1.794-1.57 2.163-2.723-.949.564-2.003.974-3.127 1.195-.896-.954-2.173-1.55-3.591-1.55-2.717 0-4.917 2.201-4.917 4.917 0 .386.043.762.127 1.124-4.083-.205-7.702-2.159-10.125-5.134-.423.724-.666 1.561-.666 2.457 0 1.694.863 3.188 2.175 4.065-.801-.025-1.555-.245-2.212-.612v.061c0 2.367 1.683 4.342 3.918 4.789-.41.111-.841.171-1.287.171-.314 0-.621-.031-.921-.087.623 1.947 2.432 3.362 4.576 3.402-1.675 1.313-3.785 2.096-6.076 2.096-.395 0-.786-.023-1.17-.068 2.165 1.389 4.736 2.2 7.504 2.2 9.005 0 13.92-7.461 13.92-13.92 0-.212-.005-.425-.014-.637.954-.688 1.786-1.548 2.443-2.532z" />
                        </svg>
                      </a>
                      <a
                        href="https://instagram.com/PropertyHub"
                        aria-label="Instagram"
                        className="social-link"
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          fill="#ecf0f1"
                          viewBox="0 0 24 24"
                        >
                          <path d="M12 2.163c3.204 0 3.584.012 4.849.07 1.366.062 2.633.333 3.608 1.308.975.975 1.246 2.242 1.308 3.608.058 1.265.069 1.645.069 4.849s-.012 3.584-.07 4.849c-.062 1.366-.333 2.633-1.308 3.608-.975.975-2.242 1.246-3.608 1.308-1.265.058-1.645.069-4.849.069s-3.584-.012-4.849-.07c-1.366-.062-2.633-.333-3.608-1.308-.975-.975-1.246-2.242-1.308-3.608-.058-1.265-.069-1.645-.069-4.849s.012-3.584.07-4.849c.062-1.366.333-2.633 1.308-3.608.975-.975 2.242-1.246 3.608-1.308 1.265-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-1.702.076-3.23.487-4.388 1.646-1.158 1.158-1.569 2.686-1.646 4.388-.058 1.28-.072 1.688-.072 4.947s.014 3.667.072 4.947c.076 1.702.487 3.23 1.646 4.388 1.158 1.158 2.686 1.569 4.388 1.646 1.28.058 1.688.072 4.947.072s3.667-.014 4.947-.072c1.702-.076 3.23-.487 4.388-1.646 1.158-1.158 1.569-2.686 1.646-4.388.058-1.28.072-1.688.072-4.947s-.014-3.667-.072-4.947c-.076-1.702-.487-3.23-1.646-4.388-1.158-1.158-2.686-1.569-4.388-1.646-1.28-.058-1.688-.072-4.947-.072z" />
                          <path d="M12 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.162 6.162 6.162 6.162-2.759 6.162-6.162-2.759-6.162-6.162-6.162zm0 10.162c-2.206 0-4-1.794-4-4s1.794-4 4-4 4 1.794 4 4-1.794 4-4 4zm6.406-11.845c-.796 0-1.443.647-1.443 1.443s.647 1.443 1.443 1.443 1.443-.647 1.443-1.443-.647-1.443-1.443-1.443z" />
                        </svg>
                      </a>
                    </div>
                  </div>
          
                  <div className="footer-links">
                    <h3>Quick Links</h3>
                    <ul>
                      <li>
                        <Link to="/">Home</Link>
                      </li>
                      <li>
                        <Link to="/profile">Profile</Link>
                      </li>
                    </ul>
                  </div>
          
                  <div className="footer-newsletter">
                    <h3>Subscribe to our Newsletter</h3>
                    <form>
                      <input type="email" placeholder="Enter your email" onChange={handleEmail}/>
                      <button type="submit" onClick={handleSubmit}>Subscribe</button>
                    </form>
                  </div>
                </div>
          
                <div className="footer-bottom">
                  <p>&copy; {new Date().getFullYear()} PropertyHub. All rights reserved.</p>
                </div>
              </footer>
            );
          }
        |-card.jsx
          import React from "react";
          import '../assets/styles/card.css'
          
          export default function Card(){
              return(
                  <div className="cardsContainer">
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
                      <div className="card">
                          <div className="setImage"></div>
                          <div className="information">
                              <h3>625 S. Berendo St</h3>
                              <p>625 S. Berendo St Unit 607 Los Angeles, CA 90005</p>
                              <h2>$2,265,500</h2>
                          </div>
                      </div>
          
                  </div>
              )
          };
        |-TextFieldsAndCheckbox.jsx
          import React from "react";
          
          export default function TextFieldsAndCheckbox({ data, handleChange }) {
            return (
              <>
                {/* Title */}
                <input
                  type="text"
                  placeholder="Title"
                  name="title"
                  value={data.title}
                  onChange={handleChange}
                  required
                />
          
                {/* Description */}
                <input
                  type="text"
                  placeholder="Description"
                  name="description"
                  value={data.description}
                  onChange={handleChange}
                  required
                />
          
                {/* Address Fields */}
                <input
                  type="text"
                  placeholder="Street Address"
                  name="address.street"
                  value={data.address.street}
                  onChange={handleChange}
                  required
                />
                <input
                  type="text"
                  placeholder="City"
                  name="address.city"
                  value={data.address.city}
                  onChange={handleChange}
                  required
                />
                <input
                  type="text"
                  placeholder="State"
                  name="address.state"
                  value={data.address.state}
                  onChange={handleChange}
                  required
                />
                <input
                  type="text"
                  placeholder="Zip Code"
                  name="address.zipCode"
                  value={data.address.zipCode}
                  onChange={handleChange}
                  required
                />
          
                {/* Phone Number */}
                <input
                  type="text"
                  placeholder="Phone"
                  name="phone"
                  value={data.phone}
                  onChange={handleChange}
                  required
                />
          
                {/* Property Type */}
                <p>Property Type</p>
                <select
                  name="propertyType"
                  value={data.propertyType}
                  onChange={handleChange}
                  className="propertyType"
                  required
                >
                  <option value="">Select Property Type</option>
                  <option value="Apartment">Apartment</option>
                  <option value="House">House</option>
                  <option value="Condo">Condo</option>
                  <option value="Land">Land</option>
                  <option value="Villa">Villa</option>
                  <option value="Office">Office</option>
                  <option value="Studio">Studio</option>
                </select>
          
                {/* Size */}
                <label htmlFor="size">Size (sq. ft / m²)</label>
                <input
                  type="number"
                  name="size"
                  value={data.size}
                  onChange={handleChange}
                  required
                />
          
                {/* Year Built */}
                <label htmlFor="yearBuilt">Year Built</label>
                <input
                  type="number"
                  name="yearBuilt"
                  min="1800"
                  max={new Date().getFullYear()}
                  value={data.yearBuilt}
                  onChange={handleChange}
                  required
                />
          
                {/* Rooms */}
                <label htmlFor="rooms">Rooms</label>
                <input
                  type="number"
                  name="rooms"
                  min="1"
                  value={data.rooms}
                  onChange={handleChange}
                  required
                />
          
                {/* Bathrooms */}
                <label htmlFor="bathrooms">Bathrooms</label>
                <input
                  type="number"
                  name="bathrooms"
                  min="1"
                  value={data.bathrooms}
                  onChange={handleChange}
                  required
                />
          
                {/* Bedrooms */}
                <label htmlFor="bedrooms">Bedrooms</label>
                <input
                  type="number"
                  name="bedrooms"
                  min="1"
                  value={data.bedrooms}
                  onChange={handleChange}
                  required
                />
          
                {/* Offer Type: Rent or Sell as a Dropdown */}
                <h3>This is for?</h3>
                <select
                  name="offerType"
                  value={data.offerType}
                  onChange={handleChange}
                  className="offer-type"
                  required
                >
                  <option value="">Select Offer Type</option>
                  <option value="Rent">Rent</option>
                  <option value="Sale">Sale</option>
                </select>
          
                {/* Additional Features: Parking, Wi-Fi, Pet-Friendly */}
                <h3>Include :</h3>
                <div className="check">
                  <label htmlFor="parking" className="cheking">
                    Parking
                    <input
                      type="checkbox"
                      name="parking"
                      id="parking"
                      className="checkbox"
                      checked={data.parking}
                      onChange={handleChange}
                    />
                  </label>
          
                  <label htmlFor="wifi" className="cheking">
                    Wi-Fi
                    <input
                      type="checkbox"
                      name="wifi"
                      id="wifi"
                      className="checkbox"
                      checked={data.wifi}
                      onChange={handleChange}
                    />
                  </label>
          
                  <label htmlFor="petFriendly" className="cheking">
                    Pet-friendly
                    <input
                      type="checkbox"
                      name="petFriendly"
                      id="petFriendly"
                      className="checkbox"
                      checked={data.petFriendly}
                      onChange={handleChange}
                    />
                  </label>
                </div>
          
                {/* Price */}
                <label htmlFor="price">Price</label>
                <div className="price">
                  <input
                    type="number"
                    name="price"
                    min="0"
                    id="price"
                    value={data.price}
                    onChange={handleChange}
                    required
                  />
                  <p>{data.offerType === "Rent" ? "$ / month" : "$"}</p>
                </div>
              </>
            );
          }
        |-ImageUpload.jsx
          import React from "react";
          
          export default function ImageUpload({ handleFileChange, createImagePreviews }) {
            return (
              <>
                <label htmlFor="images">Upload Images</label>
                <input
                  type="file"
                  name="images"
                  id="images"
                  accept="image/*"
                  multiple
                  onChange={handleFileChange}
                />
          
                <div className="image-previews">{createImagePreviews()}</div>
              </>
            );
          }
        |-search.jsx
          import React, { useState } from "react";
          import axios from "axios";
          import "../assets/styles/search.css";
          
          export default function Search() {
            const [filters, setFilters] = useState({
              offerType: "",
              location: "",
              bathrooms: "",
              rooms: "",
              wifi: false,
              petFriendly: false,
              parking: false,
              priceMax: "",
              more: false,
            });
          
            const handleInputChange = (e) => {
              const { name, value, type, checked } = e.target;
              setFilters({
                ...filters,
                [name]: type === "checkbox" ? checked : value,
              });
            };
          
            // Function to construct query string based on selected filters
            const createQueryString = (params) => {
              return Object.entries(params)
                .filter(([key, value]) => value !== "" && value !== false) // Filter out empty values
                .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
                .join("&");
            };
          
            const handleSubmit = (e) => {
              e.preventDefault();
          
              // Create query string based on the filters object
              const queryString = createQueryString(filters);
              console.log(queryString)
          
              //sending query to the backend
            };
          
            return (
              <form className="serchContainer" onSubmit={handleSubmit}>
                <div className="OfferAndLocation">
                  <div className="offer-type">
                    <p>Offer Type</p>
                    <select
                      name="offerType"
                      className="select"
                      value={filters.offerType}
                      onChange={handleInputChange}
                    >
                      <option value="" disabled hidden>
                        Select Offer Type
                      </option>
                      <option value="rent">Rent</option>
                      <option value="sale">Sale</option>
                    </select>
                  </div>
          
                  <div className="location">
                    <p>Location</p>
                    <input
                      type="text"
                      name="location"
                      placeholder="City/Location name"
                      value={filters.location}
                      onChange={handleInputChange}
                    />
                  </div>
                </div>
          
                {filters.more && (
                  <div className="filters show">
                    <div className="filter-group">
                      <label htmlFor="bathrooms">Bathrooms</label>
                      <input
                        type="number"
                        name="bathrooms"
                        min="1"
                        placeholder="e.g., 2"
                        value={filters.bathrooms}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <label htmlFor="rooms">Rooms</label>
                      <input
                        type="number"
                        name="rooms"
                        min="1"
                        placeholder="e.g., 3"
                        value={filters.rooms}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <label htmlFor="priceMax">Price Maximum</label>
                      <input
                        type="number"
                        name="priceMax"
                        min="0"
                        placeholder="e.g., 1000"
                        value={filters.priceMax}
                        onChange={handleInputChange}
                      />
                    </div>
          
                    <div className="filter-group">
                      <div className="checkbox-container">
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="wifi"
                            id="wifi"
                            checked={filters.wifi}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="wifi">WiFi</label>
                        </div>
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="petFriendly"
                            id="petFriendly"
                            checked={filters.petFriendly}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="petFriendly">Pet Friendly</label>
                        </div>
                        <div className="checkbox-item">
                          <input
                            type="checkbox"
                            name="parking"
                            id="parking"
                            checked={filters.parking}
                            onChange={handleInputChange}
                          />
                          <label htmlFor="parking">Parking</label>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
          
                <div className="actions">
                  <button type="submit" className="button search-button">
                    Search
                  </button>
                  <button
                    type="button"
                    className="button filter-button"
                    onClick={() => setFilters({ ...filters, more: !filters.more })}
                  >
                    {filters.more ? "Hide Filters" : "More Filters"}
                  </button>
                </div>
              </form>
            );
          }
        |-InputField.jsx
          import React from 'react';
          import { FaCheck, FaTimes } from 'react-icons/fa';
          import '../assets/styles/inputField.css';
          
          const InputField = ({ type, placeholder, value, onChange, onBlur, status, loading }) => {
            return (
              <div className="input-wrapper">
                <input
                  type={type}
                  placeholder={placeholder}
                  value={value}
                  onChange={onChange}
                  onBlur={onBlur}
                  className={`input-field ${status ? status : ''}`}
                />
                <div className="icon-container">
                  {loading && <div className="loading-icon"></div>}
          
                  {/* Show icons only if value is not empty and loading is false */}
                  {!loading && value && status === 'valid' && <FaCheck className="valid-icon" />}  {/* Green check for valid */}
                  {!loading && value && status === 'invalid' && <FaTimes className="invalid-icon" />} {/* Red cross for invalid */}
                </div>
              </div>
            );
          };
          
          export default InputField;
          
        |-ErrorDisplay.jsx
          import React from 'react';
          
          const ErrorDisplay = ({ errors }) => {
            // Check if there are no errors or if errors is not an array
            if (!errors || !Array.isArray(errors) || errors.length === 0) {
              return null; // Don't render anything if there are no errors
            }
          
            // Group errors by field
            const groupedErrors = errors.reduce((acc, error) => {
              const field = error.field || 'general'; // Use 'general' if field is not specified
              if (!acc[field]) {
                acc[field] = [];
              }
              acc[field].push(error.message);
              return acc;
            }, {});
          
            return (
              <div className="error-display">
                {Object.entries(groupedErrors).map(([field, messages]) => (
                  <div key={field} className="error-category">
                    <h4>{field.charAt(0).toUpperCase() + field.slice(1)}:</h4>
                    <ul>
                      {messages.map((message, index) => (
                        <li key={index}>{message}</li>
                      ))}
                    </ul>
                  </div>
                ))}
              </div>
            );
          };
          
          export default ErrorDisplay;
          
        |-SignUpOAuth.jsx
          import React, { useState, useEffect } from 'react';
          import { useSearchParams } from 'react-router-dom';
          import '../assets/styles/signupOAuthForm.css';  // OAuth-specific styling
          
          const SignUpOAuth = () => {
            const [searchParams] = useSearchParams();
            const [errorMessage, setErrorMessage] = useState('');
          
            useEffect(() => {
              const message = searchParams.get('message');
              if (message) {
                setErrorMessage(message);
              }
            }, [searchParams]);
          
            const redirectToGoogleSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/google/signup`;
            };
          
            const redirectToMicrosoftSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/microsoft/signup`;
            };
          
            const redirectToAppleSignUp = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/apple/signup`;
            };
          
            return (
              <div className="register-container">
                <h1>Create an Account</h1>
                {errorMessage && <p className="error-message">{errorMessage}</p>}
                
                <div className="divider">
                  <hr /> <span>Sign up with</span> <hr />
                </div>
                
                <div className="social-login">
                  <button className="social-button google" onClick={redirectToGoogleSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg" alt="Google Logo" />
                    Continue with Google
                  </button>
          
                  <button className="social-button microsoft" onClick={redirectToMicrosoftSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/1024px-Microsoft_logo.svg.png" alt="Microsoft Logo" />
                    Continue with Microsoft
                  </button>
          
                  <button className="social-button apple" onClick={redirectToAppleSignUp}>
                    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg" alt="Apple Logo" />
                    Continue with Apple
                  </button>
                </div>
              </div>
            );
          };
          
          export default SignUpOAuth;
          
        |-navbar.jsx
          import React, { useState } from 'react';
          import { NavLink, useNavigate } from 'react-router-dom';
          import Flag from 'react-world-flags';
          import '../assets/styles/navbar.css';
          import { FaBars, FaTimes, FaUser, FaGlobe, FaQuestionCircle } from 'react-icons/fa';
          import { useSelector } from 'react-redux';
          import { SignOut } from '../services/authServices';
          
          export default function Navbar() {
            const { currentUser } = useSelector((state) => state.user);
            const [toggle, setToggle] = useState({
              isMobileMenuOpen: false,
              isProfileMenuOpen: false,
              isLanguageMenuOpen: false,
              isProfileOpen: false
            });
          
            const navigate = useNavigate();
          
            const handleToggle = (menu) => {
              setToggle((prevState) => ({
                isMobileMenuOpen: menu === 'mobile' ? !prevState.isMobileMenuOpen : false,
                isProfileMenuOpen: menu === 'profile' ? !prevState.isProfileMenuOpen : false,
                isLanguageMenuOpen: menu === 'language' ? !prevState.isLanguageMenuOpen : false,
                isProfileOpen: menu === 'profileLogged' ? !prevState.isProfileOpen : false,
              }));
            };
          
            return (
              <header className="navbar">
                {/* Hamburger & FAQ Icon */}
                <div className="hamburger-menu">
                  {toggle.isMobileMenuOpen ? (
                    <FaTimes onClick={() => handleToggle('mobile')} className="icon" />
                  ) : (
                    <>
                      <FaBars onClick={() => handleToggle('mobile')} className="icon" />
                      <FaQuestionCircle onClick={() => navigate('/faq')} className="icon faq-icon" /> {/* FAQ Icon */}
                    </>
                  )}
                </div>
          
                {/* Center Logo */}
                <div className="logo">
                  <NavLink to="/">
                    <img 
                      src="https://i.ibb.co/mv6JJbL/Property-Hub-Logo-White.png" 
                      alt="PropertyHub Logo" 
                      className="logo-img"
                    />
                  </NavLink>
                </div>
          
                {/* Right-side Icons */}
                <div className="right-icons">
                  {toggle.isLanguageMenuOpen ? (
                    <FaTimes onClick={() => handleToggle('language')} className="icon" />
                  ) : (
                    <FaGlobe onClick={() => handleToggle('language')} className="icon" />
                  )}
                  {currentUser ? (
                    <div className="name-text profile-icon" onClick={() => handleToggle('profileLogged')}>
                      {currentUser.username}
                    </div>
                  ) : (
                    <FaUser onClick={() => handleToggle('profile')} className="icon profile-icon" />
                  )}
                </div>
          
                {/* Mobile Menu - Buy, Rent, Sell, Agents */}
                {toggle.isMobileMenuOpen && (
                  <div className="mobile-menu">
                    <NavLink to="/buy" className="menu-link" onClick={() => handleToggle('mobile')}>Buy</NavLink>
                    <NavLink to="/rent" className="menu-link" onClick={() => handleToggle('mobile')}>Rent</NavLink>
                    <NavLink to="/sell" className="menu-link" onClick={() => handleToggle('mobile')}>Sell</NavLink>
                    <NavLink to="/agents" className="menu-link" onClick={() => handleToggle('mobile')}>Agents</NavLink>
                  </div>
                )}
          
                {/* Profile Menu - Sign In & Sign Up */}
                {toggle.isProfileMenuOpen && (
                  <div className="profile-menu">
                    <button onClick={() => navigate('/signin')} className="profile-button">Sign In</button>
                    <button onClick={() => navigate('/signup')} className="profile-button">Sign Up</button>
                  </div>
                )}
          
                {/* Logged-in Profile Menu */}
                {toggle.isProfileOpen && (
                  <div className="profile-menu">
                    <button onClick={() => navigate('/profile')} className="profile-button">Profile</button>
                    <button onClick={() => SignOut()} className="profile-button">Sign Out</button>
                  </div>
                )}
          
                {/* Language Menu */}
                {toggle.isLanguageMenuOpen && (
                  <div className="language-menu">
                    <div className="language-option">
                      <Flag code="US" className="flag-icon" /> <span>English</span>
                    </div>
                    <div className="language-option">
                      <Flag code="MA" className="flag-icon" /> <span>العربية</span>
                    </div>
                    <div className="language-option">
                      <Flag code="FR" className="flag-icon" /> <span>Français</span>
                    </div>
                    <div className="language-option">
                      <Flag code="ES" className="flag-icon" /> <span>Español</span>
                    </div>
                    <div className="language-option">
                      <Flag code="DE" className="flag-icon" /> <span>Deutsch</span>
                    </div>
                    <div className="language-option">
                      <Flag code="BR" className="flag-icon" /> <span>Português</span>
                    </div>
                  </div>
                )}
              </header>
            );
          }
      |-redux/
        |-store.js
          import { configureStore } from '@reduxjs/toolkit';
          import userReducer from './userSlice';
          
          export const store = configureStore({
            reducer: {
              user: userReducer,
            },
          });
        |-userSlice.js
          import { createSlice } from '@reduxjs/toolkit';
          import Cookies from 'js-cookie';
          import {jwtDecode }from 'jwt-decode'; // Ensure jwt-decode is imported
          
          const USER_STORAGE_KEY = 'propertyHubUser';
          
          // Initial state
          const initialState = {
            currentUser: null,
          };
          
          // Create user slice
          const userSlice = createSlice({
            name: 'user',
            initialState,
            reducers: {
              setUser: (state, action) => {
                state.currentUser = action.payload;
                // Save user to localStorage
                localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(action.payload));
              },
              clearUser: (state) => {
                state.currentUser = null;
                // Remove user from localStorage
                localStorage.removeItem(USER_STORAGE_KEY);
              },
            },
          });
          
          // Export actions
          export const { setUser, clearUser } = userSlice.actions;
          
          // Thunk to load user data from localStorage or cookies
          export const loadUserFromStorage = () => (dispatch) => {
            // Try to load user from localStorage
            const savedUser = localStorage.getItem(USER_STORAGE_KEY);
          
            if (savedUser) {
              try {
                const parsedUser = JSON.parse(savedUser); // Safely parse JSON
                dispatch(setUser(parsedUser)); // Set user in Redux
              } catch (error) {
                console.error('Error parsing user from localStorage:', error);
                localStorage.removeItem(USER_STORAGE_KEY); // Clear corrupted data
              }
            } else {
              // Fallback to loading user from cookies (if you want to)
              const token = Cookies.get('propertyHubAuthToken');
              if (token) {
                try {
                  const userData = jwtDecode(token); // Decode the token to get user data
                  
                  
                  dispatch(setUser(userData));
                } catch (error) {
                  console.error('Error decoding token:', error);
                }
              }
            }
          };
          
          // Export reducer
          export default userSlice.reducer;
      |-assets/
        |-styles/
      |-pages/
        |-FAQ.jsx
          import React, { useEffect, useState } from 'react';
          import axios from 'axios';
          import '../assets/styles/faq.css';
          import Navbar from '../components/navbar';
          import Footer from '../components/Footer';
          
          const FAQ = () => {
            const [faqs, setFaqs] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
          
            // Fetch FAQs from the API
            useEffect(() => {
              const fetchFaqs = async () => {
                try {
                  const response = await axios.get('/api/faqs');
                  setFaqs(response.data);
                  setLoading(false);
                } catch (err) {
                  setError(err.response?.data?.message || 'Failed to fetch FAQs');
                  setLoading(false);
                }
              };
          
              fetchFaqs();
            }, []);
          
            const toggleFaq = (id) => {
              setFaqs(faqs.map(faq => faq._id === id ? { ...faq, open: !faq.open } : faq));
            };
          
            return (
              <>
              <Navbar />
              <div className="faq-page">
                {/* FAQ Section */}
                <div className="faq-container">
                  <h2>Frequently Asked Questions</h2>
                  {loading && <p>Loading FAQs...</p>}
                  {error && <p>Error loading FAQs: {error}</p>}
          
                  {!loading && !error && faqs.length === 0 && <p>No FAQs available at the moment.</p>}
          
                  {!loading && !error && faqs.length > 0 && (
                    <div className="faq-list">
                      {faqs.map(faq => (
                        <div key={faq._id} className={`faq-item ${faq.open ? 'open' : ''}`}>
                          <div className="faq-question" onClick={() => toggleFaq(faq._id)}>
                            {faq.question}
                            <span className="faq-toggle">{faq.open ? '-' : '+'}</span>
                          </div>
                          {faq.open && (
                            <div className="faq-answer">
                              <p>{faq.answer}</p>
                              {faq.tags && faq.tags.length > 0 && (
                                <div className="faq-meta">
                                  {faq.tags.map(tag => (
                                    <span key={tag}>{tag}</span>
                                  ))}
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                
              </div>
              
              <Footer />
              </>
            );
          };
          
          export default FAQ;
        |-Create.jsx
          import React, { useState } from "react";
          import axios from "axios";
          import '../assets/styles/create.css';
          import Navbar from "../components/navbar";
          import { useSelector } from "react-redux";
          import TextFieldsAndCheckbox from "../components/TextFieldsAndCheckbox";
          import ImageUpload from "../components/ImageUpload";
          import Footer from "../components/Footer";
          import Cookies from 'js-cookie';
          
          export default function Create() {
            const API_URL = import.meta.env.VITE_API_URL;
            const { currentUser } = useSelector((state) => state.user); // Access the logged-in user
          
            const [images, setImages] = useState([]);
            const [data, setData] = useState({
              title: '',
              description: '',
              propertyType: '',
              price: '', // Will be converted to a number
              size: '',  // Will be converted to a number
              yearBuilt: '',
              bedrooms: '',
              bathrooms: '',
              rooms: '',
              offerType: '', // Either "Rent" or "Sale"
              wifi: false,
              petFriendly: false,
              parking: false,
              availableFrom: new Date().toISOString().slice(0, 10),
              address: {
                street: '',
                city: '',
                state: '',
                zipCode: '',
                country: 'Morocco', // Default to "Morocco" if not provided
              },
              images: [], // Placeholder for image URLs after upload
              phone: '',
              status: 'Available', // Default status
              amenities: [], // Placeholder for amenities
              isFeatured: false, // Track if the listing is featured
            });
          
            // Handle file input change for image upload
            const handleFileChange = (event) => {
              setImages([...event.target.files]);
            };
          
            // Handle form changes (both text fields and checkboxes)
            const handleChange = (e) => {
              const { name, type, value, checked } = e.target;
          
              if (name.includes('address.')) {
                const field = name.split('.')[1];
                setData((prev) => ({
                  ...prev,
                  address: { ...prev.address, [field]: value }
                }));
              } else if (name.includes('coordinates.')) {
                const field = name.split('.')[1];
                setData((prev) => ({
                  ...prev,
                  coordinates: { ...prev.coordinates, [field]: value }
                }));
              } else {
                setData((prev) => ({
                  ...prev,
                  [name]: type === 'checkbox' ? checked : value
                }));
              }
            };
          
           // Handle form submission to send listing data and upload images
          const handleSubmit = async (event) => {
            event.preventDefault();
          
            // Convert numeric values before submitting
            const formattedData = {
              ...data,
              price: Number(data.price), // Convert price to a number
              size: Number(data.size),   // Convert size to a number
              bedrooms: Number(data.bedrooms),
              bathrooms: Number(data.bathrooms),
              rooms: Number(data.rooms),
            };
          
            const formData = new FormData();
            const imageUrls = [];
          
            // Upload images to Cloudinary
            for (const image of images) {
              formData.append("file", image);
              formData.append("upload_preset", import.meta.env.VITE_CLOUDINARY_UPLOAD_PRESET);
          
              try {
                const response = await axios.post(
                  `https://api.cloudinary.com/v1_1/${import.meta.env.VITE_CLOUDINARY_CLOUD_NAME}/image/upload`,
                  formData
                );
                imageUrls.push(response.data.secure_url);
              } catch (error) {
                console.error("Error uploading image to Cloudinary:", error);
                alert("Error during uploading image");
                return;
              }
            }
          
            // Prepare the final data object with image URLs and ensure proper data types
            const updatedData = {
              ...formattedData, // Use the formatted data with correct types
              images: imageUrls, // Add uploaded image URLs
              offerType: data.offerType.charAt(0).toUpperCase() + data.offerType.slice(1), // Capitalize offerType
            };
          
            const token = Cookies.get('propertyHubAuthToken');
            console.log("Token:", token); // Log the token value
            console.log("All cookies:", Cookies.get());
          
            // Send the data to the backend with JWT token in headers
            try {
              await axios.post(`${API_URL}/api/properties`, updatedData, {
                headers: {
                  Authorization: `Bearer ${token}`, // Include the JWT token in the Authorization header
                },
              });
              console.log("Property listing created successfully", updatedData);
            } catch (error) {
              console.error("Error creating listing:", error);
            }
          };
          
          
            // Create image previews to display selected images
            const createImagePreviews = () => {
              return Array.from(images).map((file, index) => {
                const url = URL.createObjectURL(file);
                return (
                  <img
                    key={index}
                    src={url}
                    alt={`preview ${index}`}
                    className="image-preview" // Added class for image preview styling
                    style={{ width: "100px", height: "100px", objectFit: "cover", margin: "5px" }}
                  />
                );
              });
            };
          
            return (
              <>
                <Navbar />
          
                <div className="creating-container">
                  <h2>Create Property Listing</h2>
                  <form className="creating" onSubmit={handleSubmit}>
                    <TextFieldsAndCheckbox data={data} handleChange={handleChange} />
          
                    <ImageUpload handleFileChange={handleFileChange} createImagePreviews={createImagePreviews} />
                    <button type="submit" className="submit-btn">Create</button>
                  </form>
                </div>
          
                <Footer />
              </>
            );
          }
        |-SignIn.jsx
          import React, { useState } from 'react';
          import { useNavigate } from 'react-router-dom';
          import { useDispatch } from 'react-redux';
          import { loginUser } from '../services/authServices';  // Import the login function from authServices
          import Cookies from 'js-cookie';  // Import js-cookie
          import '../assets/styles/signin.css';
          import Navbar from '../components/navbar';
          
          const SignIn = () => {
            const dispatch = useDispatch();
          
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
            const navigate = useNavigate();
          
            // Handle Google OAuth login redirection
            const redirectToGoogleSignin = () => {
              window.location.href = `${import.meta.env.VITE_API_URL}/api/auth/google/signin`;
            };
          
            // Handle Email and Password Sign-In
            const handleEmailSignIn = async (e) => {
              e.preventDefault();
              setLoading(true);
          
              try {
                // Call loginUser function from authServices
                const response = await loginUser({ email, password }, dispatch);
          
                if (response.data.success) {
                  const token = response.data.token;  // Assuming the token is returned in the response
                  Cookies.set('propertyHubAuthToken', token, { expires: 7, path: '/' });  // Set the cookie with a 7-day expiry
                  
                  // Navigate to success page after login
                  navigate('/signin/success');
                }
              } catch (err) {
                const errorMessage = err.response?.data?.message || 'Something went wrong. Please try again.';
                navigate(`/signin/failure?message=${encodeURIComponent(errorMessage)}`);
              } finally {
                setLoading(false);
              }
            };
          
            return (
              <>
                <Navbar />
                <div className="login-container">
                  <h1>Welcome back</h1>
          
                  {/* Sign-in using email and password */}
                  <form onSubmit={handleEmailSignIn}>
                    <input
                      type="email"
                      placeholder="Email address*"
                      required
                      className="input-email"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                    />
                    <input
                      type="password"
                      placeholder="Password*"
                      required
                      className="input-password"  // New input for password
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                    />
                    <button type="submit" className="continue-button" disabled={loading}>
                      {loading ? 'Signing in...' : 'Continue'}
                    </button>
                  </form>
          
                  <p className="signup-link">
                    Don't have an account? <a href="/signup">Sign Up</a>
                  </p>
          
                  <div className="divider">
                    <hr /> <span>OR</span> <hr />
                  </div>
          
                  {/* Google OAuth sign-in */}
                  <div className="social-login">
                    <button className="social-button google" onClick={redirectToGoogleSignin}>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg" alt="Google Logo" />
                      Continue with Google
                    </button>
          
                    {/* Other social logins (disabled for now) */}
                    <button className="social-button microsoft" disabled>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/1024px-Microsoft_logo.svg.png" alt="Microsoft Logo" />
                      Continue with Microsoft Account
                    </button>
          
                    <button className="social-button apple" disabled>
                      <img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg" alt="Apple Logo" />
                      Continue with Apple
                    </button>
                  </div>
                </div>
              </>
            );
          };
          
          export default SignIn;
        |-Profile.jsx
          import React, { useState, useRef, useEffect } from "react";
          import { useSelector } from "react-redux";
          import '../assets/styles/profile.css';
          import {  useNavigate } from "react-router-dom";
          import Navbar from "../components/navbar";
          import axios from "axios";
          import { SignOut } from "../services/authServices";
          import Footer from "../components/Footer";
          
          
          export default function Profile() {
              const { currentUser } = useSelector((state) => state.user);
              const navigate = useNavigate();
          
              const [updateData, setUpdateData] = useState({
                  id: currentUser ? currentUser.id : '',
                  username: currentUser ? currentUser.username : '',
                  email: currentUser ? currentUser.email : '',
                  password: '', // Initially empty, filled when user enters a new password
              });
          
              const [toggle, setToggle] = useState(false); // Toggle for expanding profile section
              const [error, setError] = useState('');
              const [loading, setLoading] = useState(false);
          
              const imageUpdate = useRef(null);
          
              useEffect(() => {
                  if (!currentUser) {
                      navigate("/signin"); // Redirect to signin if currentUser is not set
                  }
              }, [currentUser, navigate]);
          
              const handleUpdate = (e) => {
                  const { name, value } = e.target;
                  setError('');
          
                  if (value.trim() === '') return; // Prevent empty updates
          
                  setUpdateData((prev) => ({
                      ...prev,
                      [name]: value,
                  }));
              };
          
              const handleSubmit = async () => {
                  if (!updateData.username || !updateData.email) {
                      setError('Username and Email are required fields.');
                      return;
                  }
          
                  if (updateData.password && updateData.password !== updateData.confirmPassword) {
                      setError('Passwords do not match.');
                      return;
                  }
          
                  try {
                      setError('');
                      setLoading(true);
          
                      const response = await axios.put('/api/update-profile', updateData);
                      console.log('Profile updated:', response.data);
          
                  } catch (error) {
                      setError('Failed to update profile. Please try again.');
                  } finally {
                      setLoading(false);
                  }
              };
          
              const navigateateToCreate = () => {
                  navigate('/create')
              }
          
              const handleToggle = () => {
                  setToggle(!toggle); // Toggle expand/collapse
              };
          
              const handleSignout = async () => {
                  try {
                    await SignOut();
                  } catch (error) {
                    console.error('Error during sign-out navigation:', error);
                  }
                };
          
              return (
                  <>
                      {currentUser && (
                          <>
                              <Navbar />
                              <div className="profile">
                                  <img
                                      src="https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png"
                                      alt="User Avatar"
                                      onClick={() => imageUpdate.current.click()}
                                  />
                                  <div className="setting">
                                      <input
                                          type="file"
                                          accept="image/*"
                                          name="avatar"
                                          style={{ display: 'none' }}
                                          ref={imageUpdate}
                                          onChange={handleUpdate}
                                      />
          
                                      {/* Profile button */}
                                      <button className="profile-toggle-btn" onClick={handleToggle}>
                                          Profile
                                      </button>
          
                                      {/* Show profile info if toggle is true */}
                                      {toggle && (
                                          <div className="profile-info">
                                              <h4>{error}</h4>
                                              <label htmlFor="username">Change Username</label>
                                              <input
                                                  type="text"
                                                  name="username"
                                                  value={updateData.username}
                                                  onChange={handleUpdate}
                                              />
          
                                              <label htmlFor="email">Change Email</label>
                                              <input
                                                  type="email"
                                                  name="email"
                                                  value={updateData.email}
                                                  onChange={handleUpdate}
                                              />
          
                                              <label htmlFor="password">Change Password</label>
                                              <input
                                                  type="password"
                                                  name="password"
                                                  placeholder="New Password"
                                                  onChange={handleUpdate}
                                              />
                                              <input
                                                  type="password"
                                                  name="confirmPassword"
                                                  placeholder="Confirm Password"
                                                  onChange={handleUpdate}
                                              />
          
                                              <button
                                                  className="upating-profile"
                                                  type="submit"
                                                  onClick={handleSubmit}
                                                  disabled={loading}>
                                                  {loading ? 'Updating...' : 'Update Profile'}
                                              </button>
                                          </div>
                                      )}
                                  </div>
          
                                  <button className="profile-toggle-btn" onClick={navigateateToCreate}>Create Listing</button>
                                  <button className="profile-toggle-btn">Show My Listing</button>
                                  <button className="profile-toggle-btn" onClick={handleSignout}>Sign Out</button>
                              </div>
                          </>
                      )}
          
                      <Footer />
                  </>
              );
          }
        |-AuthStatus.jsx
          import React, { useEffect } from 'react';
          import { useNavigate, useSearchParams } from 'react-router-dom';
          import { FaCheckCircle, FaExclamationTriangle } from 'react-icons/fa'; // Icons for success and failure
          import '../assets/styles/authStatus.css';  // Centralized CSS
          
          // Failure Component
          export const AuthFailure = ({ type = "SignUp" }) => {  // Default type is "SignUp" if not provided
            const [searchParams] = useSearchParams();
            const navigate = useNavigate();
          
            // Extract the error message from query params or use a default message
            const errorMessage = searchParams.get('message') || `Failed to ${type}. Please try again.`;
          
            useEffect(() => {
              // Redirect to the correct page after 3 seconds
              const timer = setTimeout(() => {
                navigate(`/${type.toLowerCase()}`); // Redirects to /signin or /signup
              }, 3000);
          
              // Clean up timer
              return () => clearTimeout(timer);
            }, [navigate, type]);
          
            return (
              <div className="error-container">
                <div className="error-icon">
                  <FaExclamationTriangle className="icon" /> {/* Failure icon */}
                </div>
                <h1 className="error-title">{`${type} Failed`}</h1>
                <p className="error-message">{errorMessage}</p>
                <p className="redirect-message">You will be redirected to the {type} page shortly...</p>
              </div>
            );
          };
          
          // Success Component
          export const AuthSuccess = ({ type = "SignUp" }) => {  // Default type is "SignUp" if not provided
            const navigate = useNavigate();
          
            useEffect(() => {
              // Redirect to the homepage after 2 seconds
              const timer = setTimeout(() => {
                navigate('/');
              }, 2000);
          
              // Clean up timer
              return () => clearTimeout(timer);
            }, [navigate]);
          
            return (
              <div className="success-container">
                <div className="success-icon">
                  <FaCheckCircle className="icon" /> {/* Success icon */}
                </div>
                <h1 className="success-title">{`${type} Successful!`}</h1>
                <p className="redirect-message">Redirecting to the homepage...</p>
              </div>
            );
          };
          
        |-Home.jsx
          import React from "react";
          import Navbar from "../components/navbar";
          import Search from "../components/search";
          import Card from "../components/card";
          
          
          
          export default function Home(){
             return( <>
              <Navbar />
              <Search />
              <Card /> 
             </>)
          }
        |-SignUp.jsx
          import React from 'react';
          import Navbar from '../components/navbar';
          import SignUpOAuth from '../components/SignUpOAuth';
          import SignUpForm from '../components/SignUpFormLocal';
          
          const SignUp = () => {
            return (
              <>
                <Navbar />
                <div className="signup-page-container">
                  
                  {/* Local Email/Password Sign-Up Section */}
                  <SignUpForm />
          
                  {/* Divider between Local and OAuth sign-up form */}
                  <div className="divider">
                    <hr />
                    <span>Or sign up with</span>
                    <hr />
                  </div>
          
                  {/* OAuth Sign-Up Section */}
                  <SignUpOAuth />
          
                </div>
              </>
            );
          };
          
          export default SignUp;
          
        |-Agents.jsx
      |-services/
        |-validationHelper.js
          export const validateField = async (field, value, setLoading, setStatus, setError, validationService) => {
            if (value) {
              setLoading(true);
              setStatus(null);
              setError('');
          
              try {
                const response = await validationService(value); // Call the validation service
                if (response.data.success) {
                  setStatus('valid'); // Change 'available' to 'valid'
                } else {
                  setStatus('invalid'); // Change 'taken' to 'invalid'
                  setError(response.data.error.message);
                }
              } catch (err) {
                if (err.response && err.response.status === 400) {
                  setStatus('invalid'); // Change 'taken' to 'invalid'
                  setError(`This ${field} is already registered.`);
                } else {
                  setStatus('error');
                  setError(`Error checking ${field} availability.`);
                }
              } finally {
                setLoading(false);
              }
            }
          };
          
        |-authServices.jsx
          import axios from 'axios';
          import { setUser } from '../redux/userSlice';
          import Cookies from 'js-cookie';
          
          
          
          const API_URL = import.meta.env.VITE_API_URL;
          const tokenName = import.meta.env.VITE_JWT_COOKIE_NAME;
          
          
          // Create an Axios instance with a base URL and default options
          const axiosInstance = axios.create({
            baseURL: API_URL,        // Base URL for all API requests
            withCredentials: true,   // Include credentials with every request (useful for authentication)
          });
          
          // Function to register a new user
          export const registerUser = async (userData, dispatch) => {
            console.log('registerUser called with:', userData);
            try {
              console.log('Sending request to:', `${API_URL}/api/auth/signup`); // Log API endpoint
              const response = await axiosInstance.post('/api/auth/signup', userData); // Use axiosInstance
              console.log('API response:', response.data.data);
          
              // Dispatch the action after successful registration
              dispatch(setUser(response));
          
              return response;
            } catch (error) {
              console.error('API error:', error);
              if (error.response) {
                console.error('Error response:', error.response.data);
                console.error('Error status:', error.response.status);
              } else if (error.request) {
                console.error('Error request:', error.request);
              } else {
                console.error('Error message:', error.message);
              }
              throw error; // Re-throw the error to be handled by the caller
            }
          };
          
          // Login function
          export const loginUser = async (userData, dispatch) => {
            try {
              const response = await axiosInstance.post('/api/auth/signin', userData, dispatch); // Use axiosInstance
              console.log('Login API response:', response);
          
              // Assuming your backend sends the token in response
              Cookies.set('propertyHubAuthToken', response.data.token); // Store token in cookies
              dispatch(setUser(response.data.data)); // Dispatch the action to update Redux and persist it
          
              return response;
            } catch (error) {
              console.error('Error during login:', error);
              throw error;
            }
          };
          
          // Function to validate email availability
          export const checkEmailAvailability = async (email) => {
            console.log('checkEmailAvailability called with email:', email);
            try {
              const response = await axiosInstance.get(`/api/auth/check-email/${email}`); // Use axiosInstance
              console.log('Email availability response:', response);
              return response;
            } catch (error) {
              console.error('Error in checkEmailAvailability:', error);
              throw error; // Re-throw the error to be handled by the caller
            }
          };
          
          // Function to validate username availability
          export const checkUsernameAvailability = async (username) => {
            console.log('checkUsernameAvailability called with username:', username);
            try {
              const response = await axiosInstance.get(`/api/auth/check-username/${username}`); // Use axiosInstance
              console.log('Username availability response:', response);
              return response;
            } catch (error) {
              console.error('Error in checkUsernameAvailability:', error);
              throw error;
            }
          };
          
          
          export const SignOut = async () => {
            try {
              // Send logout request to the server
              await axios.post(`${API_URL}/api/auth/logout`);
              
              // Clear cookies and local storage after successful sign-out
              Cookies.remove(tokenName);
              localStorage.clear();
              window.location.href= '/'
          
            } catch (error) {
              console.error('Sign out failed:', error);
              setError('Failed to sign out. Please try again.');
            }
          };
  |-server/
    |-app.js
      import express from 'express';
      import connectDB from './config/db.js';
      import applyGlobalMiddleware from './middleware/auth/globalMiddlewares.js';
      import errorHandler from './middleware/error/globalErrorMiddleware.js';  
      import initRoutes from './routes/initRoutes.js';
      
      // Connect to the database
      connectDB();
      
      // Initialize the app
      const app = express();
      
      // Apply global middlewares (e.g., JSON parsing, CORS)
      applyGlobalMiddleware(app);
      
      // Initialize all routes
      initRoutes(app);
      
      // Error handling middleware
      app.use(errorHandler);
      
      // Start the server
      const PORT = process.env.PORT || 5000;
      app.listen(PORT, () => {
        console.log(`Server is running on http://localhost:${PORT}`);
      });
    |-config/
      |-db.js
        import mongoose from 'mongoose';
        import dotenv from 'dotenv';
        
        dotenv.config(); // Load environment variables
        
        // Function to connect to MongoDB using the latest Mongoose standards
        const mongoURI = process.env.MONGODB_URI;
        const connectDB = async () => {
          try {
            const conn = await mongoose.connect(mongoURI);
            console.log(`MongoDB connected successfully: ${conn.connection.host}`);
          } catch (error) {
            console.error(`MongoDB connection error: ${error.message}`);
            process.exit(1); // Exit with failure
          }
        };
        
        export default connectDB;
      |-passport.js
        /**
         * This file configures the passport authentication middleware using JWT strategy 
         * to verify tokens and authenticate admin users. It attaches the admin data 
         * to the request object upon successful authentication.
         */
        
        import passport from 'passport';
        import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
        import { Strategy as LocalStrategy } from 'passport-local';
        import { 
          authenticateAdmin, 
          authenticateAgent,
          authenticateUserService
        }  from '../services/authService.js';  // If singular, for example
        import { 
          handleGoogleOAuthSignup, 
          handleGoogleOAuthSignin,
        } from '../services/authService.js'; // Import service function
        
        
        passport.use(
          'local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                const user = await authenticateUserService(email, password);
                return done(null, user);
              } catch (error) {
                return done(error, false);
              }
            }
          )
        );
        
        
        passport.use(
          'admin-local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                const admin = await authenticateAdmin(email, password);
                return done(null, admin);  // Pass the authenticated admin to the next middleware
              } catch (error) {
                return done(null, false, { message: error.message });  // Pass the error to the controller
              }
            }
          )
        );
        
        // Passport strategy for agent-local authentication
        passport.use(
          'agent-local',
          new LocalStrategy(
            { usernameField: 'email', passwordField: 'password' },
            async (email, password, done) => {
              try {
                // Call the service to handle agent authentication
                const { agent } = await authenticateAgent(email, password);
        
                // Pass the authenticated agent to the next middleware
                return done(null, agent);
              } catch (error) {
                // Pass the error to the controller (since service now throws errors)
                return done(null, false, error);
              }
            }
          )
        );
        
        passport.use(
          'google-signup',
          new GoogleStrategy(
            {
              clientID: process.env.GOOGLE_OAUTH_CLIENT_ID,
              clientSecret: process.env.GOOGLE_OAUTH_CLIENT_SECRET,
              callbackURL: process.env.GOOGLE_OAUTH_SIGNUP_REDIRECT_URI,
              scope: ['profile', 'email'],
            },
            async (accessToken, refreshToken, profile, done) => {
              const { id: googleId, name: { givenName: firstName = '', familyName: lastName = '' }, emails: [{ value: email = '' } = {}], photos: [{ value: avatar = '' } = {}] } = profile;
        
              try {
                // Pass profile data to the service layer for sign-up logic
                const { user, isExisting } = await handleGoogleOAuthSignup({ googleId, firstName, lastName, email, avatar });
                return done(null, { user, isExisting }); // Pass both user and isExisting flag
              } catch (error) {
                return done(error, null); // In case of an error, pass it to Passport
              }
            }
          )
        );
        
        passport.use(
          'google-signin',
          new GoogleStrategy(
            {
              clientID: process.env.GOOGLE_OAUTH_CLIENT_ID,
              clientSecret: process.env.GOOGLE_OAUTH_CLIENT_SECRET,
              callbackURL: process.env.GOOGLE_OAUTH_SIGNIN_REDIRECT_URI,
              scope: ['profile', 'email'],
            },
            async (accessToken, refreshToken, profile, done) => {
              const { id: googleId, name: { givenName: firstName = '', familyName: lastName = '' }, emails: [{ value: email = '' } = {}], photos: [{ value: avatar = '' } = {}] } = profile;
        
              try {
                // Pass profile data to the service layer for sign-in logic
                const user = await handleGoogleOAuthSignin({ googleId, firstName, lastName, email, avatar });
                return done(null, { user }); // Pass user object to Passport
              } catch (error) {
                return done(error, null); // Handle errors
              }
            }
          )
        );
        
        export default passport;
    |-controllers/
      |-admin/
        |-adminController.js
          
          
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { 
            getAllAdminsService, 
            getAdminByIdService,
            deleteAdminService,
            updateAdminService,
           } from '../../services/adminService.js';
          
          /**
           * @desc    Controller to handle the retrieval of all admin users.
           * @route   GET /api/admin
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the user's authentication details.
           * @param   {Object} res - Express response object for sending the list of admins.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with the success status and list of all admin users.
           */
          export const getAllAdmins = async (req, res, next) => {
            try {
              // Get the raw admin data from the service layer
              const admins = await getAllAdminsService();
              
              // Sanitize the data by excluding sensitive fields like passwords
              const sanitizedAdmins = admins.map(admin => excludeSensitiveInfo(admin, ['password', '__v']));
          
              // Respond with the sanitized admin data
              return res.status(200).json({
                success: true,
                data: sanitizedAdmins,
              });
          
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          export const getAdminById = async (req, res, next) => {
            try {
              // Extract the admin ID from the request parameters
              const { id } = req.params;
          
              // Call the service layer to get the admin by ID
              const admin = await getAdminByIdService(id);
          
              const sanitizedAdmin = excludeSensitiveInfo(admin, ['password', '__v']);
          
              // Respond with the admin data (excluding sensitive info like password)
              return res.status(200).json({
                success: true,
                data: sanitizedAdmin,
              });
          
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to delete an admin by ID.
           * @route   DELETE /api/admin/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the admin ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteAdmin = async (req, res, next) => {
            try {
              // Extract admin ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle admin deletion
              await deleteAdminService(id);
          
              // Send success response after admin is deleted
              return res.status(200).json({
                success: true,
                message: 'Admin deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to update a specific admin's information.
           * @route   PUT /api/admin/:id
           * @access  Private (Admin or Super Admin)
           * @param   {Object} req - Express request object containing the admin ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated admin data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated admin data or error.
           */
          export const updateAdmin = async (req, res, next) => {
            try {
              const { id } = req.params;
              const updates = req.body;
              console.log(req.user);
              const userRole = req.user.role;  // Get the user's role from the request (e.g., 'admin' or 'super-admin')
          
              // Call the service to update the admin and pass the userRole
              const updatedAdmin = await updateAdminService(id, updates, userRole);
              
              const sanitizedUpdatedAdmin = excludeSensitiveInfo(updatedAdmin, ['password', '__v']);
          
          
              return res.status(200).json({
                success: true,
                message: 'Admin information updated successfully.',
                data: sanitizedUpdatedAdmin,
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
      |-agent/
        |-agentController.js
          
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import {
            getAgentsByFilterService, 
            getAgentByIdService,
            deleteAgentService,
            updateAgentService,
            updateAgentStatusService, 
          } from '../../services/agentService.js';
          
          
          /**
           * @desc    Controller to handle retrieving all agent users from the database.
           * @param   {Object} req - Express request object.
           * @param   {Object} res - Express response object used to send the list of agents.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with the success status and list of all agents.
           */
          export const getAgentsByFilter = async (req, res, next) => {
            try {
              const filters = req.query;  // Extract filters from query parameters
          
              // Fetch the agents (all or filtered) from the service layer
              const agents = await getAgentsByFilterService(filters);
          
              // Sanitize the data by excluding sensitive fields like passwords
              const sanitizedAgents = agents.map(agent => excludeSensitiveInfo(agent, ['password', '__v']));
          
              // Respond with the sanitized agent data
              return res.status(200).json({
                success: true,
                data: sanitizedAgents,
              });
          
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          /**
           * @desc    Get a specific agent by ID from the database.
           *          Returns agent data except for the password field.
           * @route   GET /api/agent/:id
           * @access  Private (Agent/Admin)
           * @param   {Object} req - Express request object containing the agent ID in params.
           * @param   {Object} res - Express response object for sending the agent data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with agent data or formatted error.
           */
          export const getAgentById = async (req, res, next) => {
            try {
              // Extract the agent ID from the request parameters
              const { id } = req.params;
          
              // Call the service layer to get the agent by ID
              const agent = await getAgentByIdService(id);
          
              // Sanitize the agent data (remove sensitive fields like password)
              const sanitizedAgent = excludeSensitiveInfo(agent, ['password', '__v']);
          
              // Respond with the agent data
              return res.status(200).json({
                success: true,
                data: sanitizedAgent,
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to delete an agent by ID.
           * @route   DELETE /api/agent/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the agent ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteAgent = async (req, res, next) => {
            try {
              // Extract agent ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle agent deletion
              await deleteAgentService(id);
          
              // Send success response after agent is deleted
              return res.status(200).json({
                success: true,
                message: 'Agent deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to update a specific agent's information.
           * @route   PUT /api/agent/:id
           * @access  Private (Agent or Super Admin)
           * @param   {Object} req - Express request object containing the agent ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated agent data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated agent data or error.
           */
          export const updateAgent = async (req, res, next) => {
            try {
              const { id } = req.params;
              const updates = req.body;
              const userRole = req.user.role;  // Get the user's role from the request
          
              // Call the service to update the agent and pass the userRole
              const updatedAgent = await updateAgentService(id, updates, userRole);
          
              // Exclude sensitive fields like password before returning the response
              const sanitizedUpdatedAgent = excludeSensitiveInfo(updatedAgent, ['password', '__v']);
          
              return res.status(200).json({
                success: true,
                message: 'Agent information updated successfully.',
                data: sanitizedUpdatedAgent,
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
          
          
          /**
           * @desc Controller to update the status of an agent (admin-only)
           * @route PUT /api/agent/:id/status
           * @access Private (Admin)
           * @param {Object} req - The request object containing agent ID and new status.
           * @param {Object} res - The response object used to send the updated agent details.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message and updated agent data.
           */
          export const updateAgentStatus = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { agentStatus } = req.body;
          
              // Call the service layer to update agent status
              const updatedAgent = await updateAgentStatusService(id, agentStatus);
          
              // Send response with updated agent data
              return res.status(200).json({
                success: true,
                message: `Agent status updated to ${agentStatus}`,
                data: {
                  id: updatedAgent._id,
                  firstName: updatedAgent.firstName,
                  lastName: updatedAgent.lastName,
                  email: updatedAgent.email,
                  agentStatus: updatedAgent.agentStatus,
                },
              });
            } catch (error) {
              return next(error);  // Pass the error to the global error handler
            }
          };
          
      |-faq/
        |-faqController.js
          import FAQ from '../../models/Faq.js';
          import { formatError } from '../../utils/errorFormatter.js';
          
          // Get all FAQs Controller
          export const getAllFaqs = async (req, res, next) => {
            try {
              const faqs = await FAQ.find();
              res.status(200).json(faqs);
            } catch (error) {
              return next(formatError('Error retrieving FAQs', [], 500));
            }
          };
          
          // Create a new FAQ Controller
          export const createFaq = async (req, res, next) => {
            const { question, answer, category, priority, isPublished, tags } = req.body;
          
            try {
              const faq = new FAQ({
                question,
                answer,
                category,  // Optional category
                priority,  // Optional priority
                isPublished, // Optional publication status
                tags       // Optional tags (array of strings)
              });
          
              await faq.save(); // Save the new FAQ to the database
              res.status(201).json(faq); // Return the created FAQ
            } catch (error) {
              return next(formatError('Error creating FAQ', [{ field: 'general', message: error.message }], 400));
            }
          };
          
          // Update a FAQ Controller
          export const updateFaq = async (req, res, next) => {
            const { id } = req.params;
            const updates = req.body;
          
            try {
              const faq = await FAQ.findById(id);
          
              if (!faq) {
                return next(formatError('FAQ not found', [{ field: 'id', message: `FAQ with id ${id} not found` }], 404));
              }
          
              // Object to track updated fields
              const fieldsUpdated = [];
          
              // Only update fields that were passed in req.body
              for (const key in updates) {
                if (faq[key] !== undefined) { // Ensure the key exists in the FAQ object
                  faq[key] = updates[key];
                  fieldsUpdated.push(key);
                }
              }
          
              // Save the updated FAQ
              await faq.save();
          
              // Respond with a detailed success message
              res.status(200).json({
                message: 'FAQ was successfully updated.',
                id: id,
                fieldsUpdated: fieldsUpdated.length ? fieldsUpdated : 'No fields were updated',
                faq
              });
          
            } catch (error) {
              return next(formatError('Error updating FAQ', [{ field: 'id', message: error.message }], 500));
            }
          };
          
          // Delete a FAQ Controller
          export const deleteFaq = async (req, res, next) => {
            const { id } = req.params; // Extract the id from the URL
          
            try {
              const faq = await FAQ.findByIdAndDelete(id); // Find and delete the FAQ by id
              if (!faq) {
                return next(formatError('FAQ not found', [{ field: 'id', message: `FAQ with id ${id} not found` }], 404));
              }
          
              res.status(200).json({
                message: 'FAQ was successfully deleted',
                id: id
              });
            } catch (error) {
              return next(formatError('Error deleting FAQ', [{ field: 'id', message: error.message }], 500));
            }
          };
      |-auth/
        |-agentAuthController.js
          
          
          import passport from 'passport';
          import '../../config/passport.js';
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { UnauthorizedError } from '../../utils/customErrors.js';  // Adjust path if needed
          import { createNewAgent, } from '../../services/agentService.js';
          
          
          /**
           * @desc    Controller to handle the registration of new agents.
           * @param   {Object} req - Express request object containing the agent's data in the body.
           * @param   {Object} res - Express response object used to send the result of the registration process.
           * @param   {Function} next - Express middleware function for passing control to the next middleware in case of errors.
           * @returns {JSON} - Success response with the created agent's data and a JWT token
           * @throws  {JSON} - If validation or business logic errors occur, or if there's a server error during registration.
           */
          export const createAgent = async (req, res, next) => {
              try {
                // Call the service layer to create a new agent
                const newAgent = await createNewAgent(req.body);
            
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(newAgent);
            
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
            
                // Exclude sensitive fields (like password) from the response
                const agentResponse = excludeSensitiveInfo(newAgent, ['password', '__v']);
            
                return res.status(201).json({
                  success: true,
                  message: 'Agent created successfully.',
                  data: agentResponse,
                });
                
              } catch (error) {
                return next(error);
              }
            };
            
            /*
             * Controller to handle agent login using Passport local strategy.
             * This controller handles authentication, token generation, and setting the authentication cookie.
             * 
             * @param {Object} req - Express request object containing agent's login credentials.
             * @param {Object} res - Express response object used to send the login result and JWT token.
             * @param {Function} next - Express middleware function for error handling or passing control to the next middleware.
             * @returns {JSON} - Returns a success response with the agent's data and a JWT token if authentication is successful.
             * @throws {JSON} - If authentication fails, it passes an error to the global error handler.
             */
            export const loginAgent = (req, res, next) => {
              passport.authenticate('agent-local', { session: false }, async (err, agent, info) => {
                if (err) {
                  return next(err);  // Pass server error to the global error handler
                }
            
                if (!agent) {
                  // Handle authentication failure
                  const error = new UnauthorizedError(info?.message || 'Authentication failed');
                  return next(error);
                }
            
                try {
                  // Generate JWT token and set it as a cookie
                  const { token, cookieOptions } = generateTokenAndCookieOptions(agent);
                  
                  // Set the JWT token in the cookie
                  setTokenCookie(res, token, cookieOptions);
            
            
                  const agentResponse = excludeSensitiveInfo(agent, ['password', '__v']);
            
            
                  // Send the response with agent info (excluding sensitive data)
                  return res.status(200).json({
                    success: true,
                    message: 'Agent logged in successfully!',
                    data: agentResponse,
                  });
                } catch (error) {
                  next(error);  // Pass any unexpected error to the global error handler
                }
              })(req, res, next);
            };
        |-userAuthController.js
          import passport from 'passport';
          import '../../config/passport.js';
          import { createNewUser } from '../../services/userServices.js';
          import { generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import { excludeSensitiveInfo } from '../../utils/excludeSensitiveInfo.js';
          import { clearTokenCookie } from '../../services/authService.js';
          import { UnauthorizedError, } from '../../utils/customErrors.js';
          
          
          /**
           * @desc    Controller to handle the registration of new users.
           * @param   {Object} req - Express request object containing the user's data in the body.
           * @param   {Object} res - Express response object used to send the result of the registration process.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with the created user's data and a JWT token.
           */
          export const createUser = async (req, res, next) => {
            try {
              // Call the service layer to create a new user
              const newUser = await createNewUser(req.body);
          
              // Generate token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(newUser);
          
              // Set the JWT token in the cookie
              setTokenCookie(res, token, cookieOptions);
          
              // Exclude sensitive fields (like password) from the response
              const userResponse = excludeSensitiveInfo(newUser, ['password', '__v']);
          
              return res.status(201).json({
                success: true,
                message: 'User registered successfully.',
                data: userResponse,
              });
            } catch (error) {
              return next(error); // Pass errors to the global error handler
            }
          };
          
          /**
           * Controller to handle user login via local strategy.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with JWT token and user data.
           */
          export const authenticateUser = async (req, res, next) => {
            passport.authenticate('local', { session: false }, async (err, user, info) => {
              if (err) {
                return next(err);  // Pass server-side error to global error handler
              }
          
              if (!user) {
                // Handle authentication failure
                const error = new UnauthorizedError(info?.message || 'Authentication failed');
                return next(error);
              }
          
              try {
                // Generate JWT token and cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
          
                // Exclude sensitive fields like password from the response
                const userResponse = excludeSensitiveInfo(user, ['password', '__v']);
          
                // Send success response
                return res.status(200).json({
                  success: true,
                  message: 'User logged in successfully!',
                  data: userResponse,
                });
              } catch (error) {
                return next(error);  // Pass any unexpected error to the global error handler
              }
            })(req, res, next);
          };
          
          /**
           * Controller for logging out a user.
           * @desc Clears the authentication token stored in the user's cookie, effectively logging them out.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object used to send the result of the logout.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message indicating the user has logged out.
           */
          export const logoutUser = (req, res, next) => {
            try {
              // Call the service to clear the authentication token cookie
              clearTokenCookie(res);
          
              // Send a response indicating successful logout
              return res.status(200).json({
                success: true,
                message: 'User logged out successfully.',
              });
            } catch (error) {
              next(error); // Pass any errors to the global error handler
            }
          };
          
        |-googleOAuthController.js
          import User from '../../models/User.js';
          import { handleGoogleOAuthSignup } from '../../services/authService.js';
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          
          /**
           * Controller to handle Google OAuth Signup Callback.
           * @desc This controller is called after the Google OAuth sign-up process.
           * @param {Object} req - Express request object containing the user profile.
           * @param {Object} res - Express response object used to send the result of the signup.
           * @returns {Response} - Redirect to a success or failure page on the client.
           */
          export const googleOAuthSignupCallback = async (req, res) => {
            try {
              const { user, isExisting } = req.user;  // This is passed by Passport after Google authentication
          
              if (!user) {
                const errorMessage = encodeURIComponent('Google OAuth failed');
                return res.redirect(`${process.env.CLIENT_URI}/signup/failure?message=${errorMessage}`);
              }
          
              // Generate token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
              setTokenCookie(res, token, cookieOptions);
          
              if (isExisting) {
                const welcomeBackMessage = encodeURIComponent('Welcome back!');
                return res.redirect(`${process.env.CLIENT_URI}/signin/success?message=${welcomeBackMessage}`);
              } else {
                const successMessage = encodeURIComponent('Signup successful');
                return res.redirect(`${process.env.CLIENT_URI}/signup/success?message=${successMessage}`);
              }
            } catch (error) {
              const errorMessage = encodeURIComponent('Error processing signup');
              return res.redirect(`${process.env.CLIENT_URI}/signup/failure?message=${errorMessage}`);
            }
          };
          
          
          // Google OAuth Sign-In Callback
          /**
           * Google OAuth Sign-In Callback Controller
           * @desc This controller is called after the Google OAuth sign-in process.
           * @param {Object} req - Express request object containing the user profile.
           * @param {Object} res - Express response object used to send the result of the sign-in.
           * @returns {Response} - Redirect to a success or failure page on the client.
           */
          export const googleOAuthSigninCallback = async (req, res) => {
            try {
              const { user } = req.user;  // This is passed by Passport after Google authentication
          
              if (!user) {
                const errorMessage = encodeURIComponent('Google OAuth failed');
                return res.redirect(`${process.env.CLIENT_URI}/signin/failure?message=${errorMessage}`);
              }
          
              // Generate JWT token and get cookie options
              const { token, cookieOptions } = generateTokenAndCookieOptions(user);
          
              // Set the JWT token in the cookie
              setTokenCookie(res, token, cookieOptions);
          
              // Redirect to frontend with success message
              const successMessage = encodeURIComponent('Signin successful');
              return res.redirect(`${process.env.CLIENT_URI}/signin/success?message=${successMessage}`);
          
            } catch (error) {
              const errorMessage = encodeURIComponent('Error processing signin');
              return res.redirect(`${process.env.CLIENT_URI}/signin/failure?message=${errorMessage}`);
            }
          };
        |-adminAuthController.js
          
          
          
          import {generateTokenAndCookieOptions, setTokenCookie } from '../../utils/authHelpers.js';
          import passport from 'passport';
          import '../../config/passport.js';
          import {excludeSensitiveInfo} from '../../utils/excludeSensitiveInfo.js';
          import { 
            createNewAdmin, 
           } from '../../services/adminService.js';
          import { UnauthorizedError, } from '../../utils/customErrors.js';
          
          
          /**
           * Controller to create a new admin.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Returns the created admin and a JWT token.
           */
          export const createAdmin = async (req, res, next) => {
              try {
                // Call the service layer to create a new admin
                const newAdmin = await createNewAdmin(req.body);
            
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(newAdmin);
            
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
            
                // Exclude sensitive fields (like password) from the response
                const adminResponse = excludeSensitiveInfo(newAdmin, ['password', '__v']);
            
                // Send success response
                return res.status(201).json({
                  success: true,
                  message: 'Admin created successfully.',
                  data: adminResponse,
                });
              } catch (error) {
                // Pass the error to the global error handler
                return next(error);
              }
            };
            
          /**
           * Login admin controller.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware function for error handling.
           */
          export const loginAdmin = (req, res, next) => {
            passport.authenticate('admin-local', { session: false }, async (err, admin, info) => {
              if (err) {
                return next(err);  // Handle server error
              }
          
              if (!admin) {
                // If no admin is found, pass the UnauthorizedError to the error handler
                const error = new UnauthorizedError(info?.message || 'Authentication failed');
                return next(error);
              }
          
              try {
                // Generate token and get cookie options
                const { token, cookieOptions } = generateTokenAndCookieOptions(admin);
          
                // Set the JWT token in the cookie
                setTokenCookie(res, token, cookieOptions);
          
                // Exclude sensitive fields from the response
                const adminResponse = excludeSensitiveInfo(admin, ['password', '__v']);
          
                return res.status(200).json({
                  success: true,
                  message: 'Admin logged in successfully!',
                  data: adminResponse,
                });
              } catch (error) {
                // Pass any errors to the error handler
                return next(error);
              }
            })(req, res, next);
          };
      |-property/
        |-propertiesController.js
          import { 
            createNewProperty,
            getPropertyByIdService,
            deletePropertyService,
            getPropertiesByFilterService,
            addPropertyImageService, 
            removePropertyImageService,
            addPropertyAmenityService, 
            removePropertyAmenityService 
           } from '../../services/propertyService.js';
          import { updatePropertyService } from '../../services/propertyService.js';
          
          /**
           * @desc    Controller to handle the creation of a new property.
           * @param   {Object} req - Express request object containing the property data.
           * @param   {Object} res - Express response object used to send the result of the creation process.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with the created property's data.
           */
          export const createProperty = async (req, res, next) => {
            try {
                const newProperty = await createNewProperty(req.body);
          
                return res.status(201).json({
                    success: true,
                    message: 'Property created successfully.',
                    data: newProperty,
                });
            } catch (error) {
                next(error);
            }
          };
          
          
          /**
           * @desc    Controller to handle retrieving a property by ID from the database.
           * @param   {Object} req - Express request object containing the property ID in params.
           * @param   {Object} res - Express response object for sending the property data.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {Object} - Success response with property data or formatted error.
           */
          export const getPropertyById = async (req, res, next) => {
            try {
              const { id } = req.params; // Extract property ID from params
          
              // Call the service to get the property by ID
              const property = await getPropertyByIdService(id);
          
              return res.status(200).json({
                success: true,
                data: property, 
              });
            } catch (error) {
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to update a specific property's information.
           * @route   PUT /api/properties/:id
           * @access  Private (Admin or Property Owner)
           * @param   {Object} req - Express request object containing the property ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated property data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated property data or error.
           */
          export const updateProperty = async (req, res, next) => {
            try {
              const { id } = req.params;
              const updates = req.body;
              const userRole = req.user.role;
          
              // Call the service to update the property
              const updatedProperty = await updatePropertyService(id, updates, userRole);
          
              return res.status(200).json({
                success: true,
                message: 'Property information updated successfully.',
                data: updatedProperty,  // Send the updated property data
              });
            } catch (error) {
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to delete a property by ID and remove its reference from users/agents.
           * @route   DELETE /api/properties/:id
           * @access  Private (Admin or Property Owner)
           * @param   {Object} req - Express request object containing the property ID in params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteProperty = async (req, res, next) => {
            try {
              const { id } = req.params;
          
              // Call the service to delete the property and remove its references from users/agents
              await deletePropertyService(id);
          
              return res.status(200).json({
                success: true,
                message: 'Property deleted and references updated successfully!',
              });
            } catch (error) {
              return next(error);  // Pass any errors to the global error handler
            }
          };
          
          /**
           * @desc    Controller to fetch properties, either all or filtered based on query parameters.
           * @param   {Object} req - Express request object containing query parameters for filters.
           * @param   {Object} res - Express response object for sending the property data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - JSON response with success status and list of properties.
           */
          export const getPropertiesByFilter = async (req, res, next) => {
            try {
              // Pass query parameters to the service
              const filters = req.query;
          
              // Fetch properties based on filters (or all if no filters)
              const properties = await getPropertiesByFilterService(filters);
          
              return res.status(200).json({
                success: true,
                data: properties,
              });
            } catch (error) {
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to add an image to a property
           * @route   PUT /api/properties/:id/images
           * @access  Private (Admin, Owner, or Agent)
           */
          export const addPropertyImage = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { imageUrl } = req.body;
          
              const updatedProperty = await addPropertyImageService(id, imageUrl);
          
              return res.status(200).json({
                success: true,
                message: 'Image added successfully.',
                data: updatedProperty,
              });
            } catch (error) {
              next(error);
            }
          };
          
          /**
           * @desc    Controller to remove an image from a property
           * @route   PUT /api/properties/:id/images/remove
           * @access  Private (Admin, Owner, or Agent)
           */
          export const removePropertyImage = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { imageUrl } = req.body;
          
              const updatedProperty = await removePropertyImageService(id, imageUrl);
          
              return res.status(200).json({
                success: true,
                message: 'Image removed successfully.',
                data: updatedProperty,
              });
            } catch (error) {
              next(error);
            }
          };
          
          /**
           * @desc    Controller to add an amenity to a property
           * @route   PUT /api/properties/:id/amenities
           * @access  Private (Admin, Owner, or Agent)
           */
          export const addPropertyAmenity = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { amenity } = req.body;
          
              const updatedProperty = await addPropertyAmenityService(id, amenity);
          
              return res.status(200).json({
                success: true,
                message: 'Amenity added successfully.',
                data: updatedProperty,
              });
            } catch (error) {
              next(error);  // Pass error to global error handler
            }
          };
          
          /**
           * @desc    Controller to remove an amenity from a property
           * @route   PUT /api/properties/:id/amenities/remove
           * @access  Private (Admin, Owner, or Agent)
           */
          export const removePropertyAmenity = async (req, res, next) => {
            try {
              const { id } = req.params;
              const { amenity } = req.body;
          
              const updatedProperty = await removePropertyAmenityService(id, amenity);
          
              return res.status(200).json({
                success: true,
                message: 'Amenity removed successfully.',
                data: updatedProperty,
              });
            } catch (error) {
              next(error);  // Pass error to global error handler
            }
          };
          
      |-validation/
        |-validationController.js
          
          
          import { 
            isUsernameAvailable, 
            isEmailAvailable 
          } from '../../services/validationServices.js';
          
          /**
           * Controller to check if a username is available.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware for error handling.
           */
          export const checkUsername = async (req, res, next) => {
            const { username } = req.params;
          
            try {
              await isUsernameAvailable(username); // Call the service layer
          
              return res.status(200).json({ success: true, message: 'Username is available.' });
            } catch (error) {
              return next(error); // Forward errors to the global error handler
            }
          };
          
          /**
           * Controller to check if an email is already registered.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express middleware for error handling.
           */
          export const checkEmail = async (req, res, next) => {
            const { email } = req.params;
          
            try {
              await isEmailAvailable(email); // Call the service layer
          
              return res.status(200).json({ success: true, message: 'Email is available.' });
            } catch (error) {
              return next(error); // Forward errors to the global error handler
            }
          };
      |-user/
        |-userController.js
          /**
           * This file contains the controllers for user management in the system.
           */
          
          // Utility functions
          import { excludeSensitiveInfo } from '../../utils/excludeSensitiveInfo.js';
          
          // Service functions
          import {
            getUsersByFilterService,
            getUserByIdService,
            deleteUserService,
            updateUserService,
            addPropertyToUserService,
            removePropertyFromUserService,
          } from '../../services/userServices.js';
          
          /**
           * @desc    Controller to retrieve users based on query parameters (filters) or return all users if no filters are provided.
           *          This route is public, meaning it doesn't require authentication.
           * @route   GET /api/users
           * @access  Public
           * @param   {Object} req - Express request object containing query parameters for filtering.
           * @param   {Object} res - Express response object used to send the list of filtered users or all users.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with a list of users or an error.
           */
          export const getUsersByFilter = async (req, res, next) => {
            try {
              const filters = req.query;
              const users = await getUsersByFilterService(filters);
          
              const sanitizedUsers = users.map(user => excludeSensitiveInfo(user, ['password', '__v']));
          
              return res.status(200).json({
                success: true,
                data: sanitizedUsers,
              });
          
            } catch (error) {
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to retrieve a specific user by ID from the database.
           * @route   GET /api/users/:id
           * @access  Public
           * @param   {Object} req - Express request object containing the user ID in params.
           * @param   {Object} res - Express response object for sending the user data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with user data or formatted error.
           */
          export const getUserById = async (req, res, next) => {
              try {
                const { id } = req.params; // Extract user ID from params
            
                // Call the service to get user by ID
                const user = await getUserByIdService(id);
            
                // Sanitize user data (exclude sensitive fields like password)
                const sanitizedUser = excludeSensitiveInfo(user, ['password', '__v']);
            
                return res.status(200).json({
                  success: true,
                  data: sanitizedUser,
                });
              } catch (error) {
                return next(error); // Pass error to global error handler
              }
          };
          
          /**
           * @desc    Controller to update a specific user's information.
           * @route   PUT /api/user/:id
           * @access  Private (User or Admin)
           * @param   {Object} req - Express request object containing the user ID in params and updated data in the body.
           * @param   {Object} res - Express response object for sending the updated user data.
           * @param   {Function} next - Express next middleware function for error handling.
           * @returns {Object} - Success response with updated user data or error.
           */
          export const updateUser = async (req, res, next) => {
              try {
                const { id } = req.params; // Extract user ID from the request params
                const updates = req.body;  // Extract the updates from the request body
                const userRole = req.user.role;  // Get the user's role from the JWT payload
            
                // Call the service to update the user
                const updatedUser = await updateUserService(id, updates, userRole);
            
                // Exclude sensitive fields like password before sending the response
                const sanitizedUpdatedUser = excludeSensitiveInfo(updatedUser, ['password', '__v']);
            
                return res.status(200).json({
                  success: true,
                  message: 'User information updated successfully.',
                  data: sanitizedUpdatedUser,
                });
              } catch (error) {
                return next(error);  // Pass the error to the global error handler
              }
          };
          
          /**
           * @desc    Controller to delete a user by ID.
           * @route   DELETE /api/users/:id
           * @access  Private (Admin)
           * @param   {Object} req - Express request object containing the user ID in the params.
           * @param   {Object} res - Express response object used to send the deletion result.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success message or error response.
           */
          export const deleteUser = async (req, res, next) => {
            try {
              // Extract user ID from request parameters
              const { id } = req.params;
          
              // Call the service to handle user deletion
              await deleteUserService(id);
          
              // Send success response after user is deleted
              return res.status(200).json({
                success: true,
                message: 'User deleted successfully!',
              });
            } catch (error) {
              // Pass the error to the global error handler
              return next(error);
            }
          };
          
          /**
           * @desc    Controller to add a property to a user's properties array.
           * @route   POST /api/users/:userId/add-property
           * @access  Private (User or Admin)
           * @param   {Object} req - Express request object containing userId in params and propertyId in the body.
           * @param   {Object} res - Express response object used to send the updated user data.
           * @param   {Function} next - Express middleware function for error handling.
           * @returns {JSON} - Success response with the updated user data.
           */
          export const addPropertyToUser = async (req, res, next) => {
            const { userId } = req.params; // Extract userId from URL params
            const { propertyId } = req.body; // Extract propertyId from the body
          
            try {
              // Call the service to add the property to the user's properties array
              const updatedUser = await addPropertyToUserService(userId, propertyId);
          
              // Return success response with the updated user data
              return res.status(200).json({
                success: true,
                message: 'Property added to user successfully.',
                data: updatedUser,
              });
            } catch (error) {
              return next(error); // Pass any errors to the global error handler
            }
          };
          
          /**
           * Controller to handle removing a property from a user.
           * @param {Object} req - Express request object containing userId in params and propertyId in body.
           * @param {Object} res - Express response object for sending the result of the removal process.
           * @param {Function} next - Express middleware function for error handling.
           */
          export const removePropertyFromUser = async (req, res, next) => {
            try {
              const { userId } = req.params;
              const { propertyId } = req.body;
          
              const updatedUser = await removePropertyFromUserService(userId, propertyId);
          
              return res.status(200).json({
                success: true,
                message: 'Property removed from user successfully.',
                data: updatedUser
              });
            } catch (error) {
              next(error);
            }
          };
          
    |-utils/
      |-validationErrorsHandler.js
        import { validationResult } from 'express-validator';
        import { ValidationError } from '../utils/customErrors.js';
        
        /**
         * Middleware to handle validation errors from express-validator.
         */
        export const handleValidationErrors = (req, res, next) => {
          const errors = validationResult(req);
        
          if (!errors.isEmpty()) {
            // Format validation errors: Each error includes only the field and its message
            const formattedErrors = errors.array().map(err => ({
              field: err.param,   // This will be the field name (like "email")
              message: err.msg,   // This will be the error message (like "Please provide a valid email address")
            }));
        
            // Pass the formatted errors to the global error handler
            return next(new ValidationError('Validation failed due to invalid inputs.', formattedErrors, 400));
          }
        
          // Proceed to the next middleware/controller if no validation errors
          next();
        };
      |-checkDuplicateFields.js
        /**
         * @desc Checks for duplicate fields in the database and returns an array of duplicate field errors if found.
         * @param {Model} model - The Mongoose model to search for existing records.
         * @param {Object} fieldsToCheck - The fields to check for duplicates (e.g., username, email, phoneNumber).
         * @returns {Array} - Returns an array of duplicate field errors or an empty array if no duplicates are found.
         */
        export const checkDuplicateFields = async (model, fieldsToCheck) => {
          const duplicateErrors = [];
        
          // Build the query to search for any matching records
          const query = {
            $or: Object.keys(fieldsToCheck).map((field) => ({ [field]: fieldsToCheck[field] })),
          };
        
          // Find an existing record that matches one of the fields
          const existingRecord = await model.findOne(query);
        
          // If an existing record is found, check for which fields are duplicates
          if (existingRecord) {
            Object.keys(fieldsToCheck).forEach((field) => {
              if (existingRecord[field] === fieldsToCheck[field]) {
                duplicateErrors.push({
                  field,
                  message: `${field.charAt(0).toUpperCase() + field.slice(1)} is already in use.`,
                });
              }
            });
          }
        
          // Return an array of duplicate errors (empty array if no duplicates found)
          return duplicateErrors;
        };
      |-generateUniqueUsername.js
        import User from '../models/User.js';
        
        async function generateUniqueUsername(firstName, lastName, email) {
            let baseUsername = (firstName + lastName).toLowerCase().replace(/\s+/g, '');
        
            // If no valid base username is created, fall back to the email prefix
            if (!baseUsername) {
                baseUsername = email.split('@')[0]; // Use email username part as fallback
            }
        
            let username = baseUsername;
            let suffix = 1;
            
            // Check if the generated username already exists in the database
            while (await User.findOne({ username })) {
              username = `${baseUsername}${suffix}`;
              suffix++;
            }
            
            return username;
        }
        
        export default generateUniqueUsername;
        
      |-authHelpers.js
        import jwt from 'jsonwebtoken';
        import { ValidationError } from '../utils/customErrors.js';
        
        export const generateJWT = (user) => {
          console.log('User object received in generateJWT:', JSON.stringify(user, null, 2));
        
          if (!user || !user._id || !user.username || !user.email || !user.role) {
            throw new ValidationError('Invalid user object provided to generateJWT', [
              { field: '_id', message: 'User ID is missing' },
              { field: 'username', message: 'Username is missing' },
              { field: 'email', message: 'Email is missing' },
              { field: 'role', message: 'Role is missing' }
            ].filter(error => !user || !user[error.field]));
          }
        
          const payload = {
            id: user._id,
            username: user.username,
            email: user.email,
            role: user.role,
          };
        
          const options = {
            expiresIn: process.env.JWT_EXPIRES_IN,
            issuer: process.env.JWT_ISSUER,
            audience: process.env.JWT_AUDIENCE,
          };
        
          console.log('JWT payload:', payload);
          console.log('JWT options:', options);
        
          return jwt.sign(payload, process.env.JWT_SECRET, options);
        };
        
        export const generateTokenAndCookieOptions = (user) => {
          const token = generateJWT(user);
          const cookieOptions = {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 3 * 24 * 60 * 60 * 1000, // 3 days in milliseconds
            name: process.env.JWT_COOKIE_NAME,
          };
        
          console.log('Generated token:', token);
          console.log('Cookie options:', cookieOptions);
        
          return { token, cookieOptions };
        };
        
        export const setTokenCookie = (res, token, cookieOptions) => {
          if (!res || !token || !cookieOptions) {
            throw new Error('Invalid parameters provided to setTokenCookie');
          }
        
          console.log('Setting token cookie. Token:', token);
          res.cookie(cookieOptions.name, token, cookieOptions);
        };
        
        export const verifyJWT = (token) => {
          try {
            console.log('Verifying token:', token);
            return jwt.verify(token, process.env.JWT_SECRET, {
              issuer: process.env.JWT_ISSUER,
              audience: process.env.JWT_AUDIENCE,
            });
          } catch (error) {
            console.error('Token verification failed:', error);
            throw new Error('Invalid or expired token');
          }
        };
      |-removeRestrictedFields.js
        
        
        /**
         * Utility function to remove restricted fields from an updates object.
         * @param {Object} data - The updates object containing fields to be created or modified.
         * @param {Array<string>} restrictedFields - An array of field names that should not be modified.
         * @returns {Object} - The sanitized updates object with restricted fields removed.
         */
        export const removeRestrictedFields = (data, restrictedFields) => {
            // Create a shallow copy of updates to avoid directly modifying the original object
            const sanitizedUpdates = { ...data };
          
            // Loop through restrictedFields and delete them from updates if they exist
            restrictedFields.forEach(field => {
              if (field in sanitizedUpdates) {
                delete sanitizedUpdates[field];
              }
            });
          
            return sanitizedUpdates;
          };
          
      |-excludeSensitiveInfo.js
        
        
        /**
         * @desc Exclude sensitive fields from the Mongoose model object before sending the response.
         * @param {Object} modelObject - The Mongoose model object.
         * @param {Array<string>} fieldsToExclude - Array of fields to exclude from the object. Defaults to ['password'].
         * @returns {Object} - The object with specified fields excluded, ready to send as a response.
         */
        export const excludeSensitiveInfo = (modelObject, fieldsToExclude = ['password']) => {
            const modelObj = modelObject.toObject(); // Convert Mongoose document to plain JS object
          
            fieldsToExclude.forEach(field => {
              delete modelObj[field];
            });
          
            return modelObj; // Return the sanitized object
          };
          
      |-mongooseUtils.js
        /*
         * This utility function checks if an ID is a valid MongoDB ObjectId. This is useful for ensuring that
         */
        
        import mongoose from 'mongoose';
        
        export const isValidObjectId = (id) => {
            console.log(isValidObjectId);
            return mongoose.Types.ObjectId.isValid(id);
        };
      |-errorFormatter.js
        /**
         * Formats errors for consistent API response.
         * @param {string} message - A general error message.
         * @param {array} errors - Optional array of field-specific errors.
         * @param {number} statusCode - Optional HTTP status code (default 400).
         */
        export const formatError = (message, errors = [], statusCode = 400) => {
          return {
            success: false,
            error: {
              message,
              errors: errors.length > 0 ? errors : undefined,  // Only include errors if there are any
            },
            statusCode,
          };
        };
      |-customErrors.js
        class CustomError extends Error {
            constructor(message, statusCode, errors = []) {
                super(message);
                this.statusCode = statusCode;
                this.errors = errors;
                this.name = this.constructor.name;
            }
        
            toJSON() {
                return {
                    success: false,
                    error: {
                        message: this.message,
                        errors: this.errors.length > 0 ? this.errors : undefined,
                    },
                    statusCode: this.statusCode,
                };
            }
        }
        
        export class UnauthorizedError extends CustomError {
            constructor(message = 'Unauthorized access', errors = []) {
                super(message, 401, errors);
            }
        }
        
        export class ForbiddenError extends CustomError {
            constructor(message = 'Forbidden action', errors = []) {
                super(message, 403, errors);
            }
        }
        
        export class ValidationError extends CustomError {
            constructor(message = 'Validation failed', errors = []) {
                super(message, 400, errors);
            }
        }
        
        export class BusinessLogicError extends CustomError {
            constructor(message = 'Business logic error occurred', errors = []) {
                super(message, 400, errors);
            }
        }
        
        export class NotFoundError extends CustomError {
            constructor(message = 'Resource not found') {
                super(message, 404);
            }
        }
        
        export class ServerError extends CustomError {
            constructor(message = 'Internal Server Error') {
                super(message, 500);
            }
        }
        
        export class MongooseValidationError extends ValidationError {
            constructor(mongooseError) {
                // Extract and format validation errors from Mongoose
                const formattedErrors = Object.keys(mongooseError.errors).map(key => ({
                    field: key,
                    message: mongooseError.errors[key].message,
                }));
                super('Validation failed for some fields.', formattedErrors);
            }
        }
        
        
        export { CustomError };
    |-routes/
      |-userRoutes.js
        /**
         * This file contains the routes for user management in the system.
         */
        
        import express from 'express';
        
        // Controllers
        import {
          getUsersByFilter,
          getUserById,
          updateUser,
          deleteUser,
          addPropertyToUser,
          removePropertyFromUser,
        } from '../controllers/user/userController.js';
        
        // Middleware - Authentication & Authorization
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        import { checkIsUserSelfOrAdmin } from '../middleware/auth/roleMiddleware.js';  // Role-based access control
        
        // Middleware - Validation
        import { validateObjectId } from '../middleware/validation/validateObjectId.js';
        import { validateUpdateUserFields } from '../middleware/validation/userUpdateValidation.js';
        import { validatePropertyIdBody } from '../middleware/validation/validateObjectIdBody.js';
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js';
        import { validateUserObjectIdParam } from '../middleware/validation/validateUserObjectId.js';
        
        const router = express.Router();
        
        // Get Users by filter (public)
        router.get(
          '/', 
          getUsersByFilter
        );
        
        // Get a specific users by ID (public)
        router.get(
          '/:id',
          validateObjectId, 
          getUserById
        );
        
        // Update user information (admin or the user themselves)
        router.put(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsUserSelfOrAdmin, 
          validateUpdateUserFields, 
          updateUser
        );
        
        // Delete a user (admin or the user themselves)
        router.delete(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsUserSelfOrAdmin, 
          deleteUser
        );
        
        router.post(
          '/:userId/add-property',
          authenticateJWT,
          checkIsUserSelfOrAdmin, 
          validateUserObjectIdParam,
          validatePropertyIdBody,
          handleValidationErrors,
          addPropertyToUser,
        );
        
        router.put(
          '/:userId/remove-property',
          authenticateJWT,
          checkIsUserSelfOrAdmin, 
          validateUserObjectIdParam,
          validatePropertyIdBody,
          handleValidationErrors,
          removePropertyFromUser
        );
        
        
        export default router;
      |-agentRoutes.js
        /**
         * This file contains the routes for agent management in the system.
         */
        
        import express from 'express';
        import {
          getAgentsByFilter,
          getAgentById,
          updateAgentStatus,
          updateAgent,
          deleteAgent,
        } from '../controllers/agent/agentController.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        import { checkIsAdmin, checkIsAgentSelfOrAdmin} from '../middleware/auth/roleMiddleware.js';  // Role-based access control
        import { validateUpdateAgentFields } from '../middleware/validation/agentUpdateValidation.js';  // Input validation for agents
        import {validateObjectId} from '../middleware/validation/validateObjectId.js';
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Agent Routes
         * ============================
         */
        
        // Get all agents (public)
        router.get(
          '/', 
          getAgentsByFilter
        );
        
        // Get a specific agent by ID (public)
        router.get(
          '/:id',
          validateObjectId, 
          getAgentById
        );
        
        // Admin-only route to approve or reject agents
        router.patch(
          '/:id/status', 
          authenticateJWT,
          validateObjectId,  
          checkIsAdmin, 
          updateAgentStatus
        );
        
        // Update agent information (admin or the agent themselves)
        router.put(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsAgentSelfOrAdmin, 
          validateUpdateAgentFields, 
          updateAgent
        );
        
        // Delete an agent (admin or the agent themselves)
        router.delete(
          '/:id', 
          authenticateJWT,
          validateObjectId, 
          checkIsAgentSelfOrAdmin, 
          deleteAgent
        );
        
        
        export default router;
      |-transactionRoutes.js
        import express from 'express';
        const router = express.Router();
        
        // Placeholder routes for transactions (buying, renting)
        router.get('/', (req, res) => {
          res.send('Transaction route');
        });
        
        export default router;
      |-initRoutes.js
        import authRoutes from './authRoutes.js';
        import userRoutes from './userRoutes.js';
        import propertyRoutes from './propertyRoutes.js';
        import transactionRoutes from './transactionRoutes.js';
        import adminRoutes from './adminRoutes.js';
        import agentRoutes from './agentRoutes.js';
        import faqRoutes from './faqRoutes.js';
        
        
        const initRoutes = (app) => {
          app.use('/api/auth', authRoutes);             // Authentication routes
          app.use('/api/users', userRoutes);            // User-related routes
          app.use('/api/properties', propertyRoutes);   // Property routes
          app.use('/api/transactions', transactionRoutes); // Transaction routes (buy, rent)
          app.use('/api/admin', adminRoutes);           // Admin-specific routes
          app.use('/api/agents', agentRoutes);          // Agent-specific routes
          app.use('/api/faqs', faqRoutes);
        };
        
        export default initRoutes;
        
      |-adminRoutes.js
        /**
         * This file contains the routes for admin management in the system.
         */
        
        import express from 'express';
        import {
          getAllAdmins,
          getAdminById,
          updateAdmin,
          deleteAdmin,
        } from '../controllers/admin/adminController.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';  // JWT auth middleware for protected routes
        import { checkIsAdmin,checkIsAdminSelfOrSuperAdmin} from '../middleware/auth/roleMiddleware.js';
        import { validateAdminUpdateFields } from '../middleware/validation/adminUpdateValidation.js';
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js';
        import {validateObjectId} from '../middleware/validation/validateObjectId.js';
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Admin Routes
         * ============================
         */
        
        // Admin Management
        
        // Get all admins (admin-only route)
        router.get('/', 
          authenticateJWT,
          checkIsAdmin, 
          getAllAdmins);
        
        // Get a specific admin by ID (admin-only route)
        router.get('/:id', 
          authenticateJWT,
          validateObjectId,
          checkIsAdmin, 
          getAdminById);
        
        // Update admin information (admin-only route)
        router.put('/:id',
          authenticateJWT,
          validateObjectId,  // Add this new middleware
          checkIsAdminSelfOrSuperAdmin,
          validateAdminUpdateFields,
          handleValidationErrors,
          updateAdmin
        );
        
        // Delete an admin (super admin only)
        router.delete('/:id',
          authenticateJWT,
          validateObjectId,
          checkIsAdminSelfOrSuperAdmin,
          deleteAdmin);
        
        export default router;
      |-propertyRoutes.js
        import express from 'express';
        import {
          createProperty,
          getPropertyById,
          updateProperty,
          deleteProperty,
          getPropertiesByFilter,
          addPropertyImage,
          removePropertyImage,
          addPropertyAmenity,
          removePropertyAmenity,
        } from '../controllers/property/propertiesController.js';
        import { validateObjectId } from '../middleware/validation/validateObjectId.js';
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        import { validatePropertyFields } from '../middleware/validation/propertyValidation.js';
        import { validateUpdatePropertyFields } from '../middleware/validation/propertyUpdateValidation.js';
        import { validateFilterQuery } from '../middleware/validation/propertyQueryValidation.js';
        import { validateImageUrl } from '../middleware/validation/validateImageUrl.js';
        import { validateAmenity } from '../middleware/validation/amenityValidation.js';
        
        import { 
          checkRoleToCreateProperty,
          checkIsAdminOrOwnerOrAgent
         } from '../middleware/auth/roleMiddleware.js';  // Role-based access control
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js'; // Make sure this is imported correctly
        
        const router = express.Router();
        
        /**
         * ============================
         * Property Routes
         * ============================
         */
        
        // Create a new property (authenticated users only)
        router.post(
          '/', 
          authenticateJWT,
          checkRoleToCreateProperty, 
          validatePropertyFields,
          handleValidationErrors,   
          createProperty
        );
        
        // Get a specific property by ID (public)
        router.get(
          '/:id',
          validateObjectId, 
          getPropertyById
        );
        
        // Update property information (admin, agent or the property owner)
        router.put(
          '/:id', 
          authenticateJWT, 
          validateObjectId, 
          checkIsAdminOrOwnerOrAgent,
          validateUpdatePropertyFields,
          handleValidationErrors,
          updateProperty
        );
        
        // Delete a property (admin or the property owner)
        router.delete(
          '/:id', 
          authenticateJWT, 
          validateObjectId, 
          checkIsAdminOrOwnerOrAgent, 
          deleteProperty
        );
        
        // Route for fetching properties (all or filtered)
        router.get(
          '/', 
          validateFilterQuery,  // Optional: Validates the filters provided
          handleValidationErrors, 
          getPropertiesByFilter  // Fetch properties based on filters or return all properties
        );
        
        // Add and Remove Image Routes (images related)
        router.put(
          '/:id/images', 
          authenticateJWT,
           validateObjectId, 
           checkIsAdminOrOwnerOrAgent, 
           validateImageUrl,
           handleValidationErrors, 
           addPropertyImage
        );
        
        router.put(
          '/:id/images/remove', 
          authenticateJWT, 
          validateObjectId, 
          checkIsAdminOrOwnerOrAgent,
          validateImageUrl, 
          handleValidationErrors, 
          removePropertyImage
        );
        
        // Add an amenity to a property
        router.put(
          '/:id/amenities',
          authenticateJWT,
          validateObjectId,
          checkIsAdminOrOwnerOrAgent,
          validateAmenity,
          handleValidationErrors,
          addPropertyAmenity
        );
        
        // Remove an amenity from a property
        router.put(
          '/:id/amenities/remove',
          authenticateJWT,
          validateObjectId,
          checkIsAdminOrOwnerOrAgent,
          validateAmenity,
          handleValidationErrors,
          removePropertyAmenity
        );
        
        export default router;
      |-authRoutes.js
        import express from 'express';
        import passport from 'passport';
        import '../config/passport.js'; // Ensure Passport configuration is loaded
        import {
          googleOAuthSignupCallback,
          googleOAuthSigninCallback
        } from '../controllers/auth/googleOAuthController.js';
        import {
          checkUsername,
          checkEmail,
        } from '../controllers/validation/validationController.js'; // Controllers for username and email checks
        import {
          createUser,
          authenticateUser,
          logoutUser,
          // forgotPassword,
          // resetPassword,
          // verifyToken
        } from '../controllers/auth/userAuthController.js';
        import { validateUserFields } from '../middleware/validation/userValidation.js';
        
        import authenticateJWT from '../middleware/auth/authMiddleware.js';
        
        import {
          createAdmin,
          loginAdmin,
        } from '../controllers/auth/adminAuthController.js';
        import { validateAdminFields } from '../middleware/validation/adminValidation.js';
        import {checkIsSuperAdmin} from '../middleware/auth/roleMiddleware.js';
        
        import {
          createAgent,
          loginAgent,
        } from '../controllers/auth/agentAuthController.js';
        import { handleValidationErrors } from '../middleware/common/handleValidationErrors.js';
        import { validateAgentFields } from '../middleware/validation/agentValidation.js';  // Input validation for agents
        
        
        
        const router = express.Router();
        
        /**
         * ============================
         * Google OAuth Routes
         * ============================
         */
        
        // Google OAuth Sign-Up Route
        router.get(
          '/google/signup', 
          passport.authenticate('google-signup'));
        
        // Google OAuth Sign-In Route
        router.get(
          '/google/signin', 
          passport.authenticate('google-signin')
        );
        
        // Google OAuth Callback for Sign Up
        router.get(
          '/google/signup/callback',
          passport.authenticate('google-signup', { session: false, failureRedirect: `${process.env.CLIENT_URI}/signup` }),
          googleOAuthSignupCallback
        );
        
        // Google OAuth Callback for Sign In
        router.get(
          '/google/signin/callback',
          passport.authenticate('google-signin', { session: false, failureRedirect: `${process.env.CLIENT_URI}/signin` }),
          googleOAuthSigninCallback
        );
        
        /**
         * ============================
         * Local Authentication Routes
         * ============================
         */
        
        // Sign-up route with validation
        router.post(
          '/signup', 
          validateUserFields,
          handleValidationErrors,  
          createUser
        );
        
        // Check if username is available (with validation middleware)
        router.get(
          '/check-username/:username', 
          checkUsername);
        
        // Check if email is already registered (with validation middleware)
        router.get(
          '/check-email/:email', 
          checkEmail);
        
        
        // User login with email and password (Local Authentication)
        router.post(
          '/signin', 
          authenticateUser
        );
        
        // Logout route (JWT-based, invalidates JWT on the client-side)
        router.post(
          '/logout', 
          logoutUser
        );
        
        /* 
        // Forgot Password (Send reset password link)
        router.post('/forgot-password', forgotPassword);
        
        // Reset Password (Handle reset with token)
        router.post('/reset-password', resetPassword);
        
        // Verify if the JWT token is still valid
        router.get('/verify-token', authenticateJWT, verifyToken);
        */
        
        /**
         * ============================
         * Admin Authentication Routes
         * ============================
         */
        
        // Create a new admin (super admin only)
        router.post(
          '/admins/signup',
          authenticateJWT, 
          checkIsSuperAdmin,
          validateAdminFields,
          handleValidationErrors,  
          createAdmin
        );
        
        // Admin Login
        router.post(
          '/admins/login',
           loginAdmin
        );
        
        /**
         * ============================
         * Agent Authentication Routes
         * ============================
         */
        
        // Register a new agent (public route)
        router.post(
          '/agents/signup',
          validateAgentFields,
          handleValidationErrors,  
          createAgent
        );
        
        // Agent login route (public)
        router.post(
          '/agents/login',
          loginAgent
        );
        
        export default router;
      |-faqRoutes.js
        import express from 'express';
        import { getAllFaqs, createFaq, updateFaq, deleteFaq } from '../controllers/faq/faqController.js';
        
        const router = express.Router();
        
        // Get All FAQS (GET /api/faqs)
        router.get('/', getAllFaqs);
        
        // Create a new FAQ (POST /api/faqs)
        router.post('/', createFaq);
        
        // Update an existing FAQ (PUT /api/faqs/:id)
        router.put('/:id', updateFaq);
        
        // Delete an existing FAQ (DELETE /api/faqs/:id)
        router.delete('/:id', deleteFaq);
        
        export default router;
        
    |-middleware/
      |-error/
        |-test.js
          class CustomError extends Error {
              constructor(message, statusCode, errors = []) {
                  super(message);
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.name = this.constructor.name;
              }
          
              toJSON() {
                  return {
                      success: false,
                      error: {
                          message: this.message,
                          errors: this.errors.length > 0 ? this.errors : undefined,
                      },
                      statusCode: this.statusCode,
                  };
              }
          }
          
          const eror = new CustomError("Not found", 404)
          console.log(eror.toJSON())
        |-globalErrorMiddleware.js
          import { ValidationError, BusinessLogicError, NotFoundError, ServerError, CustomError } from '../../utils/customErrors.js';
          
          /**
           * Global error handler middleware
           */
          const errorHandler = (err, req, res, next) => {
              let errorResponse;
          
              // Check if it's one of our custom errors
              if (err instanceof CustomError) {
                  errorResponse = err.toJSON();  // Use the custom error's toJSON method
              } else {
                  // If it's an unknown error, wrap it in a generic ServerError
                  const serverError = new ServerError('An unexpected error occurred');
                  errorResponse = serverError.toJSON();
          
                  // Optionally, log the original error in case it's unexpected
                  console.error('Unexpected Error:', err);
              }
          
              // Log stack trace in development mode for easier debugging
              if (process.env.NODE_ENV === 'development') {
                  console.error('Error Stack:', err.stack);
                  errorResponse.error.stack = err.stack;  // Include the stack trace in development mode
              }
          
              // Ensure statusCode is set in case something went wrong
              const statusCode = errorResponse.statusCode || 500;
          
              // Send the formatted error response to the client
              return res.status(statusCode).json(errorResponse);
          };
          
          export default errorHandler;
      |-common/
        |-checkRequiredFields.js
          import { formatError } from '../../utils/errorFormatter.js';
          
          /**
           * @desc Middleware to check for required fields in different request locations (body, query, params).
           * @param {Object} requiredFields - An object that specifies required fields and where to look for them (body, query, params).
           * @returns {Function} Middleware function
           */
          const checkRequiredFields = (requiredFields) => {
            return (req, res, next) => {
              const errors = [];
          
              // Loop through the specified required fields
              for (const [location, fields] of Object.entries(requiredFields)) {
                fields.forEach(field => {
                  if (!req[location] || !req[location][field]) {
                    errors.push({
                      field,
                      message: `${field} is required in ${location}.`,  // Dynamic error message
                    });
                  }
                });
              }
          
              // If errors are found, return the formatted error response
              if (errors.length > 0) {
                return next(formatError('Required fields missing', errors, 400));
              }
          
              // No errors, move to the next middleware
              next();
            };
          };
          
          export default checkRequiredFields;
        |-checkEmptyBody.js
          import { formatError } from '../../utils/errorFormatter.js';
          
          /**
           * @desc Middleware to check if the request body is empty and format the error using `errorFormatter`.
           *       This is reusable across different routes and contexts.
           * @param {String} message - Custom error message to return when the body is empty.
           * @returns {Function} - Middleware function to handle the empty body check.
           */
          const checkEmptyBody = (message = 'Request body is empty. Please provide valid data.') => {
            return (req, res, next) => {
              // Check if the request body is empty
              if (Object.keys(req.body).length === 0) {
                // Format and return the error
                const error = formatError(message, [], 400);  // Use `formatError` with the custom message
                return next(error);  // Pass the error to the global error handler
              }
              next();  // Proceed to the next middleware if the body isn't empty
            };
          };
          
          export default checkEmptyBody;
        |-handleValidationErrors.js
          import mongoose from 'mongoose';
          
          import { validationResult } from 'express-validator';
          import { ValidationError } from '../../utils/customErrors.js';  // Use your custom ValidationError
          
          /**
           * Middleware to handle validation errors from express-validator.
           */
          export const handleValidationErrors = (req, res, next) => {
            const errors = validationResult(req);
          
            if (!errors.isEmpty()) {
              // Format validation errors: Each error includes only the field and its message
              const formattedErrors = errors.array().map(err => ({
                field: err.param,  // Field name (like "email")
                message: err.msg,  // Error message (like "Please provide a valid email address")
              }));
          
              // Pass the formatted errors to the global error handler using custom ValidationError
              return next(new ValidationError('Validation failed due to invalid inputs.', formattedErrors));
            }
          
            // Proceed if no validation errors
            next();
          };
      |-auth/
        |-authMiddleware.js
          import jwt from 'jsonwebtoken';
          import { UnauthorizedError, ForbiddenError } from '../../utils/customErrors.js';  // Import your custom error classes
          
          /**
           * @desc Authenticates the user using a JWT token.
           * @param {Object} req - The request object.
           * @param {Object} res - The response object.
           * @param {Function} next - The next middleware function.
           * @returns {void} - Calls the next middleware if authentication is successful.
           * @throws {UnauthorizedError} - Throws a 401 error if the token is missing.
           * @throws {ForbiddenError} - Throws a 403 error if the token is invalid or expired.
           */
          const authenticateJWT = (req, res, next) => {
            // Check if the token is sent in the Authorization header
            let token = req.header('Authorization')?.replace('Bearer ', '');
          
            // If not, check if the token is stored in a cookie
            if (!token) {
              token = req.cookies?.token;
            }
          
            // If no token is found, throw an UnauthorizedError
            if (!token) {
              return next(new UnauthorizedError('Unauthorized access. Token is missing, please log in.'));
            }
          
            try {
              // Verify the token using the secret key
              const decoded = jwt.verify(token, process.env.JWT_SECRET);
              req.user = decoded;  // Attach the decoded user info to `req.user`
              next();  // Continue to the next middleware/route handler
            } catch (error) {
              // If the token is invalid or expired, throw a ForbiddenError
              return next(new ForbiddenError('Invalid token or session expired. Please log in again.'));
            }
          };
          
          export default authenticateJWT;
        |-roleMiddleware.js
          import { 
            ForbiddenError,
            NotFoundError 
          } from '../../utils/customErrors.js';
          import Property from '../../models/Property.js';
          
          /**
           * @desc - Check if the user is an admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is not an admin
           */
          export const checkIsAdmin = (req, res, next) => {
            // Check if the user is authenticated and has the role 'admin' or 'super-admin'
            if (req.user && (req.user.role === 'admin' || req.user.role === 'super-admin')) {
              return next();  // Proceed if the user is an admin or super-admin
            }
          
            // If the user is not an admin, throw a ForbiddenError
            return next(new ForbiddenError('Access forbidden: Admins only.'));
          };
          
          /**
           * @desc - Check if the user is a super admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is not a super admin
           */
          export const checkIsSuperAdmin = (req, res, next) => {
            // Check if the user is authenticated and has the role 'super-admin'
            if (req.user && req.user.role === 'super-admin') {
              return next();  // Proceed if the user is a super-admin
            }
          
            // If the user is not a super-admin, throw a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * @desc - Check if the user is either the admin they are modifying or a super admin
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is neither the admin themselves nor a super admin
           */
          export const checkIsAdminSelfOrSuperAdmin = (req, res, next) => {
            const { id } = req.params;  // The ID of the admin being accessed (from URL param)
            const { role, id: userId } = req.user;  // The role and ID of the logged-in user (from JWT payload)
          
            // Allow access if the user is a super-admin
            if (role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is modifying their own account
            if (userId === id) {
              return next();
            }
          
            // If neither, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * @desc - Middleware to check if the user is either an admin or the agent themselves
           * @param {Object} req - The request object
           * @param {Object} res - The response object
           * @param {Function} next - The next middleware function
           * @returns {void}
           * @throws {ForbiddenError} - Throws 403 Forbidden if the user is neither the admin nor the agent
           */
          export const checkIsAgentSelfOrAdmin = (req, res, next) => {
            const { id } = req.params;  // The agent ID being accessed from the URL
            const { role, id: userId } = req.user;  // The logged-in user's role and ID from JWT payload
          
            // Allow access if the user is an admin (admin or super-admin)
            if (role === 'admin' || role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is updating their own account
            if (userId === id) {
              return next();
            }
          
            // If neither condition is met, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          /**
           * Middleware to check if the user is either an admin or the user themselves.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express next middleware function.
           * @returns {void} - Calls next if authorized, throws ForbiddenError otherwise.
           */
          export const checkIsUserSelfOrAdmin = (req, res, next) => {
            const { id } = req.params;  // The user ID being accessed from the URL
            const { role, id: userId } = req.user;  // The logged-in user's role and ID from JWT payload
          
            // Allow access if the user is an admin
            if (role === 'admin' || role === 'super-admin') {
              return next();
            }
          
            // Allow access if the user is updating their own account
            if (userId === id) {
              return next();
            }
          
            // If neither condition is met, deny access with a ForbiddenError
            return next(new ForbiddenError('Access denied: You do not have the required permissions to perform this action.'));
          };
          
          // Middleware to check if the user is authorized to create a property
          export const checkRoleToCreateProperty = (req, res, next) => {
            const { role } = req.user;
          
            // Allow access to users with any of these roles
            const allowedRoles = ['user', 'agent', 'admin', 'super-admin'];
          
            if (req.user && allowedRoles.includes(role)) {
              return next();
            }
          
            // If the user does not have the right role, return 403 Forbidden
            return res.status(403).json({ message: 'Access denied: You do not have permission to create a property.' });
          };
          
          /**
           * Middleware to check if the user is an admin, the property owner (user who created it), or the agent managing the property.
           * @param {Object} req - Express request object.
           * @param {Object} res - Express response object.
           * @param {Function} next - Express next middleware function.
           * @returns {void} - Calls next if authorized, throws ForbiddenError otherwise.
           */
          export const checkIsAdminOrOwnerOrAgent = async (req, res, next) => {
            const { id: propertyId } = req.params;
            const { role, id: userId } = req.user;  // The logged-in user's role and ID from JWT payload
          
            try {
              // If the user is an admin or super-admin, allow the update
              if (role === 'admin' || role === 'super-admin') {
                return next();
              }
          
              const property = await Property.findById(propertyId);
          
              if (!property) {
                return next(new NotFoundError(`Property with ID ${propertyId} not found`));
              }
           
              console.log(property.userId, userId);
              // Check if `userId` is set on the property and compare with the logged-in user
              if (property.userId && property.userId.toString() === userId.toString()) {
                return next();
              }
          
              // Check if `agentId` is set on the property and compare with the logged-in user
              if (property.agentId && property.agentId.toString() === userId.toString()) {
                return next();
              }
          
              // If none of the conditions are met, deny access
              return next(new ForbiddenError('Access denied: You are not authorized to modify this property.'));
            } catch (error) {
              return next(error); // Pass error to the global error handler
            }
          };
        |-globalMiddlewares.js
          import cors from 'cors';
          import express from 'express';
          import morgan from 'morgan';
          import helmet from 'helmet';
          import compression from 'compression';
          import rateLimit from 'express-rate-limit';
          
          // Apply all global middlewares
          const applyGlobalMiddleware = (app) => {
            // Body parsers
            app.use(express.json()); // Parse JSON requests
            app.use(express.urlencoded({ extended: true })); // Parse URL-encoded data
          
            // CORS middleware
            app.use(cors({
              origin: process.env.CLIENT_URI, // Your frontend URL
              credentials: true // Allow credentials (cookies, authorization headers, etc.)
            }));
          
            // Security middleware
            app.use(helmet()); // Secure app by setting various HTTP headers
          
            // Logging middleware
            app.use(morgan('dev')); // Log HTTP requests in the console (for dev environments)
          
            // Compression middleware
            app.use(compression()); // Compress response bodies for performance
          
            // Rate limiting middleware (optional but recommended)
            const limiter = rateLimit({
              windowMs: 15 * 60 * 1000, // 15 minutes
              max: 100, // Limit each IP to 100 requests per window
            });
            app.use(limiter); // Apply rate limiter to all requests
          };
          
          export default applyGlobalMiddleware;
      |-validation/
        |-userUpdateValidation.js
          import { body } from 'express-validator';
          import mongoose from 'mongoose';
          import User from '../../models/User.js';
          
          /**
           * @desc Middleware array that validates the fields for User updates.
           *       Fields are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling user requests.
           */
          export const validateUpdateUserFields = [
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            body('username')
              .optional()
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value, { req }) => {
                const user = await User.findOne({ username: value, _id: { $ne: req.params.id } });
                if (user) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value, { req }) => {
                const user = await User.findOne({ email: value, _id: { $ne: req.params.id } });
                if (user) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            body('avatar')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            body('role')
              .optional()
              .isIn(['user']).withMessage('Invalid role. Only "user" is allowed.'),
          
            body('accountStatus')
              .optional()
              .isIn(['active', 'pending', 'suspended', 'deactivated']).withMessage('Invalid account status.'),
          
            body('isEmailVerified')
              .optional()
              .isBoolean().withMessage('Email verification status must be true or false.'),
          
            body('lastLogin')
              .optional()
              .isISO8601().withMessage('Last login must be a valid date.'),
          
            body('failedLoginAttempts')
              .optional()
              .isInt({ min: 0 }).withMessage('Failed login attempts must be a positive integer.'),
          
            body('lockUntil')
              .optional()
              .isISO8601().withMessage('Lock until must be a valid date.'),
          
            // Properties validation (optional)
            body('properties')
            .optional()
            .isArray().withMessage('Properties must be an array of ObjectIds.')
            .custom((value) => {
              if (!value.every(mongoose.Types.ObjectId.isValid)) {
                throw new Error('Invalid property IDs.');
              }
              return true;
            }),
          
            body('isUsernameCustomized')
              .optional()
              .isBoolean().withMessage('isUsernameCustomized must be a boolean value (true or false).'),
          ];
          
        |-validateImageUrl.js
          import { body } from 'express-validator';
          
          export const validateImageUrl = [
            body('imageUrl')
              .notEmpty().withMessage('Image URL is required.')
              .isURL().withMessage('Image must be a valid URL.')
              .matches(/\.(jpg|jpeg|png|webp)$/).withMessage('Image must be a valid format: jpg, jpeg, png, or webp.'),
          ];
        |-userValidation.js
          import { body } from 'express-validator';
          import {accountStatusEnum } from '../../models/User.js'; // Importing enums for validation
          
          export const validateUserFields = [
            // Validate first name
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ min: 2, max: 30 }).withMessage('First name must be between 2 and 30 characters long.')
              .matches(/^[a-zA-Z]+$/).withMessage('First name can only contain letters.'),
          
            // Validate last name
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ min: 2, max: 30 }).withMessage('Last name must be between 2 and 30 characters long.')
              .matches(/^[a-zA-Z]+$/).withMessage('Last name can only contain letters.'),
          
            // Validate username
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 3, max: 20 }).withMessage('Username must be between 3 and 20 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain letters, numbers, and underscores.'),
          
            // Validate email
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.')
              .normalizeEmail(), // Normalize email address to lowercase
          
            // Validate password
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,}$/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Validate role (optional, default role will be 'user')
            body('role')
            .optional()
            .isIn(['user']).withMessage('Role must be: user'),
          
            // Validate account status (optional, default is 'active')
            body('accountStatus')
              .optional()
              .isIn(accountStatusEnum).withMessage(`Account status must be one of: ${accountStatusEnum.join(', ')}`),
          
            // Ensure isEmailVerified is a boolean (optional)
            body('isEmailVerified')
              .optional()
              .isBoolean().withMessage('Email verification status must be a boolean value (true or false).'),
          
            // Ensure lastLogin is a valid date (optional)
            body('lastLogin')
              .optional()
              .isISO8601().withMessage('Last login must be a valid date.'),
          
            // Validate failedLoginAttempts (optional, should be an integer)
            body('failedLoginAttempts')
              .optional()
              .isInt({ min: 0 }).withMessage('Failed login attempts must be a positive integer.'),
          
            // Validate lockUntil (optional, should be a valid date)
            body('lockUntil')
              .optional()
              .isISO8601().withMessage('Lock until must be a valid date.'),
            
            // Validate avatar (optional)
            body('avatar')
              .optional()
              .isURL().withMessage('Avatar must be a valid URL.')
          ];
        |-propertyQueryValidation.js
          import { query } from 'express-validator';
          
          /**
           * @desc Middleware array that validates the query parameters for filtering properties.
           *       Filters are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling property filter requests.
           */
          export const validateFilterQuery = [
            query('title')
              .optional()
              .isLength({ max: 100 }).withMessage('Title cannot exceed 100 characters.'),
          
            query('propertyType')
              .optional()
              .isIn(['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'])
              .withMessage('Property type must be one of: Apartment, House, Condo, Land, Villa, Office, Studio.'),
          
            query('priceMin')
              .optional()
              .isInt({ min: 0 }).withMessage('Minimum price must be a positive whole number (integer).'),
          
            query('priceMax')
              .optional()
              .isInt({ min: 0 }).withMessage('Maximum price must be a positive whole number (integer).'),
          
            query('status')
              .optional()
              .isIn(['Available', 'Sold', 'Rented', 'Pending'])
              .withMessage('Status must be one of: Available, Sold, Rented, Pending.'),
          
            query('sizeMin')
              .optional()
              .isFloat({ min: 0 }).withMessage('Minimum size must be a positive number.'),
          
            query('sizeMax')
              .optional()
              .isFloat({ min: 0 }).withMessage('Maximum size must be a positive number.'),
          
            query('bedrooms')
              .optional()
              .isInt({ min: 1 }).withMessage('Bedrooms must be at least 1.'),
          
            query('bathrooms')
              .optional()
              .isInt({ min: 1 }).withMessage('Bathrooms must be at least 1.'),
          
            query('offerType')
              .optional()
              .isIn(['Sale', 'Rent'])
              .withMessage('Offer type must be either Sale or Rent.'),
          
            query('yearBuiltMin')
              .optional()
              .isInt({ min: 1800 }).withMessage('Minimum year built must be after 1800.'),
          
            query('yearBuiltMax')
              .optional()
              .isInt({ max: new Date().getFullYear() })
              .withMessage(`Maximum year built must be before ${new Date().getFullYear()}.`),
          
            query('availableFrom')
              .optional()
              .isISO8601().withMessage('Available date must be a valid ISO 8601 date.'),
          
            query('address.city')
              .optional()
              .isString().withMessage('City must be a valid string.'),
          
            query('address.state')
              .optional()
              .isString().withMessage('State must be a valid string.'),
          
            query('address.zipCode')
              .optional()
              .matches(/^\d{5}(-\d{4})?$/).withMessage('Please provide a valid zip code.'),
          
            query('coordinates.lat')
              .optional()
              .isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90 degrees.'),
          
            query('coordinates.lng')
              .optional()
              .isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180 degrees.')
          ];
        |-amenityValidation.js
          import { body } from 'express-validator';
          
          export const validateAmenity = [
            body('amenity')
              .notEmpty().withMessage('Amenity is required.')
              .isString().withMessage('Amenity must be a valid string.')
          ];
        |-validateObjectId.js
          import { isValidObjectId } from 'mongoose';
          import { ValidationError } from '../../utils/customErrors.js';
          
          export const validateObjectId = (req, res, next) => {
            const { id } = req.params;
            if (!isValidObjectId(id)) {
              return next(new ValidationError('Invalid ID'));
            }
            next();
          };
        |-propertyValidation.js
          import { body } from 'express-validator';
          
          export const validatePropertyFields = [
            body('title')
              .notEmpty().withMessage('Property title is required.')
              .isLength({ max: 100 }).withMessage('Title cannot exceed 100 characters.'),
          
            body('description')
              .notEmpty().withMessage('Description is required.')
              .isLength({ max: 500 }).withMessage('Description cannot exceed 500 characters.'),
          
            body('propertyType')
              .notEmpty().withMessage('Property type is required.')
              .isIn(['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'])
              .withMessage('Property type must be one of: Apartment, House, Condo, Land, Villa, Office, Studio.'),
          
            body('price')
              .notEmpty().withMessage('Price is required.')
              .isInt({ min: 0 }).withMessage('Price must be a positive whole number (integer).'),
          
            body('status')
              .optional()
              .isIn(['Available', 'Sold', 'Rented', 'Pending'])
              .withMessage('Status must be one of: Available, Sold, Rented, Pending.'),
          
            body('size')
              .notEmpty().withMessage('Property size is required.')
              .isFloat({ min: 0 }).withMessage('Size must be a positive number.'),
          
            body('bedrooms')
              .notEmpty().withMessage('Number of bedrooms is required.')
              .isInt({ min: 1 }).withMessage('Bedrooms must be at least 1.'),
          
            body('bathrooms')
              .notEmpty().withMessage('Number of bathrooms is required.')
              .isInt({ min: 1 }).withMessage('Bathrooms must be at least 1.'),
          
            body('rooms')
              .notEmpty().withMessage('Number of rooms is required.')
              .isInt({ min: 1 }).withMessage('Rooms must be at least 1.'),
          
            body('offerType')
              .notEmpty().withMessage('Offer type is required.')
              .isIn(['Sale', 'Rent'])
              .withMessage('Offer type must be either Sale or Rent.'),
          
            body('yearBuilt')
              .optional()
              .isInt({ min: 1800, max: new Date().getFullYear() })
              .withMessage(`Year built must be between 1800 and ${new Date().getFullYear()}.`),
          
            body('availableFrom')
              .optional()
              .isISO8601().withMessage('Available date must be a valid ISO 8601 date.'),
          
            body('address.street')
              .notEmpty().withMessage('Street address is required.')
              .isLength({ max: 100 }).withMessage('Street address cannot exceed 100 characters.'),
          
            body('address.city')
              .notEmpty().withMessage('City is required.'),
          
            body('address.state')
              .notEmpty().withMessage('State is required.'),
          
            body('address.zipCode')
              .notEmpty().withMessage('Zip code is required.')
              .matches(/^\d{5}(-\d{4})?$/).withMessage('Please provide a valid zip code.'),
          
            body('address.country')
              .optional().default('Morocco')
              .isString().withMessage('Country must be a valid string.'),
          
            body('images.*')
              .optional()
              .isURL().withMessage('Each image must be a valid URL (jpg, jpeg, png, or webp).')
              .matches(/\.(jpg|jpeg|png|webp)$/).withMessage('Image must be a valid format: jpg, jpeg, png, or webp.'),
          
            body('amenities')
              .optional()
              .isArray().withMessage('Amenities must be an array of strings.')
              .custom((amenities) => {
                return amenities.every(amenity => typeof amenity === 'string');
              }).withMessage('All amenities must be valid strings.'),
          
            body('isFeatured')
              .optional()
              .isBoolean().withMessage('isFeatured must be a boolean value.'),
          
            // Coordinates validation, made optional by removing `.notEmpty()`
            body('coordinates.lat')
              .optional()
              .isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90 degrees.'),
          
            body('coordinates.lng')
              .optional()
              .isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180 degrees.')
          ];
        |-validateObjectIdBody.js
          import { body } from 'express-validator';
          
          export const validatePropertyIdBody = [
            body('propertyId')
              .notEmpty().withMessage('Property ID is required.')
              .isMongoId().withMessage('Property ID must be a valid MongoDB ObjectId.'),
          ];
        |-adminValidation.js
          /**
           * This file contains middleware functions that validate the fields for creating a new Admin.
           */
          
          import { body } from 'express-validator';
          
          /**
           * @desc Middleware array that validates the fields for creating a new Admin.
           * @returns {Array} An array of validation rules to be applied before handling admin creation requests.
           */
          export const validateAdminFields = [
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.'),
          
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.'),
          
            body('phoneNumber')
              .notEmpty().withMessage('Phone number is required.')
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number in E.164 format (e.g., +1234567890).'),
          
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            body('role')
              .optional()
              .isIn(['admin', 'super-admin']).withMessage('Role must be either "admin" or "super-admin".'),
          
            body('permissions')
              .optional()
              .isArray().withMessage('Permissions must be an array.')
              .custom((permissions) => {
                const validPermissions = ['manage_users', 'manage_agents', 'view_reports', 'manage_admins'];
                for (const permission of permissions) {
                  if (!validPermissions.includes(permission)) {
                    throw new Error(`Invalid permission: ${permission}.`);
                  }
                }
                return true;
              }),
          
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL (jpg, jpeg, png, or webp).')
          ];
        |-validateUserObjectId.js
          import { isValidObjectId } from 'mongoose';
          import { ValidationError } from '../../utils/customErrors.js';
          
          export const validateUserObjectIdParam = (req, res, next) => {
            const { userId } = req.params;  // Make sure to reference the correct param (userId)
            if (!isValidObjectId(userId)) {
              return next(new ValidationError('Invalid User ID'));  // Customize the error message
            }
            next();
          };
        |-agentUpdateValidation.js
          import { body } from 'express-validator';
          import mongoose from 'mongoose';
          import Agent from '../../models/Agent.js';
          
          /**
           * @desc Middleware array that validates the fields for Agent updates.
           *       Fields are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling agent requests.
           */
          export const validateUpdateAgentFields = [
            // First name validation
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            // Last name validation
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            // Username validation (must be unique)
            body('username')
              .optional()
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ username: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            // Email validation (must be unique)
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ email: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            // Phone number validation (must be unique, E.164 format)
            body('phoneNumber')
              .optional()
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number.')
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ phoneNumber: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('Phone number already exists.');
                }
              }),
          
            // Agency name validation
            body('agency')
              .optional()
              .isLength({ max: 100 }).withMessage('Agency name cannot exceed 100 characters.'),
          
            // Bio validation (optional)
            body('bio')
              .optional()
              .isLength({ max: 1000 }).withMessage('Bio cannot exceed 1000 characters.'),
          
            // License number validation (must be unique)
            body('licenseNumber')
              .optional()
              .custom(async (value, { req }) => {
                const agent = await Agent.findOne({ licenseNumber: value, _id: { $ne: req.params.id } });
                if (agent) {
                  return Promise.reject('License number already exists.');
                }
              }),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            // Password validation (optional)
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Properties validation (optional)
            body('properties')
              .optional()
              .isArray().withMessage('Properties must be an array of ObjectIds.')
              .custom((value) => {
                if (!value.every(mongoose.Types.ObjectId.isValid)) {
                  throw new Error('Invalid property IDs.');
                }
                return true;
              }),
          
            // Social media links validation (optional)
            body('socialMediaLinks.facebook')
              .optional()
              .matches(/^https?:\/\/(www\.)?facebook.com\/.+$/).withMessage('Please provide a valid Facebook URL.'),
          
            body('socialMediaLinks.linkedin')
              .optional()
              .matches(/^https?:\/\/(www\.)?linkedin.com\/.+$/).withMessage('Please provide a valid LinkedIn URL.'),
          
            body('socialMediaLinks.twitter')
              .optional()
              .matches(/^https?:\/\/(www\.)?twitter.com\/.+$/).withMessage('Please provide a valid Twitter URL.'),
          
            // Availability validation (optional)
            body('availability')
              .optional()
              .isBoolean().withMessage('Availability must be true or false.'),
          ];
        |-adminUpdateValidation.js
          /**
           * This file contains middleware functions that validate the fields for updating an admin.
           */
          
          import { body } from 'express-validator';
          
          /**
           * @desc Middleware array that validates the fields for Admin updates (allows partial updates).
           * 
           * @returns {Array} An array of validation rules to be applied before handling admin update requests.
           */
          export const validateAdminUpdateFields = [
            // First name validation (optional for update)
            body('firstName')
              .optional()
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain letters.'),
          
            // Last name validation (optional for update)
            body('lastName')
              .optional()
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain letters.'),
          
            // Email validation (optional for update)
            body('email')
              .optional()
              .isEmail().withMessage('Please provide a valid email address.'),
          
            // Phone number validation (optional for update)
            body('phoneNumber')
              .optional()
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number in E.164 format (e.g., +1234567890).'),
          
            // Password validation (optional for update)
            body('password')
              .optional()
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,}$/)
              .withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Role validation should not be allowed unless you're a super admin
            body('role')
              .optional()
              .custom((value, { req }) => {
                if (req.user.role !== 'super-admin') {
                  throw new Error('Only super-admin can update role.');
                }
                return true;
              }),
          
              body('permissions')
              .optional()
              .isArray().withMessage('Permissions must be an array.')
              .custom((permissions, { req }) => {
                const validPermissions = ['manage_users', 'manage_agents', 'view_reports', 'manage_admins'];
          
                // Ensure all provided permissions are valid
                const allValid = permissions.every(permission => validPermissions.includes(permission));
          
                if (!allValid) {
                  throw new Error('Invalid permission. Valid options are: manage_users, manage_agents, view_reports, manage_admins.');
                }
          
                return true;
              })
              .withMessage('Permissions must only contain valid values: manage_users, manage_agents, view_reports, manage_admins.'),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/)
              .withMessage('Please provide a valid image URL (jpg, jpeg, png, or webp).')
          ];
        |-agentValidation.js
          import { body } from 'express-validator';
          import Agent from '../../models/Agent.js';
          import mongoose from 'mongoose';  // This is necessary for ObjectId validation
          
          /**
           * @desc Middleware array that validates the fields for creating an Agent.
           * @returns {Array} An array of validation rules to be applied before handling agent creation requests.
           */
          export const validateAgentFields = [
            // First name validation
            body('firstName')
              .notEmpty().withMessage('First name is required.')
              .isLength({ max: 50 }).withMessage('First name cannot exceed 50 characters.')
              .isAlpha().withMessage('First name must only contain alphabetic characters.'),
          
            // Last name validation
            body('lastName')
              .notEmpty().withMessage('Last name is required.')
              .isLength({ max: 50 }).withMessage('Last name cannot exceed 50 characters.')
              .isAlpha().withMessage('Last name must only contain alphabetic characters.'),
          
            // Username validation (must be unique)
            body('username')
              .notEmpty().withMessage('Username is required.')
              .isLength({ min: 4, max: 30 }).withMessage('Username must be between 4 and 30 characters long.')
              .matches(/^[a-zA-Z0-9_]+$/).withMessage('Username can only contain alphanumeric characters and underscores.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ username: value });
                if (agent) {
                  return Promise.reject('Username already exists.');
                }
              }),
          
            // Email validation (must be unique)
            body('email')
              .notEmpty().withMessage('Email is required.')
              .isEmail().withMessage('Please provide a valid email address.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ email: value });
                if (agent) {
                  return Promise.reject('Email already exists.');
                }
              }),
          
            // Phone number validation (must be unique, E.164 format)
            body('phoneNumber')
              .notEmpty().withMessage('Phone number is required.')
              .matches(/^\+?[1-9]\d{1,14}$/).withMessage('Please provide a valid phone number.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ phoneNumber: value });
                if (agent) {
                  return Promise.reject('Phone number already exists.');
                }
              }),
          
            // Agency name validation
            body('agency')
              .notEmpty().withMessage('Agency name is required.')
              .isLength({ max: 100 }).withMessage('Agency name cannot exceed 100 characters.'),
          
            // Bio validation (optional)
            body('bio')
              .optional()
              .isLength({ max: 1000 }).withMessage('Bio cannot exceed 1000 characters.'),
          
            // License number validation (must be unique)
            body('licenseNumber')
              .notEmpty().withMessage('License number is required.')
              .custom(async (value) => {
                const agent = await Agent.findOne({ licenseNumber: value });
                if (agent) {
                  return Promise.reject('License number already exists.');
                }
              }),
          
            // Profile image URL validation (optional)
            body('profileImage')
              .optional()
              .matches(/^https?:\/\/.+\.(jpg|jpeg|png|webp)$/).withMessage('Please provide a valid image URL.'),
          
            // Password validation
            body('password')
              .notEmpty().withMessage('Password is required.')
              .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long.')
              .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).withMessage('Password must include at least one uppercase letter, one lowercase letter, and one number.'),
          
            // Properties validation (optional)
            body('properties')
              .optional()
              .isArray().withMessage('Properties must be an array of ObjectIds.')
              .custom((value) => {
                if (!value.every(mongoose.Types.ObjectId.isValid)) {
                  throw new Error('Invalid property IDs.');
                }
                return true;
              }),
          
            // Social media links validation (optional)
            body('socialMediaLinks.facebook')
              .optional()
              .matches(/^https?:\/\/(www\.)?facebook.com\/.+$/).withMessage('Please provide a valid Facebook URL.'),
          
            body('socialMediaLinks.linkedin')
              .optional()
              .matches(/^https?:\/\/(www\.)?linkedin.com\/.+$/).withMessage('Please provide a valid LinkedIn URL.'),
          
            body('socialMediaLinks.twitter')
              .optional()
              .matches(/^https?:\/\/(www\.)?twitter.com\/.+$/).withMessage('Please provide a valid Twitter URL.'),
          
            // Availability validation (optional)
            body('availability')
              .optional()
              .isBoolean().withMessage('Availability must be true or false.'),
          ];
        |-propertyUpdateValidation.js
          import { body } from 'express-validator';
          /**
           * @desc Middleware array that validates the fields for Property updates.
           *       Fields are optional but will be validated if present.
           * @returns {Array} An array of validation rules to be applied before handling property requests.
           */
          export const validateUpdatePropertyFields = [
            body('title')
              .optional()
              .isLength({ max: 100 }).withMessage('Title cannot exceed 100 characters.'),
          
            body('description')
              .optional()
              .isLength({ max: 500 }).withMessage('Description cannot exceed 500 characters.'),
          
            body('propertyType')
              .optional()
              .isIn(['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'])
              .withMessage('Property type must be one of: Apartment, House, Condo, Land, Villa, Office, Studio.'),
          
            body('price')
              .optional()
              .isInt({ min: 0 }).withMessage('Price must be a positive whole number (integer).'),
          
            body('status')
              .optional()
              .isIn(['Available', 'Sold', 'Rented', 'Pending'])
              .withMessage('Status must be one of: Available, Sold, Rented, Pending.'),
          
            body('size')
              .optional()
              .isFloat({ min: 0 }).withMessage('Size must be a positive number.'),
          
            body('bedrooms')
              .optional()
              .isInt({ min: 1 }).withMessage('Bedrooms must be at least 1.'),
          
            body('bathrooms')
              .optional()
              .isInt({ min: 1 }).withMessage('Bathrooms must be at least 1.'),
          
            body('rooms')
              .optional()
              .isInt({ min: 1 }).withMessage('Rooms must be at least 1.'),
          
            body('offerType')
              .optional()
              .isIn(['Sale', 'Rent'])
              .withMessage('Offer type must be either Sale or Rent.'),
          
            body('yearBuilt')
              .optional()
              .isInt({ min: 1800, max: new Date().getFullYear() })
              .withMessage(`Year built must be between 1800 and ${new Date().getFullYear()}.`),
          
            body('availableFrom')
              .optional()
              .isISO8601().withMessage('Available date must be a valid ISO 8601 date.'),
          
            body('address.street')
              .optional()
              .isLength({ max: 100 }).withMessage('Street address cannot exceed 100 characters.'),
          
            body('address.city')
              .optional()
              .notEmpty().withMessage('City is required.'),
          
            body('address.state')
              .optional()
              .notEmpty().withMessage('State is required.'),
          
            body('address.zipCode')
              .optional()
              .matches(/^\d{5}(-\d{4})?$/).withMessage('Please provide a valid zip code.'),
          
            body('address.country')
              .optional()
              .isString().withMessage('Country must be a valid string.'),
          
            body('images.*')
              .optional()
              .isURL().withMessage('Each image must be a valid URL (jpg, jpeg, png, or webp).')
              .matches(/\.(jpg|jpeg|png|webp)$/).withMessage('Image must be a valid format: jpg, jpeg, png, or webp.'),
          
            body('amenities')
              .optional()
              .isArray().withMessage('Amenities must be an array of strings.')
              .custom((amenities) => {
                return amenities.every(amenity => typeof amenity === 'string');
              }).withMessage('All amenities must be valid strings.'),
          
            body('isFeatured')
              .optional()
              .isBoolean().withMessage('isFeatured must be a boolean value.'),
          
            body('coordinates.lat')
              .optional()
              .isFloat({ min: -90, max: 90 }).withMessage('Latitude must be between -90 and 90 degrees.'),
          
            body('coordinates.lng')
              .optional()
              .isFloat({ min: -180, max: 180 }).withMessage('Longitude must be between -180 and 180 degrees.')
          ];
    |-test/
      |-controllers/
        |-adminController.test.js
        |-authController.test.js
        |-agentController.test.js
        |-propertyController.test.js
        |-userController.test.js
      |-utils/
        |-customErrors.test.js
        |-removeRestrictedFields.test.js
        |-excludeSensitiveInfo.test.js
      |-routes/
        |-authRoutes.test.js
        |-propertyRoutes.test.js
        |-agentRoutes.test.js
        |-userRoutes.test.js
      |-middlewares/
        |-authMiddleware.test.js
        |-roleMiddleware.test.js
        |-validationMiddleware.test.js
      |-integration/
        |-integrationTests.test.js
      |-services/
        |-authService.test.js
        |-propertyService.test.js
        |-userService.test.js
        |-agentService.test.js
      |-models/
        |-agentModel.test.js
        |-propertyModel.test.js
        |-userModel.test.js
    |-services/
      |-validationServices.js
        import User from '../models/User.js';
        import { BusinessLogicError } from '../utils/customErrors.js';
        
        /**
         * Service to check if a username is available.
         * @param {string} username - The username to check.
         * @throws {BusinessLogicError} - Throws an error if the username is already taken.
         */
        export const isUsernameAvailable = async (username) => {
          const existingUser = await User.findOne({ username });
          
          if (existingUser) {
            throw new BusinessLogicError('This username is unavailable.');
          }
          
          return true; // Username is available
        };
        
        /**
         * Service to check if an email is already registered.
         * @param {string} email - The email to check.
         * @throws {BusinessLogicError} - Throws an error if the email is already registered.
         */
        export const isEmailAvailable = async (email) => {
          const existingUser = await User.findOne({ email });
          
          if (existingUser) {
            throw new BusinessLogicError('This email is unavailable.');
          }
          
          return true; // Email is available
        };
      |-propertyService.js
        import Property from '../models/Property.js';
        import { 
            BusinessLogicError, 
            ServerError, 
            NotFoundError, 
            ValidationError,
            MongooseValidationError 
          } from '../utils/customErrors.js';
          import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        /**
         * @desc    Service to handle creating a new property.
         * @param   {Object} propertyData - Data for creating the property.
         * @returns {Object} - The created property document.
         * @throws  {ServerError} - Throws an error if property creation fails.
         */
        export const createNewProperty = async (propertyData) => {
            try {
                const restrictedFields = ['createdAt', 'updatedAt', '_id', 'isFeatured'];
                const sanitizedData = removeRestrictedFields(propertyData, restrictedFields);
        
                // Attempt to create the property in the database
                const newProperty = await Property.create(sanitizedData);
                return newProperty;
            } catch (error) {
                console.error('Error creating property:', error);  // Log the actual error for debugging
                if (error.name === 'ValidationError') {
                    throw new ValidationError('Mongoose validation failed.', error.errors);
                } else if (error.code === 11000) {
                    throw new BusinessLogicError('Duplicate field error: Property already exists.');
                }
                throw new ServerError('Error creating property.');
            }
        };
        
          /**
         * @desc    Service to retrieve a property by its ID from the database.
         * @param   {string} propertyId - The ID of the property to be fetched.
         * @returns {Object} - Returns the property object if found.
         * @throws  {NotFoundError} - If the property is not found.
         * @throws  {ServerError} - For other server errors.
         */
        export const getPropertyByIdService = async (propertyId) => {
            try {
              const property = await Property.findById(propertyId);
          
              if (!property) {
                throw new NotFoundError(`Property with ID ${propertyId} not found`);
              }
          
              return property;
            } catch (error) {
              if (error instanceof NotFoundError) {
                throw error; // Pass specific NotFoundError
              }
          
              // Wrap any unexpected errors in a ServerError
              throw new ServerError('Error while fetching property', 500);
            }
        };
        
        /**
         * @desc    Service to update a specific property's information.
         * @param   {string} id - The property's ID.
         * @param   {Object} updates - The updates to be applied to the property.
         * @param   {string} userRole - The role of the user making the update request (either 'agent' or 'admin').
         * @throws  {ValidationError} - If the ID or fields are invalid.
         * @throws  {NotFoundError} - If the property is not found.
         * @throws  {ForbiddenError} - If the user is not allowed to update restricted fields.
         * @throws  {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated property object.
         */
        export const updatePropertyService = async (id, updates, userRole) => {
            try {
              const restrictedFields = ['createdAt', 'updatedAt', '_id', 'isFeatured'];
          
              const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
          
              const updatedProperty = await Property.findByIdAndUpdate(id, sanitizedUpdates, {
                new: true,  // Return the updated document
                runValidators: true,  // Apply schema validations
              });
          
              if (!updatedProperty) {
                throw new NotFoundError('Property not found');
              }
          
              return updatedProperty;
          
            } catch (error) {
              if (error.name === 'ValidationError') {
                throw new MongooseValidationError(error);
              } else if (error instanceof NotFoundError || error instanceof ForbiddenError) {
                throw error;
              }
          
              throw new ServerError('Server error while updating property information');
            }
        };
        
        /**
         * Service to delete a property by ID and remove its reference from users/agents.
         * @param {string} id - The property's ID.
         * @throws {NotFoundError} - If the property is not found.
         * @throws {ServerError} - If an error occurs during deletion.
         */
        export const deletePropertyService = async (id) => {
          try {
            // Find the property by ID
            const property = await Property.findById(id);
            if (!property) {
              throw new NotFoundError('Property not found');
            }
        
            // Delete the property from the database
            await property.deleteOne();
        
            // Remove the property reference from users' and agents' properties array
            await User.updateMany(
              { properties: id },  // Match users with this property
              { $pull: { properties: id } }  // Remove the property from their properties array
            );
        
            await Agent.updateMany(
              { properties: id },  // Match agents with this property
              { $pull: { properties: id } }  // Remove the property from their properties array
            );
        
          } catch (error) {
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting property and updating users/agents');
          }
        };
        
        /**
         * @desc    Service to fetch properties based on filters, or return all properties if no filters are provided.
         * @param   {Object} filters - Query parameters used for filtering properties.
         * @returns {Array} - Array of properties that match the filters or all properties if no filters are applied.
         */
        export const getPropertiesByFilterService = async (filters) => {
          try {
            // Initialize an empty query object
            const query = {};
        
            // Add filters to the query dynamically based on the user input
            if (filters.title) {
              query.title = { $regex: filters.title, $options: 'i' }; // Case-insensitive match for title
            }
        
            if (filters.propertyType) {
              query.propertyType = filters.propertyType;
            }
        
            if (filters.priceMin || filters.priceMax) {
              query.price = {};
              if (filters.priceMin) query.price.$gte = parseInt(filters.priceMin, 10);
              if (filters.priceMax) query.price.$lte = parseInt(filters.priceMax, 10);
            }
        
            if (filters.status) {
              query.status = filters.status;
            }
        
            if (filters.sizeMin || filters.sizeMax) {
              query.size = {};
              if (filters.sizeMin) query.size.$gte = parseFloat(filters.sizeMin);
              if (filters.sizeMax) query.size.$lte = parseFloat(filters.sizeMax);
            }
        
            if (filters.bedrooms) {
              query.bedrooms = { $gte: parseInt(filters.bedrooms, 10) }; // Minimum number of bedrooms
            }
        
            if (filters.bathrooms) {
              query.bathrooms = { $gte: parseInt(filters.bathrooms, 10) }; // Minimum number of bathrooms
            }
        
            if (filters.rooms) {
              query.rooms = { $gte: parseInt(filters.rooms, 10) }; // Minimum number of rooms
            }
        
            if (filters.offerType) {
              query.offerType = filters.offerType;
            }
        
            if (filters.wifi) {
              query.wifi = filters.wifi === 'true'; // Ensure it's a boolean
            }
        
            if (filters.petFriendly) {
              query.petFriendly = filters.petFriendly === 'true'; // Ensure it's a boolean
            }
        
            if (filters.parking) {
              query.parking = filters.parking === 'true'; // Ensure it's a boolean
            }
        
            if (filters.yearBuiltMin || filters.yearBuiltMax) {
              query.yearBuilt = {};
              if (filters.yearBuiltMin) query.yearBuilt.$gte = parseInt(filters.yearBuiltMin, 10);
              if (filters.yearBuiltMax) query.yearBuilt.$lte = parseInt(filters.yearBuiltMax, 10);
            }
        
            if (filters.city) {
              query['address.city'] = filters.city;
            }
        
            if (filters.state) {
              query['address.state'] = filters.state;
            }
        
            if (filters.zipCode) {
              query['address.zipCode'] = filters.zipCode;
            }
        
            if (filters.amenities) {
              query.amenities = { $all: filters.amenities.split(',').map(amenity => amenity.trim()) };
            }    
        
            if (filters.coordinatesLat || filters.coordinatesLng) {
              query.coordinates = {};
              if (filters.coordinatesLat) query['coordinates.lat'] = parseFloat(filters.coordinatesLat);
              if (filters.coordinatesLng) query['coordinates.lng'] = parseFloat(filters.coordinatesLng);
            }
        
            // Execute the query to fetch properties from the database
            const properties = await Property.find(query);
        
            // Return the array of properties
            return properties;
          } catch (error) {
            // Throw an error if any issue occurs
            throw new ServerError('Error fetching properties from the database');
          }
        };
        
        export const addPropertyImageService = async (propertyId, imageUrl) => {
          try {
            // Find the property by ID
            const property = await Property.findById(propertyId);
        
            if (!property) {
              throw new NotFoundError('Property not found');
            }
        
            // Check if the image already exists in the array to avoid duplicates
            if (property.images.includes(imageUrl)) {
              throw new BusinessLogicError('Image URL already exists in the property.');
            }
        
            // Add the new image URL to the images array
            const updatedProperty = await Property.findByIdAndUpdate(
              propertyId,
              { $push: { images: imageUrl } },  // Push new image if not found in array
              { new: true, runValidators: true }  // Return the updated document
            );
        
            return updatedProperty;
          } catch (error) {
            // Re-throw known errors (like BusinessLogicError)
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            }
        
            // Wrap and throw unexpected errors as ServerError
            throw new ServerError('Error adding image to property', 500, error);
          }
        };
        
        export const removePropertyImageService = async (propertyId, imageUrl) => {
          try {
            // Find the property by ID
            const property = await Property.findById(propertyId);
        
            if (!property) {
              throw new NotFoundError('Property not found');
            }
        
            // Check if the image exists in the property
            if (!property.images.includes(imageUrl)) {
              throw new BusinessLogicError('Image URL does not exist in the property.');
            }
        
            // Remove the image URL from the images array
            const updatedProperty = await Property.findByIdAndUpdate(
              propertyId,
              { $pull: { images: imageUrl } },  // Remove the image
              { new: true }  // Return the updated document
            );
        
            return updatedProperty;
          } catch (error) {
            // Re-throw known errors like NotFoundError and BusinessLogicError
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            }
        
            // Wrap any other unexpected errors in a ServerError
            throw new ServerError('Error removing image from property', 500, error);
          }
        };
        
        export const addPropertyAmenityService = async (propertyId, amenity) => {
          try {
            const property = await Property.findById(propertyId);
        
            if (!property) {
              throw new NotFoundError('Property not found');
            }
        
            if (property.amenities.includes(amenity)) {
              throw new BusinessLogicError('Amenity already exists in the property.');
            }
        
            property.amenities.push(amenity);
        
            const updatedProperty = await property.save();
        
            return updatedProperty;
          } catch (error) {
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            }
        
            throw new ServerError('Error adding amenity to property', 500, error);
          }
        };
        
        export const removePropertyAmenityService = async (propertyId, amenity) => {
          try {
            const property = await Property.findById(propertyId);
        
            if (!property) {
              throw new NotFoundError('Property not found');
            }
        
            if (!property.amenities.includes(amenity)) {
              throw new BusinessLogicError('Amenity does not exist in the property.');
            }
        
            property.amenities = property.amenities.filter(existingAmenity => existingAmenity !== amenity);
        
            // Save the updated property
            const updatedProperty = await property.save();
        
            return updatedProperty;
          } catch (error) {
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            }
        
            throw new ServerError('Error removing amenity from property', 500, error);
          }
        };
        
      |-adminService.js
        import Admin from '../models/Admin.js';
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError,
          MongooseValidationError,
          ForbiddenError,
        } from '../utils/customErrors.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        
        /**
         * Business logic to create a new admin.
         * @param {Object} adminData - The data for creating the new admin.
         * @throws {BusinessLogicError | ServerError} - Throws errors if something goes wrong.
         * @returns {Object} - The newly created admin.
         */
        export const createNewAdmin = async (adminData) => {
          try {
            const { firstName, lastName, username, email, phoneNumber, password, role, permissions, profileImage } = adminData;
        
            // Check for duplicate fields (email, username, phoneNumber)
            const duplicateErrors = await checkDuplicateFields(Admin, { username, email, phoneNumber });
        
            // If duplicates are found, throw BusinessLogicError
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            // Create a new admin
            const newAdmin = new Admin({
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              password,
              role: role || 'admin',  // Default role is 'admin'
              permissions: permissions || ['manage_users', 'view_reports'],  // Default permissions for 'admin'
              profileImage,
            });
        
            // Save the new admin to the database
            await newAdmin.save();
        
            // Return the newly created admin
            return newAdmin;
        
          } catch (error) {
            // Throw any error to be caught by the controller
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating admin');  // Default to ServerError for unexpected errors
            }
          }
        };
        
        /**
         * Service to retrieve all admin users from the database.
         * @returns {Object[]} - Returns an array of admin objects with all fields.
         * @throws {Error} - Throws NotFoundError if no admins are found, or ServerError for other errors.
         */
        export const getAllAdminsService = async () => {
          try {
            // Find all admins (do not exclude sensitive info here)
            const admins = await Admin.find();
            
            if (!admins || admins.length === 0) {
              throw new NotFoundError('No admins found');
            }
        
            // Return raw data to the controller
            return admins;
        
          } catch (error) {
            if (error instanceof NotFoundError) {
              throw error; // Propagate the specific NotFoundError
            }
        
            // Wrap any other unexpected errors in a ServerError
            throw new ServerError('Error while fetching admins', 500);
          }
        };
        
        /**
         * Service to retrieve an admin by ID.
         * @param {string} id - The admin's ID from the request parameters.
         * @returns {Object} - Returns the found admin object or throws an error.
         */
        export const getAdminByIdService = async (id) => {
          try {
            // Find the admin by ID, excluding the password field
            const admin = await Admin.findById(id)
        
            if (!admin) {
              throw new NotFoundError('Admin not found');
            }
        
            // Return the admin data
            return admin;
        
          } catch (error) {
            // Handle specific and unexpected errors
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error retrieving admin');
          }
        };
        
        /**
         * Service to delete an admin by ID.
         * @param {string} id - The admin's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the admin with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteAdminService = async (id) => {
          try {
            // Find the admin by ID
            const admin = await Admin.findById(id);
            if (!admin) {
              throw new NotFoundError('Admin not found');
            }
        
            // Delete the admin
            await admin.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting admin');
          }
        };
        
        /**
         * Service to update a specific admin's information.
         * @param {string} id - The admin's ID.
         * @param {Object} updates - The updates to be applied to the admin.
         * @param {string} userRole - The role of the user making the update request (either 'admin' or 'super-admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the admin is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'permissions'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated admin object.
         */
        export const updateAdminService = async (id, updates, userRole) => {
          try {
            // Prevent non-super admins from updating 'role' and 'permissions'
            if (userRole !== 'super-admin') {
              if ('role' in updates || 'permissions' in updates) {
                throw new ForbiddenError('Only super-admin can modify role or permissions.');
              }
            }
        
                // List of fields that cannot be modified
                const restrictedFields = ['role', 'joinedAt'];
                // Remove restricted fields from updates using the utility function
                const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            // Attempt to find and update the admin
            const updatedAdmin = await Admin.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations for fields like email and phone number
            });
        
            if (!updatedAdmin) {
              throw new NotFoundError('Admin not found');
            }
        
            return updatedAdmin;
        
          } catch (error) {
            // Handle specific validation errors
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);  // Custom error class to handle Mongoose validation errors
            } else if (error instanceof ValidationError || error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;  // Propagate known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating admin information');
          }
        };
        
      |-agentService.js
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import Agent from '../models/Agent.js';
        import {isValidObjectId} from '../utils/mongooseUtils.js';
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError
        } from '../utils/customErrors.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        /**
         * Business logic to create a new agent.
         * @param {Object} agentData - The data for creating the new agent.
         * @throws {BusinessLogicError | ServerError} - Throws specific errors if necessary.
         * @returns {Object} - The newly created agent.
         */
        export const createNewAgent = async (agentData) => {
          try {
            const {
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              agency,
              bio,             // Optional field
              licenseNumber,
              profileImage,    // Optional field
              password,
              socialMediaLinks, // Optional field containing Facebook, LinkedIn, Twitter links
            } = agentData;  // Only pick the fields needed for agent creation
        
            // Check for duplicate fields
            const duplicateErrors = await checkDuplicateFields(Agent, { username, email, phoneNumber, licenseNumber });
        
            // If duplicates are found, throw a BusinessLogicError
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            // Proceed with creating the agent
            const newAgent = new Agent({
              firstName,
              lastName,
              username,
              email,
              phoneNumber,
              agency,
              bio,             // Include bio if provided
              licenseNumber,
              profileImage,    // Include profileImage if provided
              password,
              socialMediaLinks, // Include socialMediaLinks if provided
              role: 'agent',   // Default role is 'agent'
              agentStatus: 'pending'  // Default status is 'pending'
            });
        
            // Save the new agent to the database
            await newAgent.save();
        
            // Return the new agent
            return newAgent;
        
          } catch (error) {
            // Rethrow known errors or throw ServerError for unexpected cases
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating agent'); // Default to a server error
            }
          }
        };
        
        /**
         * @desc    Service to fetch agents based on filters, or return all agents if no filters are provided.
         * @param   {Object} filters - Query parameters used for filtering agents.
         * @returns {Array} - Array of agents that match the filters or all agents if no filters are applied.
         */
        export const getAgentsByFilterService = async (filters) => {
          try {
            // Initialize an empty query object
            const query = {};
        
            // Add filters dynamically based on query parameters
        
            if (filters.firstName) {
              query.firstName = { $regex: filters.firstName, $options: 'i' };  // Case-insensitive match for first name
            }
        
            if (filters.lastName) {
              query.lastName = { $regex: filters.lastName, $options: 'i' };  // Case-insensitive match for last name
            }
        
            if (filters.username) {
              query.username = { $regex: filters.username, $options: 'i' };  // Case-insensitive match for username
            }
        
            if (filters.agency) {
              query.agency = { $regex: filters.agency, $options: 'i' };  // Case-insensitive match for agency name
            }
        
            if (filters.phoneNumber) {
              query.phoneNumber = filters.phoneNumber;
            }
        
            if (filters.email) {
              query.email = { $regex: filters.email, $options: 'i' };  // Case-insensitive match for email
            }
        
            if (filters.licenseNumber) {
              query.licenseNumber = filters.licenseNumber;  // Exact match for license number
            }      
        
            if (filters.agentStatus) {
              query.agentStatus = filters.agentStatus;  // E.g., pending, active, rejected
            }
        
            if (filters.ratingMin || filters.ratingMax) {
              query.rating = {};
              if (filters.ratingMin) query.rating.$gte = parseFloat(filters.ratingMin);
              if (filters.ratingMax) query.rating.$lte = parseFloat(filters.ratingMax);
            }
        
            if (filters.reviewsCountMin || filters.reviewsCountMax) {
              query.reviewsCount = {};
              if (filters.reviewsCountMin) query.reviewsCount.$gte = parseInt(filters.reviewsCountMin, 10);
              if (filters.reviewsCountMax) query.reviewsCount.$lte = parseInt(filters.reviewsCountMax, 10);
            }
        
            // Execute the query to fetch agents from the database
            const agents = await Agent.find(query);
        
            // Return the array of agents
            return agents;
          } catch (error) {
            throw new ServerError('Error fetching agents from the database');
          }
        };
        
        /**
         * Service to retrieve an agent by ID.
         * @param {string} id - The agent's ID from the request parameters.
         * @returns {Object} - Returns the found agent object or throws an error.
         */
        export const getAgentByIdService = async (id) => {
          try {
            // Find the agent by ID
            const agent = await Agent.findById(id);
        
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Return the agent data
            return agent;
          } catch (error) {
            // Handle specific and unexpected errors
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error retrieving agent');
          }
        };
        
        /**
         * Service to delete an agent by ID.
         * @param {string} id - The agent's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the agent with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteAgentService = async (id) => {
          try {
            // Find the agent by ID
            const agent = await Agent.findById(id);
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Delete the agent
            await agent.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting agent');
          }
        };
        
        /**
         * Service to update a specific agent's information.
         * @param {string} id - The agent's ID.
         * @param {Object} updates - The updates to be applied to the agent.
         * @param {string} userRole - The role of the user making the update request (either 'agent' or 'super-admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the agent is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'permissions'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated agent object.
         */
        export const updateAgentService = async (id, updates, userRole) => {
          try {
        
            // List of fields that cannot be modified
            const restrictedFields = ['role', 'rating', 'reviews', 'joinedAt'];
            // Remove restricted fields from updates using the utility function
            const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            // Attempt to find and update the agent
            const updatedAgent = await Agent.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations for fields like email and phone number
            });
        
            if (!updatedAgent) {
              throw new NotFoundError('Agent not found');
            }
        
            return updatedAgent;
        
          } catch (error) {
            // Handle Mongoose validation errors
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);
            } else if (error instanceof ValidationError || error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;  // Propagate known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating agent information');
          }
        };
        
        /**
         * Service to update the status of a specific agent.
         * @param {string} id - The agent's ID.
         * @param {string} agentStatus - The new status to be applied to the agent.
         * @throws {ValidationError} - If the ID or status is invalid.
         * @throws {NotFoundError} - If the agent is not found.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated agent object.
         */
        export const updateAgentStatusService = async (id, agentStatus) => {
          try {
            // Ensure the provided agentStatus is valid
            const validStatuses = ['pending', 'active', 'rejected'];
            if (!validStatuses.includes(agentStatus)) {
              throw new ValidationError('Invalid status provided');
            }
        
            // Find the agent by ID
            const agent = await Agent.findById(id);
            if (!agent) {
              throw new NotFoundError('Agent not found');
            }
        
            // Update the agent's status
            agent.agentStatus = agentStatus;
        
            // Save the updated agent
            await agent.save();
        
            return agent;  // Return the updated agent
          } catch (error) {
            if (error instanceof ValidationError || error instanceof NotFoundError) {
              throw error;  // Rethrow known errors
            }
        
            // Handle any unexpected server-side errors
            throw new ServerError('Server error while updating agent status');
          }
        };
      |-userServices.js
        /**
         * This file contains the services for user management in the system.
         * It handles business logic for creating, updating, retrieving, and deleting users.
         */
        
        import User from '../models/User.js';
        
        // Utility imports
        import { checkDuplicateFields } from '../utils/checkDuplicateFields.js';
        import { removeRestrictedFields } from '../utils/removeRestrictedFields.js';
        
        // Custom error imports
        import { 
          BusinessLogicError, 
          ServerError, 
          NotFoundError, 
          ValidationError,
          MongooseValidationError 
        } from '../utils/customErrors.js';
        
        
        /**
         * Business logic to create a new user.
         * @param {Object} userData - The data for creating the new user.
         * @throws {BusinessLogicError | ServerError} - Throws errors if something goes wrong.
         * @returns {Object} - The newly created user.
         */
        export const createNewUser = async (userData) => {
          try {
            const { firstName, lastName, username, email, password } = userData;
        
            const duplicateErrors = await checkDuplicateFields(User, { email, username });
        
            if (duplicateErrors.length > 0) {
              throw new BusinessLogicError('Duplicate fields found', duplicateErrors);
            }
        
            const newUser = new User({
              firstName,
              lastName,
              username,
              email,
              password, // Password will be hashed automatically before saving
              role: 'user',
            });
        
            await newUser.save();
        
            return newUser;
        
          } catch (error) {
            if (error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error creating user');
            }
          }
        };
        
        /**
         * @desc    Service to fetch users based on filters, or return all users if no filters are provided.
         * @param   {Object} filters - Query parameters used for filtering users.
         * @returns {Array} - Array of users that match the filters or all users if no filters are applied.
         */
        export const getUsersByFilterService = async (filters) => {
          try {
            const query = {};
        
            if (filters.firstName) {
              query.firstName = { $regex: filters.firstName, $options: 'i' }; // Case-insensitive match
            }
        
            if (filters.lastName) {
              query.lastName = { $regex: filters.lastName, $options: 'i' };
            }
        
            if (filters.username) {
              query.username = { $regex: filters.username, $options: 'i' };
            }
        
            if (filters.email) {
              query.email = { $regex: filters.email, $options: 'i' };
            }
        
            if (filters.accountStatus) {
              query.accountStatus = filters.accountStatus;  // Match exact account status
            }
        
            const users = await User.find(query);
        
            return users;
        
          } catch (error) {
            throw new ServerError('Error fetching users from the database');
          }
        };
        
        /**
         * Service to retrieve a user by their ID from the database.
         * @param {string} userId - The ID of the user to be fetched.
         * @returns {Object} - Returns the user object if found.
         * @throws {NotFoundError} - If the user is not found.
         * @throws {ServerError} - For other server errors.
         */
        export const getUserByIdService = async (userId) => {
          try {
            const user = await User.findById(userId);
        
            if (!user) {
              throw new NotFoundError(`User with ID ${userId} not found`);
            }
        
            return user;
          } catch (error) {
            if (error instanceof NotFoundError) {
              throw error;
            }
        
            throw new ServerError('Error while fetching user', 500);
          }
        };
        
        /**
         * @param {string} id - The user's ID.
         * @param {Object} updates - The updates to be applied to the user.
         * @param {string} userRole - The role of the user making the update request (either 'user' or 'admin').
         * @throws {ValidationError} - If the ID or fields are invalid.
         * @throws {NotFoundError} - If the user is not found.
         * @throws {ForbiddenError} - If the user is not allowed to update 'role' or 'accountStatus'.
         * @throws {ServerError} - For any server-side errors that occur.
         * @returns {Object} - The updated user object.
         */
        export const updateUserService = async (id, updates, userRole) => {
          try {
            const restrictedFields = ['role', 'accountStatus', 'createdAt', 'lastLogin'];
            
            const sanitizedUpdates = removeRestrictedFields(updates, restrictedFields);
        
            const updatedUser = await User.findByIdAndUpdate(id, sanitizedUpdates, {
              new: true,  // Return the updated document
              runValidators: true,  // Apply schema validations
            });
        
            if (!updatedUser) {
              throw new NotFoundError('User not found');
            }
        
            return updatedUser;
        
          } catch (error) {
            if (error.name === 'ValidationError') {
              throw new MongooseValidationError(error);
            } else if (error instanceof NotFoundError || error instanceof ForbiddenError) {
              throw error;
            }
        
            throw new ServerError('Server error while updating user information');
          }
        };
        
        /**
         * Service to delete a user by ID.
         * @param {string} id - The user's ID from the request parameters.
         * @throws {ValidationError} - If the ID is not a valid MongoDB ObjectId.
         * @throws {NotFoundError} - If the user with the provided ID is not found.
         * @throws {ServerError} - For any server errors that occur.
         */
        export const deleteUserService = async (id) => {
          try {
            // Find the user by ID
            const user = await User.findById(id);
            if (!user) {
              throw new NotFoundError('User not found');
            }
        
            // Delete the user
            await user.deleteOne();
          } catch (error) {
            // Handle specific errors or throw ServerError for unexpected cases
            if (error instanceof NotFoundError || error instanceof ValidationError) {
              throw error;
            }
            throw new ServerError('Error deleting user');
          }
        };
        
        /**
         * Service to add a property to a user's properties array.
         * @param {string} userId - The user's ID (from the URL).
         * @param {string} propertyId - The property ID to add (from the body).
         * @throws {NotFoundError} - If the user is not found.
         * @throws {BusinessLogicError} - If the property already exists in the user's properties array.
         * @throws {ServerError} - If an error occurs during the update.
         * @returns {Object} - The updated user object.
         */
        export const addPropertyToUserService = async (userId, propertyId) => {
          try {
            const user = await User.findById(userId);
            if (!user) {
              throw new NotFoundError('User not found');
            }
        
            // Check if the property already exists in the user's properties array
            if (user.properties.includes(propertyId)) {
              throw new BusinessLogicError('Property already added to user.');
            }
        
            // Add the property ID to the user's properties array
            user.properties.push(propertyId);
        
            // Save the updated user
            await user.save();
            
            return user;
          } catch (error) {
            // Throw a specific error if known or a generic server error
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error updating user properties');
            }
          }
        };
        
        /**
         * Service to remove a property from a user's properties array.
         * @param {string} userId - The user's ID (from the URL).
         * @param {string} propertyId - The property ID to remove (from the body).
         * @throws {NotFoundError} - If the user is not found.
         * @throws {BusinessLogicError} - If the property does not exist in the user's properties array.
         * @throws {ServerError} - If an error occurs during the update.
         * @returns {Object} - The updated user object.
         */
        export const removePropertyFromUserService = async (userId, propertyId) => {
          try {
            const user = await User.findById(userId);
            if (!user) {
              throw new NotFoundError('User not found');
            }
        
            if (!user.properties.includes(propertyId)) {
              throw new BusinessLogicError('Property not found in user\'s properties.');
            }
        
            user.properties = user.properties.filter(prop => prop.toString() !== propertyId);
        
            await user.save();
            
            return user;
          } catch (error) {
            if (error instanceof NotFoundError || error instanceof BusinessLogicError) {
              throw error;
            } else {
              throw new ServerError('Error removing property from user');
            }
          }
        };
      |-authService.js
        import Admin from '../models/Admin.js';
        import Agent from '../models/Agent.js';
        import User from '../models/User.js';
        import generateUniqueUsername from '../utils/generateUniqueUsername.js'; // Default import
        import { ServerError} from '../utils/customErrors.js';
        import { BusinessLogicError, UnauthorizedError } from '../utils/customErrors.js';
        
        /**
         * Authenticate admin by email and password.
         * @param {string} email - Admin email.
         * @param {string} password - Admin password.
         * @throws {UnauthorizedError | ServerError} - Throws specific errors if authentication fails.
         * @returns {Object} - Authenticated admin.
         */
        export const authenticateAdmin = async (email, password) => {
          try {
            // Find the admin by email
            const admin = await Admin.findOne({ email });
            if (!admin) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Verify the password
            const isPasswordValid = await admin.comparePassword(password);
            if (!isPasswordValid) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated admin if everything is fine
            return admin;
        
          } catch (error) {
            // Rethrow known errors or throw a generic server error
            if (error instanceof UnauthorizedError) {
              throw error;
            } else {
              throw new ServerError('Error during authentication');
            }
          }
        };
        
        /**
         * Business logic to authenticate an agent.
         * @param {String} email - The agent's email address.
         * @param {String} password - The agent's password.
         * @returns {Object} - Returns the authenticated agent or throws an error.
         */
        export const authenticateAgent = async (email, password) => {
          try {
            // Find the agent by email
            const agent = await Agent.findOne({ email });
        
            if (!agent) {
              // Throw error instead of returning
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Verify the password
            const isPasswordValid = await agent.comparePassword(password);
            if (!isPasswordValid) {
              // Throw error instead of returning
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated agent
            return { agent };
          } catch (error) {
            // Only throw ServerError if the caught error isn't already a known custom error
            if (error instanceof UnauthorizedError) {
              throw error;  // Pass the specific UnauthorizedError
            }
            
            // For other unexpected errors, throw a ServerError
            throw new ServerError('Error during agent authentication');
          }
        };
        
        export const handleGoogleOAuthSignup = async (userProfile) => {
          const { googleId, firstName, lastName, email, avatar } = userProfile;
        
          try {
            // Check if the user already exists in the database by googleId OR email
            const existingUser = await User.findOne({
              $or: [{ googleId }, { email }]
            });
        
            if (existingUser) {
              // If user exists, return the user with a flag indicating it's an existing user
              return { user: existingUser, isExisting: true };
            }
        
            // Create a new user in the database with a default role
            const newUser = new User({
              firstName,
              lastName,
              email,
              googleId,
              avatar,
              role: 'user',  // Add a default role
              username: await generateUniqueUsername(firstName, lastName, email),
            });
        
            await newUser.save();
        
            // Return the newly created user object with a flag indicating it's a new user
            return { user: newUser, isExisting: false };
          } catch (error) {
            console.error('Error during Google OAuth signup service:', error);
            throw new BusinessLogicError('Error processing signup');
          }
        };
        
        /**
         * Service to handle Google OAuth sign-in logic.
         * @param {Object} userProfile - Google user profile object containing user data.
         * @returns {Object} - Returns the user object if the user exists, otherwise throws an error.
         */
        export const handleGoogleOAuthSignin = async (userProfile) => {
          const { googleId, email } = userProfile;
        
          try {
            // Check if the user exists in the database by googleId OR email
            const existingUser = await User.findOne({ $or: [{ googleId }, { email }] });
        
            if (!existingUser) {
              // Throw an error if the user is not found
              throw new BusinessLogicError('User not found, please sign up');
            }
        
            // Return the existing user object
            return existingUser;
          } catch (error) {
            console.error('Error during Google OAuth signin service:', error);
            throw new BusinessLogicError('Error processing signin');
          }
        };
        
        /**
         * Service to handle user login.
         * @param {string} email - User's email address.
         * @param {string} password - User's password.
         * @throws {UnauthorizedError | ServerError} - Throws an error if authentication fails or if a server error occurs.
         * @returns {Object} - The authenticated user.
         */
        export const authenticateUserService = async (email, password) => {
          try {
            // Find the user by email
            const user = await User.findOne({ email });
        
            // If the user doesn't exist, throw UnauthorizedError
            if (!user) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Check if the password is correct
            const isPasswordValid = await user.comparePassword(password);
            if (!isPasswordValid) {
              throw new UnauthorizedError('Invalid email or password');
            }
        
            // Return the authenticated user
            return user;
          } catch (error) {
            // Catch unexpected server errors
            if (error instanceof UnauthorizedError) {
              throw error;
            } else {
              throw new ServerError('Server error during authentication');
            }
          }
        };
        
        /**
         * Clears the authentication token cookie, effectively logging the user out.
         * @param {Object} res - Express response object.
         * @returns {void}
         */
        export const clearTokenCookie = (res) => {
          const cookieOptions = {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 0,
          };
          
          // Clear the cookie by setting it with an expired maxAge
          res.cookie('propertyHubAuthToken', '', cookieOptions);
        };
        
    |-models/
      |-Admin.js
        /**
         * This file contains the schema for the Admin model.
         */
        
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        /**
         * @desc Admin model schema to represent admin users in the system. 
         *       It includes personal details, authentication data, and role-based permissions.
         *       Passwords are hashed before saving for security.
         */
        const adminSchema = new mongoose.Schema({
          firstName: {
            type: String,
            required: [true, 'First name is required.'],
            maxlength: [50, 'First name cannot exceed 50 characters.'],
          },
          lastName: {
            type: String,
            required: [true, 'Last name is required.'],
            maxlength: [50, 'Last name cannot exceed 50 characters.'],
          },
          username: {
            type: String,
            required: [true, 'Username is required.'],
            unique: true,
            minlength: [4, 'Username must be at least 4 characters long.'],
            maxlength: [30, 'Username cannot exceed 30 characters.'],
            match: [/^[a-zA-Z0-9_]+$/, 'Username can only contain alphanumeric characters and underscores.'],
          },
          email: {
            type: String,
            required: [true, 'Email is required.'],
            unique: true,
            match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email address.'],
          },
          phoneNumber: {
            type: String,
            required: [true, 'Phone number is required.'],
            match: [/^\+?[1-9]\d{1,14}$/, 'Please provide a valid phone number.'], // Format like +1234567890
          },
          password: {
            type: String,
            required: true,
            minlength: [6, 'Minimum length is 6 characters'],
            validate: {
              validator: function (value) {
                // Password must include at least one uppercase letter, one lowercase letter, and one number
                return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
              },
              message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.',
            },
          },
          role: {
            type: String,
            enum: ['admin', 'super-admin'],
            default: 'admin',  // Default role is "admin"
          },
          permissions: {
            type: [String],
            default: function () {
              return this.role === 'super-admin'
                ? ['manage_users', 'manage_agents', 'view_reports', 'manage_admins']
                : ['manage_users', 'view_reports'];  // Default permissions for "admin"
            },
            validate: {
              validator: function (permissionsArray) {
                // Check that all permissions are strings
                return permissionsArray.every(permission => typeof permission === 'string');
              },
              message: 'Permissions must be valid strings.',
            },
          },
          profileImage: {
            type: String,
            default: 'https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png',
            validate: {
              validator: function (value) {
                return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value);
              },
              message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).',
            },
          },
          joinedAt: {
            type: Date,
            default: Date.now, // Automatically set when admin is created
          },
        }, {
          timestamps: true, // Automatically adds createdAt and updatedAt fields
        });
        
        // Pre-save middleware to hash the password before saving
        adminSchema.pre('save', async function (next) {
          if (!this.isModified('password')) return next();
        
          try {
            const salt = await bcrypt.genSalt(10);
            this.password = await bcrypt.hash(this.password, salt);
            next();
          } catch (error) {
            next(error);
          }
        });
        
        // Method for comparing passwords during login/authentication
        adminSchema.methods.comparePassword = async function (candidatePassword) {
          return bcrypt.compare(candidatePassword, this.password);
        };
        
        // Virtual property to get admin's full name
        adminSchema.virtual('fullName').get(function () {
          return `${this.firstName} ${this.lastName}`;
        });
        
        // Indexing important fields for performance
        adminSchema.index({ email: 1 });
        adminSchema.index({ phoneNumber: 1 });
        adminSchema.index({ role: 1 });
        adminSchema.index({ username: 1 });  // Index the username for performance
        
        // Compile the schema into a model
        const Admin = mongoose.model('Admin', adminSchema);
        
        export default Admin;
      |-Property.js
        import mongoose from 'mongoose';
        
        const propertySchema = new mongoose.Schema({
          title: {
            type: String,
            required: [true, 'Property title is required.'],
            maxlength: [100, 'Title cannot exceed 100 characters.']
          },
          description: {
            type: String,
            required: [true, 'Description is required.'],
            maxlength: [500, 'Description cannot exceed 500 characters.']
          },
          propertyType: {
            type: String,
            enum: ['Apartment', 'House', 'Condo', 'Land', 'Villa', 'Office', 'Studio'],
            required: [true, 'Property type is required.']
          },
          price: {
            type: Number,
            required: [true, 'Price is required.'],
            min: [0, 'Price must be a positive number.'],
            validate: {
              validator: function (value) {
                return Number.isInteger(value);
              },
              message: 'Price must be a whole number (integer).'
            }
          },
          status: {
            type: String,
            enum: ['Available', 'Sold', 'Rented', 'Pending'],
            default: 'Available'
          },
          size: {
            type: Number,
            required: [true, 'Property size is required.'],
            min: [0, 'Size must be a positive number.'],
          },
          bedrooms: {
            type: Number,
            required: [true, 'Number of bedrooms is required.'],
            min: [1, 'Bedrooms must be at least 1.']
          },
          bathrooms: {
            type: Number,
            required: [true, 'Number of bathrooms is required.'],
            min: [1, 'Bathrooms must be at least 1.']
          },
          rooms: {
            type: Number,
            required: [true, 'Number of rooms is required.'],
            min: [1, 'Rooms must be at least 1.']
          },
          offerType: {
            type: String,
            enum: ['Sale', 'Rent'],
            required: [true, 'Offer type is required.']
          },
          wifi: {
            type: Boolean,
            default: false,
          },
          petFriendly: {
            type: Boolean,
            default: false,
          },
          parking: {
            type: Boolean,
            default: false,
          },
          yearBuilt: {
            type: Number,
            min: [1800, 'Year built must be after 1800.'],
            max: [new Date().getFullYear(), 'Year built cannot be in the future.'],
          },
          availableFrom: {
            type: Date,
            required: [true, 'Available date is required.'],
            default: Date.now,
          },
          address: {
            street: {
              type: String,
              required: [true, 'Street address is required.'],
              maxlength: [100, 'Street address cannot exceed 100 characters.']
            },
            city: {
              type: String,
              required: [true, 'City is required.']
            },
            state: {
              type: String,
              required: [true, 'State is required.']
            },
            zipCode: {
              type: String,
              required: [true, 'Zip code is required.'],
              match: [/^\d{5}(-\d{4})?$/, 'Please provide a valid zip code.']
            },
            country: {
              type: String,
              required: [true, 'Country is required.'],
              default: 'Morocco'
            }
          },
          images: [
            {
              type: String,
              validate: {
                validator: function (value) {
                  return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value); // Validate URLs for images
                },
                message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).'
              }
            }
          ],
          amenities: {
            type: [String],
            default: [],
            validate: {
              validator: function (amenitiesArray) {
                return amenitiesArray.every(amenity => typeof amenity === 'string');
              },
              message: 'All amenities must be valid strings.'
            }
          },
          isFeatured: {
            type: Boolean,
            default: false,
          },
          coordinates: {
            lat: {
              type: Number,
              min: [-90, 'Latitude must be between -90 and 90 degrees.'],
              max: [90, 'Latitude must be between -90 and 90 degrees.'],
            },
            lng: {
              type: Number,
              min: [-180, 'Longitude must be between -180 and 180 degrees.'],
              max: [180, 'Longitude must be between -180 and 180 degrees.'],
            }
          },
          createdAt: {
            type: Date,
            default: Date.now
          },
          updatedAt: {
            type: Date,
            default: Date.now
          }
        }, {
          timestamps: true
        });
        
        // Pre-save middleware to update `updatedAt` before saving
        propertySchema.pre('save', function (next) {
          this.updatedAt = Date.now();
          next();
        });
        
        // Virtual property for displaying full address
        propertySchema.virtual('fullAddress').get(function () {
          return `${this.address.street}, ${this.address.city}, ${this.address.state}, ${this.address.zipCode}, ${this.address.country}`;
        });
        
        // Indexing fields for faster queries (e.g., searching properties by price, status, or agent)
        propertySchema.index({ price: 1 });
        propertySchema.index({ status: 1 });
        propertySchema.index({ agentId: 1 });
        propertySchema.index({ offerType: 1 });
        
        const Property = mongoose.model('Property', propertySchema);
        
        export default Property;
      |-Agent.js
        /*
         * This file defines the schema for the Agent model in a property management application.
         * It includes fields for agent information, password management, and agent status, 
         * with validation and pre-save hooks for password hashing.
         */
        
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        /**
         * @desc Schema definition for the `Agent` model representing real estate agents in the system.
         */
        const agentSchema = new mongoose.Schema({
          firstName: {
            type: String,
            required: [true, 'First name is required.'],
            maxlength: [50, 'First name cannot exceed 50 characters.'],
          },
          lastName: {
            type: String,
            required: [true, 'Last name is required.'],
            maxlength: [50, 'Last name cannot exceed 50 characters.'],
          },
          username: {
            type: String,
            required: [true, 'Username is required.'],
            unique: true,
            minlength: [4, 'Username must be at least 4 characters long.'],
            maxlength: [30, 'Username cannot exceed 30 characters.'],
            match: [/^[a-zA-Z0-9_]+$/, 'Username can only contain alphanumeric characters and underscores.'],
          },
          email: {
            type: String,
            required: [true, 'Email is required.'],
            unique: true,
            match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email address.'],
          },
          phoneNumber: {
            type: String,
            required: [true, 'Phone number is required.'],
            match: [/^\+?[1-9]\d{1,14}$/, 'Please provide a valid phone number.'], // E.164 format
          },
          agency: {
            type: String,
            maxlength: [100, 'Agency name cannot exceed 100 characters.'],
            required: [true, 'Agency name is required.'],
          },
          bio: {
            type: String,
            maxlength: [1000, 'Bio cannot exceed 1000 characters.'],
            default: '', // Default empty bio
          },
          licenseNumber: {
            type: String,
            required: [true, 'License number is required.'],
            unique: true,
          },
          profileImage: {
            type: String,
            default: 'https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png', // Default avatar
            validate: {
              validator: function (value) {
                return /^https?:\/\/.+\.(jpg|jpeg|png|webp)$/.test(value); // Validate URLs for profile image
              },
              message: 'Please provide a valid image URL (jpg, jpeg, png, or webp).',
            },
          },
          password: {
            type: String,
            required: true,
            minlength: [6, 'Minimum length is 6 characters'],
            validate: {
              validator: function (value) {
                // Password must include at least one uppercase letter, one lowercase letter, and one number
                return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
              },
              message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.',
            },
          },
          properties: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Property', // Reference to properties managed by the agent
          }],
           default: [], // Default empty array for properties
          role: {
            type: String,
            enum: ['agent'], // Only "agent" is allowed for this model
            default: 'agent', // Automatically assign "agent" role
          },
          rating: {
            type: Number,
            min: [0, 'Rating cannot be below 0.'],
            max: [5, 'Rating cannot exceed 5.'],
            default: 0,
          },
          reviewsCount: {
            type: Number,
            default: 0, // Track how many reviews have been given
          },
          socialMediaLinks: {
            facebook: {
              type: String,
              match: [/^https?:\/\/(www\.)?facebook.com\/.+$/, 'Please provide a valid Facebook URL.'],
            },
            linkedin: {
              type: String,
              match: [/^https?:\/\/(www\.)?linkedin.com\/.+$/, 'Please provide a valid LinkedIn URL.'],
            },
            twitter: {
              type: String,
              match: [/^https?:\/\/(www\.)?twitter.com\/.+$/, 'Please provide a valid Twitter URL.'],
            },
            default: {}, // Default empty object for social media links
          },
          availability: {
            type: Boolean,
            default: true, // Agents are available by default unless explicitly set to unavailable
          },
          agentStatus: {
            type: String,
            enum: ['pending', 'active', 'rejected'], // Agent registration status
            default: 'pending', // New agents start with 'pending' status until approved by an admin
          },
          joinedAt: {
            type: Date,
            default: Date.now,
          },
        }, {
          timestamps: true, // Automatically adds createdAt and updatedAt fields
        });
        
        // Pre-save middleware to hash the password before saving
        agentSchema.pre('save', async function (next) {
          if (!this.isModified('password')) return next();
        
          try {
            const salt = await bcrypt.genSalt(10);
            this.password = await bcrypt.hash(this.password, salt);
            next();
          } catch (error) {
            next(error);
          }
        });
        
        // Method for comparing passwords during login/authentication
        agentSchema.methods.comparePassword = async function (candidatePassword) {
          return bcrypt.compare(candidatePassword, this.password);
        };
        
        // Virtual property to get agent's full name
        agentSchema.virtual('fullName').get(function () {
          return `${this.firstName} ${this.lastName}`;
        });
        
        // Virtual property to get the count of properties
        agentSchema.virtual('propertiesCount').get(function () {
          return this.properties.length;
        });
        
        // Indexing important fields for performance
        agentSchema.index({ email: 1 });
        agentSchema.index({ licenseNumber: 1 });
        agentSchema.index({ phoneNumber: 1 });
        agentSchema.index({ agency: 1 });
        agentSchema.index({ rating: 1 });
        agentSchema.index({ role: 1 });
        agentSchema.index({ agentStatus: 1 });
        agentSchema.index({ username: 1 });
        
        const Agent = mongoose.model('Agent', agentSchema);
        
        export default Agent;
      |-Faq.js
        import mongoose from 'mongoose';
        
        const faqSchema = new mongoose.Schema({
          question: {
            type: String,
            required: [true, "Question is required"],
            trim: true
          },
          answer: {
            type: String,
            required: [true, "Answer is required"],
            trim: true
          },
          category: {
            type: String,    // Category of FAQ, e.g., 'Registration', 'Payments', 'Account'
            default: 'General',
            trim: true
          },
          isPublished: {
            type: Boolean,   // Whether the FAQ is published or not
            default: true
          },
          priority: {
            type: Number,    // Priority or order in which FAQs should appear
            default: 0
          },
          tags: {
            type: [String],  // Tags to allow better filtering or searching of FAQs
            default: []
          }
        }, { timestamps: true });
        
        const FAQ = mongoose.model('FAQ', faqSchema);
        
        export default FAQ;
      |-User.js
        import mongoose from 'mongoose';
        import bcrypt from 'bcrypt';
        
        export const accountStatusEnum = ['active', 'pending', 'suspended', 'deactivated'];
        
        // Create the schema of the database
        const userSchema = new mongoose.Schema({
            firstName: {
                type: String,
                required: true,
            },
            lastName: {
                type: String,
                required: true,
            },
            username: {
                type: String,
                required: true,
                unique: true,
            },
            email: {
                type: String,
                required: [true, "Please enter an email"],
                unique: true,
                lowercase: true,
                match: [/\S+@\S+\.\S+/, 'Please enter a valid email']
            },
            avatar: {
                type: String,
                default: "https://cdn.pixabay.com/photo/2015/03/04/22/35/avatar-659651_640.png"
            },
            password: {
                type: String,
                minlength: [6, 'Minimum length is 6 characters'],
                validate: {
                    validator: function(value) {
                        return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,}$/.test(value);
                    },
                    message: 'Password must include at least one uppercase letter, one lowercase letter, and one number.'
                }
            },
            googleId: {
                type: String,
                required: false,
            },
            role: {
                type: String,
                enum: ['user'],
                default: 'user',
            },
            accountStatus: {
                type: String,
                enum: accountStatusEnum,
                default: 'active',
            },
            isEmailVerified: {
                type: Boolean,
                default: false,
            },
            lastLogin: {
                type: Date,
                default: null,
            },
            failedLoginAttempts: {
                type: Number,
                default: 0,
            },
            lockUntil: {
                type: Date,
                default: null,
            },
            isUsernameCustomized: {
                type: Boolean,
                default: false,
            },
            properties: [{
                type: mongoose.Schema.Types.ObjectId,
                ref: 'Property',
            }],
        }, 
        { timestamps: true }
        );
        
        userSchema.index({ email: 1 }, { unique: true });
        userSchema.index({ username: 1 }, { unique: true });
        userSchema.index({ properties: 1 });
        userSchema.index({ role: 1 });
        userSchema.index({ accountStatus: 1 });    
        
        // Hash the password before saving it to the database
        userSchema.pre('save', async function(next) {
            if (!this.isModified('password')) return next();
        
            try {
                this.password = await bcrypt.hash(this.password, 10);
                next();
            } catch (error) {
                next(error);
            }
        });
        
        // Instance method for password comparison (used for local login if needed)
        userSchema.methods.comparePassword = async function(password) {
            return bcrypt.compare(password, this.password);
        };
        
        // Method to update the last login time
        userSchema.methods.updateLastLogin = async function() {
            this.lastLogin = new Date();
            await this.save();
        };
        
        // Method to handle failed login attempts and lockout mechanism
        userSchema.methods.incrementFailedLogins = async function() {
            const MAX_ATTEMPTS = 5;
            this.failedLoginAttempts += 1;
        
            if (this.failedLoginAttempts >= MAX_ATTEMPTS) {
                this.lockUntil = new Date(Date.now() + 30 * 60 * 1000); // Lock account for 30 minutes
            }
        
            await this.save();
        };
        
        // Method to reset failed login attempts after successful login
        userSchema.methods.resetFailedLogins = async function() {
            this.failedLoginAttempts = 0;
            this.lockUntil = null;
            await this.save();
        };
        
        // Static method for login (handles both OAuth and local login)
        userSchema.statics.login = async function(email, password) {
            const user = await this.findOne({ email });
            if (user) {
                // Check if account is locked
                if (user.lockUntil && user.lockUntil > Date.now()) {
                    throw new Error("Account is temporarily locked due to multiple failed login attempts.");
                }
        
                const isMatch = await bcrypt.compare(password, user.password);
                if (isMatch) {
                    // Reset failed login attempts on successful login
                    await user.resetFailedLogins();
                    return user;
                } else {
                    // Increment failed login attempts on unsuccessful login
                    await user.incrementFailedLogins();
                    throw new Error("Incorrect password");
                }
            }
            throw new Error("Incorrect email");
        };
        
        userSchema.virtual('fullName').get(function() {
            return `${this.firstName} ${this.lastName}`;
        });
        
        const User = mongoose.model("User", userSchema);
        
        export default User;
  |-.git/
    |-refs/
      |-tags/
      |-heads/
      |-remotes/
        |-origin/
    |-hooks/
    |-branches/
    |-objects/
      |-79/
      |-2e/
      |-05/
      |-6b/
      |-b2/
      |-26/
      |-af/
      |-29/
      |-e3/
      |-4b/
      |-68/
      |-f6/
      |-80/
      |-9a/
      |-0b/
      |-c9/
      |-81/
      |-e9/
      |-f0/
      |-3c/
      |-a7/
      |-f2/
      |-67/
      |-e2/
      |-a0/
      |-d3/
      |-e8/
      |-f4/
      |-dd/
      |-e7/
      |-8a/
      |-98/
      |-pack/
      |-42/
      |-95/
      |-f5/
      |-a2/
      |-e4/
      |-c6/
      |-fb/
      |-b0/
      |-23/
      |-27/
      |-74/
      |-ce/
      |-1f/
      |-cf/
      |-de/
      |-63/
      |-32/
      |-34/
      |-c2/
      |-ee/
      |-bb/
      |-8b/
      |-c5/
      |-ac/
      |-d9/
      |-da/
      |-87/
      |-5f/
      |-ab/
      |-3f/
      |-2f/
      |-c3/
      |-db/
      |-99/
      |-91/
      |-57/
      |-f9/
      |-1b/
      |-ed/
      |-39/
      |-65/
      |-10/
      |-58/
      |-e0/
      |-7e/
      |-48/
      |-19/
      |-22/
      |-7c/
      |-ad/
      |-83/
      |-7b/
      |-0d/
      |-77/
      |-2a/
      |-50/
      |-56/
      |-dc/
      |-25/
      |-2c/
      |-40/
      |-09/
      |-88/
      |-5e/
      |-6f/
      |-5c/
      |-ba/
      |-d5/
      |-4c/
      |-38/
      |-2b/
      |-8d/
      |-b6/
      |-8f/
      |-54/
      |-15/
      |-04/
      |-9c/
      |-0f/
      |-9f/
      |-21/
      |-82/
      |-20/
      |-03/
      |-b9/
      |-0e/
      |-ca/
      |-1c/
      |-f8/
      |-72/
      |-53/
      |-b7/
      |-78/
      |-9d/
      |-4d/
      |-86/
      |-14/
      |-28/
      |-75/
      |-55/
      |-61/
      |-d6/
      |-d2/
      |-a8/
      |-33/
      |-a6/
      |-9e/
      |-1d/
      |-11/
      |-fa/
      |-b8/
      |-60/
      |-59/
      |-07/
      |-76/
      |-84/
      |-35/
      |-8c/
      |-4a/
      |-c4/
      |-f1/
      |-94/
      |-37/
      |-e5/
      |-c7/
      |-b3/
      |-7a/
      |-46/
      |-43/
      |-62/
      |-73/
      |-e6/
      |-92/
      |-17/
      |-fe/
      |-b4/
      |-90/
      |-13/
      |-24/
      |-70/
      |-cd/
      |-69/
      |-6e/
      |-eb/
      |-08/
      |-5d/
      |-aa/
      |-3a/
      |-3e/
      |-a3/
      |-3b/
      |-97/
      |-7d/
      |-b1/
      |-47/
      |-cb/
      |-c8/
      |-5a/
      |-ff/
      |-be/
      |-d4/
      |-96/
      |-66/
      |-a1/
      |-45/
      |-02/
      |-44/
      |-cc/
      |-0a/
      |-4f/
      |-e1/
      |-a5/
      |-6a/
      |-1a/
      |-18/
      |-30/
      |-36/
      |-0c/
      |-49/
      |-4e/
      |-ec/
      |-16/
      |-52/
      |-93/
      |-info/
    |-logs/
      |-refs/
        |-heads/
        |-remotes/
          |-origin/
    |-info/
